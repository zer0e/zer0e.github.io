<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zer0&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://re0.top/"/>
  <updated>2020-08-06T07:13:51.848Z</updated>
  <id>http://re0.top/</id>
  
  <author>
    <name>Zer0</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谈谈Spring IoC</title>
    <link href="http://re0.top/2020/08/06/spring_ioc/"/>
    <id>http://re0.top/2020/08/06/spring_ioc/</id>
    <published>2020-08-06T05:10:00.000Z</published>
    <updated>2020-08-06T07:13:51.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>IoC本身来说并不是一种技术，而是一种思想。在spring开发中我们常常使用，但有时候想起来这个概念时，却不知道从何说起。本文就来谈谈spring中的核心概念——IoC。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="IoC概念"><a href="#IoC概念" class="headerlink" title="IoC概念"></a>IoC概念</h2><p>IoC(Inversion of Control)中文名“控制反转”，它是一种设计的思想。Ioc代表着你将对象交给容器来控制，而不是自己控制对象本身。为什么是反转呢？举个例子：<br>我们在传统的开发中，通常是通过new关键字在对象内部使用另一个对象，是我们主动去创建依赖的对象。而Ioc则是有一个专门的容器来创建这些对象。我们通过自己主动控制生成对象的方式也叫做正转，而使用容器控制创建对象并注入的方式，就称作反转。</p><h2 id="IoC的作用"><a href="#IoC的作用" class="headerlink" title="IoC的作用"></a>IoC的作用</h2><p>IoC常常被用在大型框架上，由IoC容器去创建去查找依赖的对象，由容器去注入对象，使得对象之间是松耦合的，方便测试与功能的复用，也利于维护，让整体架构更加灵活。  </p><h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><p>前面提到了注入，也就是DI(Dependency Injection)，即“依赖注入”，是指组件之间的依赖关系由容器在运行期决定，即容器动态地将某个依赖关系注入到组件中。通过依赖注入，我们只需完成业务逻辑，无需关心资源的来源于由谁决定，一切都由容器帮忙注入依赖。</p><h2 id="IoC的技术实现"><a href="#IoC的技术实现" class="headerlink" title="IoC的技术实现"></a>IoC的技术实现</h2><p>既然已经清楚IoC的概念，那IoC容器又是怎么完成依赖注入呢？常见的方式有两种，构造器方法注入与setter注入。<br>构造器注入是指在对象创建时，所依赖的对象便以参数形式传入该对象中。假设在A类中需要B类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而setter方法注入则是在需要的时候才执行注入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而无论是哪种方法，IoC容器都帮你执行了，你无需关心注入的过程。  </p><h2 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h2><p>这里就简单介绍下IoC容器。<br>Spring 提供了两种IoC容器，BeanFactory和ApplicationContext，而ApplicationContext是BeanFactory的子类。BeanFactory 和 ApplicationContext 的区别有：<br>BeanFactory：是Spring中最底层的接口，只提供了最简单的IoC功能,负责配置，创建和管理bean。<br>在应用中，一般不使用 BeanFactory，而推荐使用ApplicationContext（应用上下文），原因如下。<br>ApplicationContext：</p><ol><li>继承了 BeanFactory，拥有了基本的 IoC 功能；</li><li>除此之外，ApplicationContext 还提供了以下功能：</li></ol><ul><li>支持国际化；</li><li>支持消息机制；</li><li>支持统一的资源加载；</li><li>支持AOP功能；</li></ul><h2 id="IoC容器初始化与依赖注入"><a href="#IoC容器初始化与依赖注入" class="headerlink" title="IoC容器初始化与依赖注入"></a>IoC容器初始化与依赖注入</h2><p>我们知道，IoC容器负责管理对象，而spring中最基本的一个对象就是Bean。<br>Bean的定义与初始化是两大步骤，Bean在定义后，IoC容器才将其初始化并注入到其他对象中。<br>Bean的定义有3步：  </p><ol><li>Resource 定位<br>Spring IoC 容器先根据开发者的配置，进行资源的定位，在 Spring 的开发中，通过 XML 或者注解方式查找资源。  </li><li>BeanDefinition 的载入<br>这个时候只是将 Resource 定位到的信息，保存到 Bean 定义（BeanDefinition）中，此时并不会创建 Bean 的实例</li><li>BeanDefinition 的注册<br>这个过程就是将 BeanDefinition 的信息发布到 Spring IoC 容器中。   </li></ol><p>但此时Bean并没有被初始化，只是在容器中被定义了。在Spring Bean的配置中，有个配置选项lazy-init，指定是否初始化Bean，默认值为false，即自动初始化，而设置为true则只有当使用getBean方法获取Bean时，才会进行Bean的初始化，完成依赖注入。  </p><h2 id="如何实现IoC容器？"><a href="#如何实现IoC容器？" class="headerlink" title="如何实现IoC容器？"></a>如何实现IoC容器？</h2><p>实现一个IoC容器有以下几个步骤。  </p><ol><li>通过注解或者配置文件，查看A类的依赖对象是哪个类，获取类名。  </li><li>使用反射API，将类名实例化成对象实例。  </li><li>将实例化对象通过构造函数或者setter方法，传递给A类。  </li></ol><p>其实Spring就是基于以上几个步骤实现IoC，IoC就是工厂模式的升级版。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文基本上都是基础知识，重点讲了IoC的概念，并顺便谈了IoC的实现原理，之后有需要的话可能会深入spring源码了解更多IoC的细节，比如BeanFactory和ApplicationContext。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;IoC本身来说并不是一种技术，而是一种思想。在spring开发中我们常常使用，但有时候想起来这个概念时，却不知道从何说起。本文就来谈谈spr
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="java" scheme="http://re0.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java线程池</title>
    <link href="http://re0.top/2020/07/24/java_thread_pool/"/>
    <id>http://re0.top/2020/07/24/java_thread_pool/</id>
    <published>2020-07-24T05:10:00.000Z</published>
    <updated>2020-07-24T10:05:42.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇来讲讲Java中线程池的使用与分析。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>阿里巴巴Java开发手册中强调，线程资源必须通过线程池来提供，不允许显式创建线程。<br>首先我们讲讲普通的线程创建方式。  </p><h2 id="Java线程创建方式"><a href="#Java线程创建方式" class="headerlink" title="Java线程创建方式"></a>Java线程创建方式</h2><p>在Java语言中，我们通过两种方式创建一个新线程，分别是继承Thread类或者实现Runnable接口。</p><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>Thread类本质上是实现了Runnable接口的一个实例，启动线程的方法是通过Thread类的start方法，这个方法是native方法，它将启动线程，并在获得时间片后执行run方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThread run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><p>如果该类已经继承其他类，由于java是单继承，所以只能实现runnable接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThread run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>这里值得一提的是，start方法是启动一个线程，线程处于就绪状态，而run方法则是直接执行，线程进入了运行状态。start方法之后会直接执行完毕，等待后续cpu的调度来执行这个线程，如果是run方法则直接在当前线程运行了方法，影响接下来的代码。因此只有start方法才能是多线程执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).run();</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 输出两个main 如果是start方法，输出不同线程。</span></span><br></pre></td></tr></table></figure></p><p>通常情况下如果需要一个异步操作，那直接在类里new Thread实例并传入Runnable实例，重写run方法就可以简单实现一个多线程操作，但这种方法并不提倡。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></p><h2 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h2><p>前面说了创建线程的方式，那为什么阿里不让程序员这样创建线程呢？原因在于以下几点：</p><ul><li>每次new Thread实例性能会逐渐变差。</li><li>线程没法统一管理，容易出现线程无限制创建，严重会有线程间相互竞争导致死锁，再严重些会导致占用过多资源而导致OOM。   </li></ul><p>而相比于new Thread，Java中提供的四种线程池有几点好处：</p><ul><li>在创建和销毁线程时所消耗时间与系统资源的开销大幅度减小。  </li><li>可以提供定时执行，并发控制等高级功能。 </li></ul><h2 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h2><p>Java中通过Executors提供四种线程池，分别为：  </p><ul><li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</li><li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。  </li></ul><p>Executors源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">            (parallelism,</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">            (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, threadFactory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>我们查看源码可以知道，Executors类使用了ThreadPoolExecutor类创建了一个简单线程池。我们接着跟进ThreadPoolExecutor类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们得知，ThreadPoolExecutor提供了四种构造器，但前三种构造器其实是调用了第四种构造方法而已。接下来看看几个参数的作用：  </p><ul><li>corePoolSize： 线程池核心线程数最大值</li><li>maximumPoolSize： 线程池最大线程数大小</li><li>keepAliveTime： 线程池中非核心线程空闲的存活时间大小</li><li>unit： 线程空闲存活时间单位</li><li>workQueue： 存放任务的阻塞队列</li><li>threadFactory： 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。</li><li>handler：  线城池的饱和策略事件，主要有四种类型。  </li></ul><p>我们可以看看源码中线程池的执行流程，即execute方法，源码中的注释已经十分清楚。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>翻译一下： </p><ul><li>提交一个任务，如果线程池中存活的核心线程小于线程数corePoolSize，线程池会创建一个核心线程去处理提交的任务。</li><li>如果核心线程池已满，一个新的任务会放到任务队列workQueue中排队等待执行。</li><li>当corePoolSize已满，并且workQueue也满，判断线程数是否达到maximumPoolSize，如果没达到，就创建一个非核心线程来执行任务。</li><li>如果线程数达到maximumPoolSize，直接采取拒绝策略。</li></ul><p>顺带一提四种拒绝策略： </p><ul><li>AbortPolicy(抛出一个异常，默认的)</li><li>DiscardPolicy(直接丢弃任务)</li><li>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</li><li>CallerRunsPolicy（交给线程池调用所在的线程进行处理) </li></ul><p>至此，线程池的工作原理基本上讲完了。但在阿里巴巴Java开发手册中有这么一条：  </p><blockquote><p>【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors返回的线程池对象的弊端如下： 1） FixedThreadPool和SingleThreadPool： 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。 2） CachedThreadPool： 允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。  </p></blockquote><p>仔细看源码，确实Executors在创建线程池时，workQueue并没有指定最大大小，可能会导致堆积大量的请求，即没有实行拒绝策略。 </p><h2 id="线程池的工作队列"><a href="#线程池的工作队列" class="headerlink" title="线程池的工作队列"></a>线程池的工作队列</h2><ul><li>ArrayBlockingQueue：有界队列，使用数组实现，FIFO。</li><li>LinkedBlockingQueue：基于链表的可设置容量的阻塞队列，默认最大长度为Integer.MAX_VALUE。</li><li>DelayQueue：延迟队列，是一个任务定时周期的延迟执行的队列。根据指定的时间从小到大排列，否则否则根据插入到队列的时间先后排序。</li><li>PriorityBlockingQueue：优先级队列。</li><li>SynchronousQueue：同步队列，不存储元素，每个插入操作必须等到另一个线程进行移除操作，否则一直阻塞。</li></ul><h2 id="几种常见线程池"><a href="#几种常见线程池" class="headerlink" title="几种常见线程池"></a>几种常见线程池</h2><p>前面只是稍微提到几种线程池，这边详细说说每种线程池。</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>源码在上头，这里我就不贴了。可以知道，这个线程池特点是核心线程数与最大线程数相同，并且没有非空闲时间，即keepAliveTime为0，再有就是阻塞队列使用的是LinkedBlockingQueue。<br>在Executors中newFixedThreadPool的阻塞队列是无界的，也就是如果核心线程执行的时间过长，会导致大量的任务插入到队列中，最终导致OOM。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; Integer.MAX_VALUE;i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded</span></span><br></pre></td></tr></table></figure></p><p>因此fixedThreadPool适用于cpu密集的任务，cpu长期被使用的情况下，尽可能少分配线程，适合执行长期的任务。  </p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>这个线程池的核心线程数为0，最大线程数为Integer.MAX_VALUE，阻塞队列为SynchronousQueue，非核心线程的空闲存活时间为60秒。<br>因为没有核心线程，所以添加任务后直接添加进阻塞队列，判断是够有空闲进程，如果有，取出去执行任务，如果没有，就创建一个线程执行，执行完任务的线程有60秒的存活时间，如果再次接到任务，则可以活下去，否则被销毁。<br>这种线程池适合并发执行短期的小任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"   "</span> + System.currentTimeMillis() + <span class="string">"   running now"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如果提交任务速度小于处理任务的速度，则只会使用一个线程重复使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"   "</span> + System.currentTimeMillis() + <span class="string">"   running now"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>特点为核心线程数为1，最大线程数也为1，阻塞队列是LinkedBlockingQueue，keepAliveTime为0。<br>这个线程池的特点就是只有一个线程在工作，如果有任务到来，线程空闲就执行任务，线程繁忙就把任务加到阻塞队列中，直到线程从队列中取出任务执行。<br>适合串行执行任务的场景。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"   "</span> + System.currentTimeMillis() + <span class="string">"   running now"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>特点是最大线程数为Integer.MAX_VALUE，阻塞队列是DelayedWorkQueue，keepAliveTime为0。<br>工作机制为：添加一个任务到阻塞队列中，线程池中的线程从阻塞队列中取任务，取time大于当前时间的任务，执行完将任务的time修改为下次执行的时间，并将这个任务放到阻塞队列中。<br>这种线程池适合周期执行定时任务的场景。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        executorService.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"   "</span> + System.currentTimeMillis() + <span class="string">"   running now"</span>);</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h1><p>本文讲了Java中四种常见的线程池，并学习相应的工作原理与应用常见，尽管阿里开发手册中不允许直接使用Executors中的线程池，但理解这几种线程池十分重要，如果需要创建线程池的话，可以通过ThreadPoolExecutor自定义所有参数来创建，让代码阅读者明白为什么要这样创建。通过这次的学习，对java线程池的理解确实有学到不少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇来讲讲Java中线程池的使用与分析。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="java" scheme="http://re0.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈动态规划Ⅲ</title>
    <link href="http://re0.top/2020/07/20/dp3/"/>
    <id>http://re0.top/2020/07/20/dp3/</id>
    <published>2020-07-20T08:10:00.000Z</published>
    <updated>2020-07-23T15:21:11.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近准备秋招感觉自己还是蛮菜的，啥都不会。但学习还是得继续，偶尔趁着休息时间来写写文章。这篇大概是最后一篇整理动态规划题目，感觉整理多了也没用，只有自己去理解才真正有用。话不多说，开始正文。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="地下城游戏"><a href="#地下城游戏" class="headerlink" title="地下城游戏"></a>地下城游戏</h2><blockquote><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。为了尽快到达公主，骑士决定每次只向右或向下移动一步。   </p></blockquote><p>来自<a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener">leetcode 174题</a><br>这道题目很像我在<a href="/2020/04/05/dp1/">浅谈动态规划Ⅰ</a>中所讲的入门题目，即最小路径权重问题。但如果我们从左上角开始进行动态规划，我们只能知道起点到终点的所需要最小血量，但是<strong>并不能保证当到达每个点时的血量不低于1</strong>。所以我们采用反向dp，即从右下角往起点进行动态规划。<br>我们令dp[i][j]为坐标(i,j)到终点所需要的最小血量。那么我们的最终答案就是dp[0][0]。<br>接下来是动态转移方程。我们先考虑dp[m-1][n-1]，也就是终点到终点需要的血量，很容易想到，应该是<code>max(1,1-dungeon[m-1][n-1])</code>，因为血量不能低于1，如果有怪物的话需要怪物血量加上1，两者取大值。<br>那其他点呢，很简单，我们需要的最少血量，而且每次只能从右或者从下走一格，因为我们是反向dp，(i,j)坐标获取的状态应该是(i+1,j)和(i,j+1)，所以对应的应该是dp[i+1][j]和dp[i][j+1]的较小值，再减去当前坐标的值，与1对比取大值，即<code>dp[i][j] = max(1,min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j])</code>。<br>在dp数组空间的选择上，有两个选择，一种是m*n，另一种是 (m+1)*(n+1)，这两个选择其实是对边界的处理有差别。<br>如果采用m*n的数组空间，那么我就必须对dp[m-1][n-1]，即终点位置进行独立地初始化，并且需要对dp[i][n-1]与dp[m-1][j]这一行一列进行独立赋值，避免数组越界。<br>而采用(m+1)*(n+1)的空间，只需要把外围空间赋值为无穷大，并对终点的下方和右方赋值为1，便可实现使用一个状态转移方程完成全部计算。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//m*n</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dungeon == <span class="keyword">null</span> || dungeon.length == <span class="number">0</span> || dungeon[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = dungeon.length;</span><br><span class="line">        <span class="keyword">int</span> n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        dp[m-<span class="number">1</span>][n-<span class="number">1</span>] = Math.max(<span class="number">1</span>,<span class="number">1</span>-dungeon[m-<span class="number">1</span>][n-<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m-<span class="number">2</span>;i &gt; -<span class="number">1</span>;i--)&#123;</span><br><span class="line">            dp[i][n-<span class="number">1</span>] = Math.max(<span class="number">1</span>,dp[i+<span class="number">1</span>][n-<span class="number">1</span>] - dungeon[i][n-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">2</span>;i &gt;-<span class="number">1</span>;i--)&#123;</span><br><span class="line">            dp[m-<span class="number">1</span>][i] = Math.max(<span class="number">1</span>,dp[m-<span class="number">1</span>][i+<span class="number">1</span>] - dungeon[m-<span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m-<span class="number">1</span>;i &gt; -<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n-<span class="number">1</span>;j &gt; -<span class="number">1</span> ; j--)&#123;</span><br><span class="line">                dp[i][j] = Math.max(<span class="number">1</span>,Math.min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]) - dungeon[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(m+1)*(n+1)空间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dungeon == <span class="keyword">null</span> || dungeon.length == <span class="number">0</span> || dungeon[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = dungeon.length;</span><br><span class="line">        <span class="keyword">int</span> n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[n][m - <span class="number">1</span>] = dp[n - <span class="number">1</span>][m] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m-<span class="number">1</span>;i &gt; -<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n-<span class="number">1</span>;j &gt; -<span class="number">1</span> ; j--)&#123;</span><br><span class="line">                dp[i][j] = Math.max(<span class="number">1</span>,Math.min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]) - dungeon[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但其实只是因为第二种方法更简单些，并且不用额外初始化，时间复杂度是一样的。如果要更进一步，因为dp[i][j]状态只与dp[i+1][j]与dp[i][j+1]有关，所以我们可以使用滚动数组方法来降低空间复杂度，这里就不再展开。  </p><h2 id="最低票价"><a href="#最低票价" class="headerlink" title="最低票价"></a>最低票价</h2><blockquote><p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。火车票有三种不同的销售方式：<br>一张为期一天的通行证售价为 costs[0] 美元；<br>一张为期七天的通行证售价为 costs[1] 美元；<br>一张为期三十天的通行证售价为 costs[2] 美元。<br>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。<br>返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。  </p></blockquote><p>来自<a href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/" target="_blank" rel="noopener">leetcode 983题</a><br>思路还是比较简单的，先定义状态，很显然，这是个一维dp问题，所有我们定义dp[i]为第i天所需要花费的费用。</p><ul><li>如果当天没有旅游，那么dp[i] = dp[i-1]</li><li>如果当前是旅游的，那么我们应该从三种方案中选择最小花费，也就是dp[i] = min(dp[i-1]+costs[0],dp[i-7]+cost[1],dp[i-30]+costs[2]).这里需要注意数组越界问题。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="keyword">int</span>[] days, <span class="keyword">int</span>[] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = days.length;</span><br><span class="line">        <span class="keyword">int</span> m = days[n-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">int</span> day_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i != days[day_index])&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                day_index++;</span><br><span class="line">                dp[i] = min(dp[Math.max(<span class="number">0</span>,i-<span class="number">1</span>)]+costs[<span class="number">0</span>],dp[Math.max(<span class="number">0</span>,i-<span class="number">7</span>)]+costs[<span class="number">1</span>],dp[Math.max(<span class="number">0</span>,i-<span class="number">30</span>)] + costs[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(Math.min(a,b),c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </li></ul><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><blockquote><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。<br>注意：你不能在买入股票前卖出股票。</p></blockquote><p>来自<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">leetcode 121题</a><br>这道题目其实只要一次遍历过程中维护一个最小值就可以解决。如果用动态规划的解法呢？<br>买卖股票，无非就是两种状态，一种买入，一种卖出，两种状态我们定义二维数组dp，先定义买入收益为dp[0](注意这里收益是负的)，卖出的收益为dp[1]，买入的成本应该是<code>dp[0][i] = max(dp[0][i-1],-prices[i])</code>，因为是负数，所以用max。而卖出的收益应该为第i-1天卖出的收益与i-1天时买入收益加上当天股价，取两者较大者，即<code>dp[1][i] = max(dp[1][i-1],dp[0][i-1]+prices[0])</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][n];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][i] = Math.max(dp[<span class="number">1</span>][i-<span class="number">1</span>],dp[<span class="number">0</span>][i-<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[<span class="number">0</span>][i] = Math.max(dp[<span class="number">0</span>][i-<span class="number">1</span>],-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n-<span class="number">1</span>]; <span class="comment">// 最大收益只在卖出状态中产生。</span></span><br><span class="line">        <span class="comment">// return Math.max(dp[0][n-1],dp[1][n-1]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>上面代码中第一维是状态，第二维是时间。<br>我们可以更换一下以更好理解下一道题目。dp[i]代表第i天，dp[i][0]代表第i天卖出的收益(即不持股)，而dp[i][1]代表第i天买入的收益(即持股)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><h2 id="买卖股票的最佳时机Ⅱ"><a href="#买卖股票的最佳时机Ⅱ" class="headerlink" title="买卖股票的最佳时机Ⅱ"></a>买卖股票的最佳时机Ⅱ</h2><p>来自<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">leetcode 122题</a><br>这道题相比上一道，多了一个可以多次买卖的条件。因此买入的状态可以由卖出的状态来进行转移，即持股的状态可以由不持股的状态转移而来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><h2 id="买卖股票的最佳时机含冻结期"><a href="#买卖股票的最佳时机含冻结期" class="headerlink" title="买卖股票的最佳时机含冻结期"></a>买卖股票的最佳时机含冻结期</h2><p>这道题比上面那道多了一个冻结期，即卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)，并且不限制买卖次数。<br>来自<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">leetcode 309题</a><br>这道题由于多了冻结期的概念，所以应该比上一道题多一种状态，dp[i]依旧表示第i天的收益，而第二维有三个状态，分别为不持股，持股，冻结期。然后分析状态转移方程，首先不持股是由昨天不持股和昨天持股今天买股两种状态转移而来，而持股的状态则是由昨天持股与昨天冻结，今天买股两个状态转移而来。<br>翻译成代码就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是本次整理的几道题目，我个人感觉股票问题是十分经典的，并且层层递进，还有几道股票题目没有整理出来，如果有闲下来的时间，下次再整理吧。整理题目也算是一种复习吧，感觉对动态规划的理解又加深不少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近准备秋招感觉自己还是蛮菜的，啥都不会。但学习还是得继续，偶尔趁着休息时间来写写文章。这篇大概是最后一篇整理动态规划题目，感觉整理多了也没
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>浅谈数据库主从复制</title>
    <link href="http://re0.top/2020/07/04/database_master_slave/"/>
    <id>http://re0.top/2020/07/04/database_master_slave/</id>
    <published>2020-07-04T05:10:00.000Z</published>
    <updated>2020-07-04T09:27:17.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前陆陆续续写了几篇高并发架构的文章，本篇文章是浅谈高并发架构系列的最后一篇。<br>前面说过，单点故障是影响整个高并发系统的重要原因，在单点的服务出现故障时有可能影响整个系统的运行。而数据库作为数据存放的服务，是最底层的服务，使用的频率也是非常高的。因此有必要将单点数据库系统进行多节点复制，以至于在一个节点出现故障时，另一个节点能够提供正常的数据库服务，这种方式也被称为容灾。<br>今天这篇文章讲的是将数据库进行多节点复制，也就是数据库的主从复制，从而达到多个数据库服务同时存在和正常运行的目的。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h2><p>前面说过，主从复制的一个优点就是做数据的备份，当主数据库故障后，可以马上切换数据库，防止数据的丢失。其次，可以加快数据库的存储与写入，例如不同的数据库负责不同的事物，例如读写分离，提升单机的性能。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们这里就使用mysql作为数据库。<br>mysql服务中，有一个文件叫做二进制日志文件(binary log file)，通常这个文件需要手动开启，这个文件记录着所有执行的操作，如果一台服务器启用这个文件后，那另一台服务器就可以通过读取这个文件，将master的所有操作都复制到自己身上，从而达到数据库的主从复制。<br>通常情况下，可以分为以下几个步骤执行：  </p><ol><li>主库启用bin log，所有事件都会写入到日志当中。</li><li>从库启用slave服务，连接到主库。</li><li>从库创建一个I/O线程，从主库读取到bin log内容并写入relay log中。</li><li>从库创建一个SQL线程，从relay log中读取内容，并将更新内容写入到从库。 </li></ol><p>值得一提的是，老版本的mysql其实读取与执行操作是由一个线程完成的，导致复制bin log与执行操作是一个串行的过程，性能受到限制。后来为了提高性能，便将这个两个操作交由两个线程完成。  </p><h2 id="深入了解"><a href="#深入了解" class="headerlink" title="深入了解"></a>深入了解</h2><p>从上面我们可以知道主从复制的基本原理与操作，接下来我们讲讲常见的主从配置。  </p><h3 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h3><p>这个配置是最常见的，也是最简单的架构，slave之前并不通信，而是只与master进行通信。这种架构广泛应用在读压力较大的场景中。  </p><h3 id="主主复制"><a href="#主主复制" class="headerlink" title="主主复制"></a>主主复制</h3><p>这个情况下，两个数据库即是master，又是相互的slave。这样任何一方有变更，便会同步到另一方的数据库中。这个架构其实可以变为主动-被动mm架构与带从服务器的mm架构。</p><ul><li>主动-被动模式的Master-Master(Master-Master in Active-Passive Mode)<br>这种模式是一种具有容错与高可用的架构，即一个节点故障之后马上会有另一个节点接替服务，也就是我们上文所提到的可实现高可用的架构。 </li><li>带从服务器的Master-Master(Master-Master with Slaves)<br>这种模式提供了冗余，即在保证高可用架构的同时，将读请求放在slave上，提高数据库的整体性能。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文重点讲述了mysql主从复制的原理与几种主从架构，但是对如何配置并没有详细讲解，之后在项目中遇到会稍微写写。<br>那这个浅谈高并发架构就告一段落了，如果有更深入的理解，我也会第一时间写出来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前陆陆续续写了几篇高并发架构的文章，本篇文章是浅谈高并发架构系列的最后一篇。&lt;br&gt;前面说过，单点故障是影响整个高并发系统的重要原因，在单
      
    
    </summary>
    
    
      <category term="架构" scheme="http://re0.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="数据库" scheme="http://re0.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>常见的负载均衡算法</title>
    <link href="http://re0.top/2020/06/24/load_balancing_algorithm/"/>
    <id>http://re0.top/2020/06/24/load_balancing_algorithm/</id>
    <published>2020-06-24T09:10:00.000Z</published>
    <updated>2020-06-25T07:36:44.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章讲了负载均衡的几种实现方式，这期就重点讲讲当请求到达负载均衡服务器时，服务器可以根据哪些算法来进行分配请求。 </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="轮询法"><a href="#轮询法" class="headerlink" title="轮询法"></a>轮询法</h2><p>这种方法很简单，就是按照顺序轮流将请求分配到各个服务器上，对服务器的状态和负载情况并不关注。<br>由于需要对pos变量进行操作，如果是高并发场景必须加写锁，并且会导致并发吞吐量的明显下降。<br>以下代码实现了一个简单的轮询。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BalanceServer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.servers = [<span class="string">"192.168.1.1"</span>,<span class="string">"192.168.1.2"</span>,<span class="string">"192.168.1.3"</span>,<span class="string">"192.168.1.4"</span>]</span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_server</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.pos == len(self.servers):</span><br><span class="line">            self.pos = <span class="number">0</span></span><br><span class="line">            <span class="comment"># self.pos %= len(self.server)</span></span><br><span class="line">        </span><br><span class="line">        server = self.servers[self.pos]</span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> server</span><br></pre></td></tr></table></figure></p><h2 id="随机法"><a href="#随机法" class="headerlink" title="随机法"></a>随机法</h2><p>这种方法与轮询差不多，将请求进行随机分配，当分配量足够大时，相当于将请求平均分配到每个服务器上。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BalanceServer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.servers = [<span class="string">"192.168.1.1"</span>,<span class="string">"192.168.1.2"</span>,<span class="string">"192.168.1.3"</span>,<span class="string">"192.168.1.4"</span>]</span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_server_by_random</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.servers[random.randint(<span class="number">0</span>,len(self.servers)<span class="number">-1</span>)]</span><br></pre></td></tr></table></figure></p><h2 id="源地址hash法"><a href="#源地址hash法" class="headerlink" title="源地址hash法"></a>源地址hash法</h2><p>这种方法是通过获取访问客户端的ip地址，通过hash函数算出ip地址的hash值，然后通过hash值对服务器列表长度取模，获得访问的服务器序号。<br>这种方法的好处在于每次客户端访问的服务器都是同一个，便于建立有状态的session会话。<br>而缺点在于如果有服务器扩展或者下线时，如果通过源地址hash算法获得的服务器资源可能会不存在，如session或者缓存，导致请求的失败。如果是缓存服务器，则可能导致缓存击穿或者缓存雪崩(详见下文)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BalanceServer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.servers = [<span class="string">"192.168.1.1"</span>,<span class="string">"192.168.1.2"</span>,<span class="string">"192.168.1.3"</span>,<span class="string">"192.168.1.4"</span>]</span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_server_by_origin_hash</span><span class="params">(self,ip)</span>:</span></span><br><span class="line">        ip_hash_code = hash(ip)</span><br><span class="line">        server = self.servers[ip_hash_code % len(self.servers)]</span><br><span class="line">        <span class="keyword">return</span> server</span><br></pre></td></tr></table></figure></p><h2 id="加权轮询法（Weight-Round-Robin）"><a href="#加权轮询法（Weight-Round-Robin）" class="headerlink" title="加权轮询法（Weight Round Robin）"></a>加权轮询法（Weight Round Robin）</h2><p>不同性能和配置的服务器对请求的抗压能力也不相同，让配置高，负载低的机器更高的权重，处理更多的请求，而配置低，负载高的机器则权重降低。通过权重我们可以重新构建服务器列表，然后再通过轮询获取服务器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BalanceServer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.servers = &#123;</span><br><span class="line">            <span class="string">'192.168.1.1'</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="string">'192.168.1.2'</span>:<span class="number">3</span>,</span><br><span class="line">            <span class="string">'192.168.1.3'</span>:<span class="number">4</span>,</span><br><span class="line">            <span class="string">'192.168.1.4'</span>:<span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_server_by_weight_round_robin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 这里可以避免服务器上下线</span></span><br><span class="line">        servers_list = []</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> self.servers.keys():</span><br><span class="line">            weight = self.servers[key]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(weight):</span><br><span class="line">                servers_list.append(key)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># self.pos需要加锁</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(servers_list):</span><br><span class="line">            self.pos = <span class="number">0</span></span><br><span class="line">        server = servers_list[self.pos]</span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> server</span><br></pre></td></tr></table></figure></p><p>注意，这里的服务器的权重应该根据状态动态调整，而不是只是一个固定值。  </p><h2 id="加权随机法"><a href="#加权随机法" class="headerlink" title="加权随机法"></a>加权随机法</h2><p>和加权轮询法类似，只是在最后选择服务器上使用随机数，这里便不多说了。  </p><h2 id="最小连接数法"><a href="#最小连接数法" class="headerlink" title="最小连接数法"></a>最小连接数法</h2><p>这种方法较为灵活，它是站在后端服务器的角度，根据当前服务器集群的连接情况，动态选取一台当前积压连接数最少的服务器来处理本次请求，合理的进行分流。 </p><h2 id="后续思考"><a href="#后续思考" class="headerlink" title="后续思考"></a>后续思考</h2><h3 id="使用hash算法的问题"><a href="#使用hash算法的问题" class="headerlink" title="使用hash算法的问题"></a>使用hash算法的问题</h3><p>上文提到使用源地址hash算法选取服务器的问题，在有服务器上下线的情况下，缓存在对应的机器上没有，可能会导致诸多问题，轻一点的就是session消失，用户需要重新登录，而如果严重一点的话则会导致瞬间大量的请求获取不到缓存，从而把大量请求直接往db中打，轻则阻塞，重则宕机。我们举个例子：<br>假设刚开始有4台缓存服务器，分别为0,1,2,3号，hash(ip) = 6 ，那么hash(ip) % 4 = 2，那么我们就应该去2号缓存服务器上拿缓存。假设此时多了一台服务器4号，那么hash(ip) % 5 = 1，我们就变成了去1号缓存服务器拿缓存，那么可想而知，如果请求量够大，一瞬间就有去新服务器拿旧服务器的缓存，而新服务器没有缓存，就会去数据库中查找，相当于大规模的缓存瞬间失效了，导致<strong>缓存雪崩</strong>。 </p><h3 id="缓存穿透，缓存击穿，缓存雪崩"><a href="#缓存穿透，缓存击穿，缓存雪崩" class="headerlink" title="缓存穿透，缓存击穿，缓存雪崩"></a>缓存穿透，缓存击穿，缓存雪崩</h3><p>这三个概念不是本文重点，这里只是提个概念。<br>缓存穿透是指请求查询了一个不存在的数据，导致每次都去数据库查询，缓存服务器相当于失效，这种情况叫做缓存穿透。<br>缓存击穿是指大量的请求同时查询了一个已经失效的缓存，导致这些请求集体请求数据库。<br>缓存雪崩则是指某个时间发生了大规模的缓存失效问题，如缓存服务器宕机，或者是上文讲的由于hash取模所带来的问题。  </p><h3 id="一致性hash算法"><a href="#一致性hash算法" class="headerlink" title="一致性hash算法"></a>一致性hash算法</h3><p>由于常用的hash(obj) % N算法在对机器添加或者删除之后，会导致原来的许多数据无法找到，所以一致性hash算法诞生了。<br>一致性hash算法首先需要将0~(2^32)-1的数字形成一个环，可以想象成一个时钟。接着我们先将数据存储在环上，用上文的例子，即<br><code>hash(ip1)=key1,hash(ip2)=key2,hash(ip3)=key3</code>，<br>   这些key就是在环上的数字。接着我们同样通过hash算法将服务器的hash值映射到环上，例如<br><code>hash(server1)=KEY1,hash(server2)=KEY2,hash(server3)=KEY3,hash(server4)=KEY4</code>，<br>我们假设KEY1~KEY4分别在环的12点，3点，6点，9点钟方向，key1~key3分别在1点，4点，8点钟位置。<br>接着我们便可将key缓存到顺时针离自己最近的服务器上。即key1缓存在hash值KEY2的服务器上，key2缓存在KEY3的服务器上，key3缓存在KEY4的服务器上。<br><strong>接下来是机器的删除与添加。</strong>  </p><ol><li>删除<br>假设2号服务器宕机，即hash值为KEY3的服务器移除了，也就是6点钟的服务器移除了，那么影响到的只有key2，key2的映射位置从2号服务器移到3号服务器，也就是只有原本2号服务器上的数据收到影响，而没有改变其他服务器。  </li><li>添加<br>假设添加了一台服务器，hash(server5)位于时钟的2点钟方向，那么根据顺时针迁移，则key1的数据迁移到该服务器上，其他对象没有影响。  </li></ol><p>一致性hash算法将数据的迁移达到了最小，只有一部分数据需要迁移，而不是所有数据都进行迁移，这样的算法对于高并发，分布式的服务是十分合适的，避免了大量数据的迁移，减小了服务器压力。<br>如果文字讲解不够清楚的话，推荐可以看看<a href="https://blog.csdn.net/cywosp/article/details/23397179" target="_blank" rel="noopener">图解</a>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文讨论了负载均衡的几种算法，并对hash算法带来的数据迁移问题进行讨论，讲解了一致性hash算法来解决问题。本文对于缓存服务出现的三种问题并没有深入讨论，没有提出解决方案，这部分内容之后也会单独写写。那么这个高并发系列就还剩下数据库的主从复制。<br>ps.由于图床的原因，最近的文章都没有添加图片，主要是不好管理，虽然有备份，但图床失效后，后续迁移工作十分繁琐，所以作者尽量不添加图片来讲述原理，望理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇文章讲了负载均衡的几种实现方式，这期就重点讲讲当请求到达负载均衡服务器时，服务器可以根据哪些算法来进行分配请求。 &lt;/p&gt;
&lt;h1 i
      
    
    </summary>
    
    
      <category term="架构" scheme="http://re0.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>浅谈负载均衡</title>
    <link href="http://re0.top/2020/06/15/load_balancing/"/>
    <id>http://re0.top/2020/06/15/load_balancing/</id>
    <published>2020-06-15T09:10:00.000Z</published>
    <updated>2020-06-20T08:56:06.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面对大量的访问请求与海量的数据，我们可以通过加大单机的性能来实现服务的稳定，还可以考虑拆分系统来防止单机故障。<br>负载均衡（Load Balance）是指将负载（例如访问请求，任务等等）进行平衡分摊到多个服务器或组件上执行，以提高性能，作为单点故障的解决方案。<br>本文将讨论常见的负载均衡分类。</p><h1 id="负载均衡分类"><a href="#负载均衡分类" class="headerlink" title="负载均衡分类"></a>负载均衡分类</h1><p>从实现方式不同，可以分为软件实现与硬件实现。从实现的节点不同，我们可以分为DNS负载均衡，HTTP负载均衡，IP负载均衡，链路层负载均衡等等。</p><h2 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h2><p>这是一种利用域名解析来实现的负载均衡技术，在DNS服务器上配置多个A记录，这些A记录对应的是服务器集群，在大型网站中，DNS解析通常作为第一级负载均衡。<br>优点有：  </p><ul><li>使用简单，全交给DNS服务器来处理，不需要额外配置负载均衡服务器。  </li><li>基于用户的地址，可以解析成距离用户最近的服务器地址，加快访问速度。  </li></ul><p>缺点有：  </p><ul><li>DNS服务是多级服务，在增加或者修改DNS后，需要较长时间才能传递到全网。在这段时间内用户可能会访问失败。  </li><li>维护性差。由于DNS服务不能知道服务器的负载情况，所以支持的算法较少，无法根据服务器当前负载量进行调节。  </li><li>DNS的控制器通常来说在域名商手里，导致无法做更多的扩展。  </li></ul><h2 id="HTTP负载均衡"><a href="#HTTP负载均衡" class="headerlink" title="HTTP负载均衡"></a>HTTP负载均衡</h2><p>这是一种利用反代技术来转发HTTP流量的技术，通常使用Nginx作为负载均衡工具，在用户的HTTP请求到达后，由反向代理服务器根据算法，将HTTP请求发送给相应的服务器，服务器完成处理后，再将数据返回给代理服务器，由代理服务器将数据转交给用户。<br>优点有：  </p><ul><li>没有暴露真实服务器ip。可以有效的隐藏内网信息。  </li><li>支持的算法较多，可以根据需求不同来配置不同负载均衡策略。 </li><li>安装和配置相对简单。  </li></ul><p>缺点有：  </p><ul><li>对服务器的健康检查只支持端口检测，而不支持url检测。如出现错误，则会转至另一服务器进行重试。  </li><li>适用的范围较小，只支持http，https等协议。  </li></ul><h2 id="IP负载均衡"><a href="#IP负载均衡" class="headerlink" title="IP负载均衡"></a>IP负载均衡</h2><p>在网络层通过修改目的地址来实现负载均衡。用户请求到达负载均衡服务器后，负载均衡服务器从负载均衡算法得到一个真实服务器地址，将ip数据报的目的地址改为改真实服务器的地址。真实服务器处理完成后，将响应数据包返回给负载均衡服务器，负载均衡服务器再将ip数据报的源地址改为自身的ip地址，发送给用户。<br>其中，真实服务器将数据返回给负载均衡服务器时，存在两种方式，第一种是负载均衡服务器作为真实服务器集群的网关，则不用配置其他东西。第二种方式是负载均衡服务器在修改目的ip地址的同时修改源地址，然后就可从真实服务器收到返回数据，这种方式成为源地址转换(snat)。  </p><h2 id="链路层负载均衡"><a href="#链路层负载均衡" class="headerlink" title="链路层负载均衡"></a>链路层负载均衡</h2><p>工作在数据链路层，通过修改mac地址来进行负载均衡。在用户请求到达时，不修改ip地址，而是修改目的mac地址，配置真实服务器集群与负载均衡服务器的ip一致，达到不修改ip地址来进行数据转发。这种方式也成直接路由模式（DR模式）。     </p><h2 id="混合型负载均衡"><a href="#混合型负载均衡" class="headerlink" title="混合型负载均衡"></a>混合型负载均衡</h2><p>通常作为一个大型架构，不会只使用一种负载均衡方案，而是采用多个负载均衡方案来实现。<br>这里举个简单方式：<br>用户进行DNS查询时，由DNS服务器根据负载均衡算法返回不同的反向代理服务器，再由反向代理服务器将请求分配给应用负载均衡服务器，接着由应用负载均衡服务器通过ip模式或者DR模式进行请求转发。<br>这种方式反向代理服务器不仅用于请求的转发，并且可以缓存静态资源，当请求是静态资源时，可以直接返回，而不是将请求进行转发。如果是动态页面时，则请求后面的应用负载均衡服务器。  </p><p>由于混合模式需要根据具体场景来灵活搭配各种方式，所以以上的方式仅供参考。  </p><h2 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h2><p>硬件负载均衡是直接在服务器与外部网络间安装负载均衡设备。一般而言，硬件负载均衡在功能、性能上优于软件方式。硬件负载均衡通常用作全局负载均衡，搭配软件负载均衡来实现整个负载均衡架构。常见的硬件负载均衡器有F5和A10。<br>优点： 能够直接通过智能交换机实现,处理能力更强，而且与系统无关，负载性能强。<br>缺点： 成本高，配置冗余。负载均衡器可能无法掌握服务器集群的状态，而是从网络的层面来判断负载情况，网络负载正常的情况下，也可能应用层已经阻塞了。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上主要从负载均衡的分类入手，对各种负载均衡进行介绍，并简单介绍了常见负载均衡架构。<br>之后会单独聊聊负载均衡的算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;面对大量的访问请求与海量的数据，我们可以通过加大单机的性能来实现服务的稳定，还可以考虑拆分系统来防止单机故障。&lt;br&gt;负载均衡（Load B
      
    
    </summary>
    
    
      <category term="架构" scheme="http://re0.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>浅谈高并发引起的问题</title>
    <link href="http://re0.top/2020/06/14/high_concurrency/"/>
    <id>http://re0.top/2020/06/14/high_concurrency/</id>
    <published>2020-06-14T05:10:00.000Z</published>
    <updated>2020-06-14T08:40:46.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实在学生时代，基本上是遇不到高并发的架构，真正遇到高并发的问题，往往是在工作之后，我在学生时代所写的很多项目其实跟高并发是一点边都沾不上，但是我依旧学习了许多高并发的知识，希望以后能派上用场。<br>当然，其实脱离了实际去讲述高并发并不是正确的，因为不同的系统架构是不一致的，分析高并发与高可用性需要先分析整体架构再来定夺。<br>本篇文章就是整理在高并发架构下会产生哪些问题，以及部分解决方案，当然也可能将解决方案单独用一篇文章来讲述。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="何为高并发"><a href="#何为高并发" class="headerlink" title="何为高并发"></a>何为高并发</h2><p>高并发（High Concurrency）是系统设计的一个重要概念，它的目的是让系统能够同时<strong>并行</strong>处理多个请求。<br>同时与高并发相关的还有许多名词，如每秒请求数(QPS(Query Per Second))，响应时间(Response Time)，吞吐量(Throughput)等等。   </p><h2 id="高并发所带来的问题"><a href="#高并发所带来的问题" class="headerlink" title="高并发所带来的问题"></a>高并发所带来的问题</h2><p>其实我个人认为高并发带来的问题可以简单分为两个部分，一个是服务故障，另一个是数据的不一致。当然如果数据库服务故障也可能导致数据的不一致性，这里我就简单这么分类。</p><h3 id="服务单点故障"><a href="#服务单点故障" class="headerlink" title="服务单点故障"></a>服务单点故障</h3><p>这个问题是许多架构在遇到高并发请求时所遇到的最基础的问题，如何在如此高的请求量之下保证服务不被击穿。<br>其实解决这个问题的最好办法是将一个系统拆分成多个系统，再配合负载均衡来实现。简单来说，负载均衡器根据每个系统的性能高低分配请求，如果一个系统故障，另一个系统也可以正常提供服务。<br>也就是说要避免单点，而是将单点拓展成多个子系统。<br>这种方案称作服务器集群，一方面是可扩展性强，可以动态添加服务器，另一方面则是可用性较高，缺点就是根据添加的服务器数量，价格也会逐步上升。<br>这个负载均衡架构，之后会单独整理。  </p><h3 id="数据的不一致与不完整"><a href="#数据的不一致与不完整" class="headerlink" title="数据的不一致与不完整"></a>数据的不一致与不完整</h3><p>这个问题是本文的重点，也是为什么整理这篇文章的原因。<br>前些日子，某游戏公司因为访问人数过多导致充值数据不一致，只能进行回档处理。这一事情引发了我的思考，为什么会导致数据不一致呢？其实这里的数据不一致不单单是同时操作数据库中的数据而导致出现问题，也可能是缓存与数据库中数据不一致。<br>举一个例子：<br>存库量不仅在数据库中，也在缓存中加快访问速度，当需要更新操作时，先行修改了数据库，再去删除缓存，如果删除缓存失败了，那么缓存中就是旧数据，而数据库则是新数据，这就导致了一种数据不一致的情况。<br>那这种情况解决方案很简单，就是无论如何先删除缓存，再修改数据库，如果删除缓存成功，修改数据库失败，那么尽管数据库数据是旧的，但是缓存为空，从数据库读取数据，不会出现不一致情况；如果删除缓存失败就不用去修改数据库。如此一来便不会出现数据库与缓存不一致的情况。  </p><p>这里需要说的是，<strong>为什么是删除缓存，而不是更新缓存？</strong><br>原因很简单，在许多复杂的缓存场景中，更新缓存的代价是极高的，例如每次更新完数据库后，是不是要同时更新缓存？但如果频繁修改了一个与缓存相关的表，缓存也会频繁更新，但问题在于缓存是否会被频繁访问？<br>这就是一种懒加载的思想，只有需要缓存的时候我们再去获得缓存。</p><p>接着上一个问题，如果问题更加复杂一下：<br>假设需要修改库存量，我们先删除了缓存，然后更新数据库，如果在更新数据库的同时又来了一个新的请求读取缓存，此时缓存为空则读取数据库，但是查询到的是修改前的旧数据，并且放入了缓存中，此时更新数据库操作完成，但是缓存中是旧数据，而数据库中是新数据，那么怎么解决这个问题？<br>其实很容易想到，就是让读操作永远在写操作后面。比如我们可以使用一个队列，当读取缓存为空时，那么就可以将这个请求加入队列当中，然后队列按顺序执行操作，便可以等到缓存更新后再去读取，保证了数据的一致性。<br>但这种方案也存在一定问题。例如，读操作可能会导致超时，为什么？因为队列中可能会有多个数据的更新操作，如果更新次数过多，会导致读请求长时间阻塞。<br>还有一个问题就是短时间的大量数据库操作，缓存如果在同一个时间失效的话，会导致多个请求同时访问数据库，需要注意数据库的QPS，并且保证缓存不会在同一时间失效。  </p><p>上面是讲数据库与缓存的一致性问题，现在讲讲数据库自身的数据一致性。<br>我们也举一个简单例子：<br>假设我们没有缓存，还是库存量的问题，我们在更新库存时同时来了多个请求更新库存量，这时候该如何保证数据的一致性？<br>其实用上文所讲的队列也可以实现，这里不再赘述。主要要讲的是数据库事务与更新锁。数据库事务是一个整体，要嘛全部执行，要嘛全部不执行，失败了就进行回滚。而在事务中，我们通过更新锁(WITH (UPDLOCK))保证其他线程只能等这个事务结束之后才可进行更新操作。<br>当然锁的引入会导致性能的下降。但这些代价不可避免，为了解决数据一致性，需要牺牲一些性能。  </p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>前面说到游戏公司充值数据不一致的问题，据我的猜测，有可能是因为从支付宝或者苹果接口回调的时候发生了问题，由于高并发导致了服务宕机。另一种可能就是更新玩家充值数据时，由于使用数据库集群时，在进行数据库切换时，主从数据不一致，当然这也是我个人猜测。<br>这篇文章整理了高并发下会引发的问题，并且给了部分解决方案，之后会更新一系列文章，分别是负载均衡分析，数据库集群实现等等文章，来对这篇文章进行补充。<br>本文在网络上查找了许多文章，并加入了自己的理解。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;其实在学生时代，基本上是遇不到高并发的架构，真正遇到高并发的问题，往往是在工作之后，我在学生时代所写的很多项目其实跟高并发是一点边都沾不上，
      
    
    </summary>
    
    
      <category term="架构" scheme="http://re0.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>浅谈动态规划Ⅱ</title>
    <link href="http://re0.top/2020/06/13/dp2/"/>
    <id>http://re0.top/2020/06/13/dp2/</id>
    <published>2020-06-13T08:10:00.000Z</published>
    <updated>2020-06-13T15:03:03.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次简单讲了动态规划的概念与如何分析，本篇文章就理一理几道常见的典型的动态规划题目。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p><code>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</code><br>来自<a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">leetcode 42题</a>。<br>这道题目有两种大思路，一种是按行求，一种是按列求。由于我们只讨论动态规划，并且让理解相对简单，我们使用按列求该列可盛多少水。<br>首先，我们要明白，对于某一列，它能盛多少水在于它左右两边的最大柱子，而这列能盛的水，就是两边最高柱子中的较小者减去当前列的高度。<br>例如[0,1,0,2]这个高度数组，我们求下标为2的列能盛多少水。首先它左边最高的高度是1，右边最高的高度是2，所以它能盛的水就是min(1,2) - 0，也就是能盛1个高度的水。<br>由此我们便可以用暴力法解决这个问题。遍历每一个列时，分别求它左右最高的列，然后将结果加上min(maxleft,maxright) - height[i]。但使用暴力法的时间复杂度为O(N^2)，有可能会超时。  </p><p>这时使用态规划来降低时间复杂度，典型地使用空间换取时间，我们设置maxleft与maxright数组，maxleft[i]表示i左边最高的高度，maxright类似，然后对整个高度数组先进行两次遍历，状态转移方程也很简单，maxleft[i] = max(height[i],maxleft[i-1]) 与 maxright[j] = max(height[j],maxright[j+1])，一个从左往右，一个从右往左。之后便和暴力法的思路一致。</p><p>接下来我们优化空间，我们使用双指针分别在高度数组的两侧，maxleft与maxright分别初始化为左右两侧高度，然后开始循环，条件为left&lt;=right，此时我们便可开始求maxleft与maxright，取小的那一边，让结果加上min(maxleft,maxright)减去height[left] 或者 height[right]，取决于maxleft小还是maxright小。<br>由此我们便将时间复杂度降为O(N),空间复杂度降为O(1)。<br>下面是完整的双指针解法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(height)</span><br><span class="line"></span><br><span class="line">        left,right = <span class="number">0</span>, n - <span class="number">1</span>  </span><br><span class="line">        maxleft,maxright = height[<span class="number">0</span>],height[n - <span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            maxleft = max(height[left],maxleft)</span><br><span class="line">            maxright = max(height[right],maxright)</span><br><span class="line">            <span class="keyword">if</span> maxleft &lt; maxright:</span><br><span class="line">                ans += maxleft - height[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += maxright - height[right]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p><code>假设你正在爬楼梯。需要 n 阶你才能到达楼顶每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？  注意：给定 n 是一个正整数。</code><br>来自<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">leetcode 70题</a><br>这道题目使用动态规划是十分好理解的，从前往后或者从后往前都可以。<br>首先这道题目的状态转移方程十分容易想到。举个例子来说明，假设fx表示爬到x阶的方案数量，那么到达这一层只能是从下一阶爬一阶，或者是下两阶爬两阶。那么状态转移方程就是fx = f(x-1) + f(x-2)。那么就可以得出代码，注意这是从前往后<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>当然我们可以假设从0级到0级也有一种方案，那么就可以从下标为2的数组开始遍历。<br>由于dp[i] = dp[i-1] + dp[i-2],只和前两项有关，那么我们便可以使用三个变量替换dp数组，使用滚动数组思想将空间复杂度降至O(1)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        k = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            i = j</span><br><span class="line">            j = k</span><br><span class="line">            k = i + j</span><br><span class="line">        <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure></p><p>其实这个状态转移方程就是斐波那契数列，他是有通项公式的，即<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> sqrt5 = Math.sqrt(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">double</span> fibn = Math.pow((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>) - Math.pow((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>并且时间复杂度为O(logN)，即pow的时间，如果n过大，带入通项公式时间会更短。</p><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><p><code>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</code><br>来自<a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">leetcode 198题</a><br>这道题很有意思，现在当小偷都需要高智商了。(笑)<br>这题思路也很简单，状态转移方程也容易想到，我们用dp[i]表示偷窃到的金额，那么dp[i] = max(dp[i-1],dp[i-2]+nums[i])，其中边界条件为dp[0] = nums[0],dp[1] = max(nums[0],nums[1])。<br>完整代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> max(nums)</span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">1</span>],nums[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>由于dp[i]只与dp[i-1]还有dp[i-2]有关，python中可以使用两个变量来替代。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> max(nums)</span><br><span class="line">        </span><br><span class="line">        first, second = nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            first, second = second, max(first + nums[i], second)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> second</span><br></pre></td></tr></table></figure></p><h2 id="鸡蛋掉落"><a href="#鸡蛋掉落" class="headerlink" title="鸡蛋掉落"></a>鸡蛋掉落</h2><p><code>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。你的目标是确切地知道 F 的值是多少。无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</code><br>来自<a href="https://leetcode-cn.com/problems/super-egg-drop/" target="_blank" rel="noopener">leetcode 887题</a><br>这道题目是十分经典的动态规划题目。<br>我们先<strong>定义状态</strong>:<br>dp[i][j]表示有i层楼梯时，使用j个鸡蛋的最少实验次数。<br>接着我们开始<strong>推导状态转移方程</strong>：<br>我们假设我们在k层扔鸡蛋，其中1&lt;=k&lt;=i，<br>· 如果鸡蛋破碎，那么就说明我们要在k层以下做这个实验，那么实验次数就变为dp[k-1][j-1].<br>· 如果鸡蛋没碎，那么我们可以去k层以上做这个实验，因此F的值就为dp[i-k][j]。<br>所以，dp[i][j]应该是这两个子问题的较大者加上1，再取1&lt;=k&lt;=i区间中的最小值。即dp[i][j] = min(1&lt;=k&lt;=i)(max(dp[k-1][j-1],dp[i-k][j]) + 1).<br>给出代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">9999</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(K+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 楼层为0时都为0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(K+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 楼层为1时，0个鸡蛋扔0次，1个以上鸡蛋扔1次</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,K+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">1</span>][j] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 鸡蛋为0时 全都为0</span></span><br><span class="line">        <span class="comment"># 鸡蛋为1时 等于楼层高度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>,K+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = min(dp[i][j],max(dp[k<span class="number">-1</span>][j<span class="number">-1</span>],dp[i-k][j]) + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>这段代码的时间复杂度为O(N^2K)，即三层的循环，在数据量较大的情况下会超时，优化的关键点在于要找到1&lt;=k&lt;=i区间中的那个最小值。我们可以使用二分查找改写上面代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">9999</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(K+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 楼层为0时都为0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(K+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 楼层为1时，0个鸡蛋扔0次，1个以上鸡蛋扔1次</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,K+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">1</span>][j] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 鸡蛋为0时 全都为0</span></span><br><span class="line">        <span class="comment"># 鸡蛋为1时 等于楼层高度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>,K+<span class="number">1</span>):</span><br><span class="line">                left = <span class="number">1</span></span><br><span class="line">                right = i</span><br><span class="line">                <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">                    mid = (left + right) // <span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> dp[mid<span class="number">-1</span>][j<span class="number">-1</span>] &gt; dp[i-mid][j]:</span><br><span class="line">                        right = mid</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left = mid</span><br><span class="line">                </span><br><span class="line">                dp[i][j] = max(dp[left<span class="number">-1</span>][j<span class="number">-1</span>],dp[i-left][j]) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>为什么判断条件是<code>dp[mid-1][j-1] &gt; dp[i-mid][j]</code>?其实是因为dp[mid-1][j-1]代表着鸡蛋碎之后的F值，dp[i-mid][j]则是鸡蛋没碎的F值，如果鸡蛋碎了，那么下次应该在左边查找，所以right=mid-1，同理，如果鸡蛋没碎，我们应该提高楼层，让left = mid，去搜索右区间。<br>尽管复杂度已经降至O(NKlogN)，但上述代码在python中依旧是超时的。在java中是没有问题的，当然理解了思想使用什么语言都是一样的。（解释器语言不好混）</p><p>这里我们看看官方的解法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(k, n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> (k, n) <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">                <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                    ans = <span class="number">0</span></span><br><span class="line">                <span class="keyword">elif</span> k == <span class="number">1</span>:</span><br><span class="line">                    ans = n</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    lo, hi = <span class="number">1</span>, n</span><br><span class="line">                    <span class="comment"># keep a gap of 2 X values to manually check later</span></span><br><span class="line">                    <span class="keyword">while</span> lo + <span class="number">1</span> &lt; hi:</span><br><span class="line">                        x = (lo + hi) // <span class="number">2</span></span><br><span class="line">                        t1 = dp(k<span class="number">-1</span>, x<span class="number">-1</span>)</span><br><span class="line">                        t2 = dp(k, n-x)</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> t1 &lt; t2:</span><br><span class="line">                            lo = x</span><br><span class="line">                        <span class="keyword">elif</span> t1 &gt; t2:</span><br><span class="line">                            hi = x</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            lo = hi = x</span><br><span class="line"></span><br><span class="line">                    ans = <span class="number">1</span> + min(max(dp(k<span class="number">-1</span>, x<span class="number">-1</span>), dp(k, n-x))</span><br><span class="line">                                  <span class="keyword">for</span> x <span class="keyword">in</span> (lo, hi))</span><br><span class="line"></span><br><span class="line">                memo[k, n] = ans</span><br><span class="line">            <span class="keyword">return</span> memo[k, n]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp(K, N)</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>官方解法其实是差不多的，思路一致，改用递归加备忘录实现，速度上较快。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天总结了4道动态规划的题目，重新学习了这4道题目后感觉又学到了不少，对于扔鸡蛋的问题，这道题目是十分经典的，之后可能还会对这道题目进行深入探究。<br>下次再整理几道题目吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上次简单讲了动态规划的概念与如何分析，本篇文章就理一理几道常见的典型的动态规划题目。&lt;/p&gt;
&lt;h1 id=&quot;实践&quot;&gt;&lt;a href=&quot;#实
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>TopK问题与快速选择算法</title>
    <link href="http://re0.top/2020/05/13/topk/"/>
    <id>http://re0.top/2020/05/13/topk/</id>
    <published>2020-05-13T08:10:00.000Z</published>
    <updated>2020-05-13T15:54:29.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TopK问题通常指的是寻找数组中第k大(小)的数或前k大(小)的数组。最简单的方法当然是使用排序，本文将从TopK问题入手，讲讲常见的几种解决方法并详细讲解快速选择算法。</p><h1 id="实践1"><a href="#实践1" class="headerlink" title="实践1"></a>实践1</h1><p>解决TopK问题的解决方案有以下几种：</p><ul><li>排序</li><li>堆</li><li>快速选择算法</li></ul><p>我们使用剑指offer中给出的一道题目作为例子。<br><code>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</code><br>接下来我将详细讲解这几种解决方案来解决上述问题。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>排序是最容易想到也是比较简单的方法，许多语言中都内置了排序方法，当然自己实现排序也是可以的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr, k)</span></span></span><br><span class="line"><span class="function">        <span class="title">arr</span>.<span class="title">sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">arr</span>[:</span>k]</span><br></pre></td></tr></table></figure><br>由于python中的排序使用的是快速排序，所以平均时间复杂度为O(nlogn)。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>我们使用大根堆来解决上述问题。由于上述题目是寻找前k小的数，所以我们使用大根堆，poll出n-k个数，留下的就是前k小的数。详细思路为：将k个数插入大根堆中，从第k+1个数开始，如果当前数小于堆顶的数，把堆顶数弹出，再插入当前数。最后留在堆中的数即为前k小的数。<br>在java当中，可以使用<strong>PriorityQueue</strong>并重写比较器来实现一个大根堆，而python中因为heapq模块只支持<strong>小根堆</strong>，我们需要将数组中的数取反，才能使用小根堆来获得前k个最小值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k) &#123;</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; pq.peek()) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[pq.size()];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: pq) &#123;</span><br><span class="line">            res[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用小根堆<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr, k)</span></span></span><br><span class="line">        if k == 0:</span><br><span class="line">            <span class="keyword">return</span> list()</span><br><span class="line"></span><br><span class="line">        pq = [-x <span class="keyword">for</span> x <span class="keyword">in</span> arr[:k]]</span><br><span class="line">        heapq.heapify(hp)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(arr)):</span><br><span class="line">            <span class="keyword">if</span> -pq[<span class="number">0</span>] &gt; arr[i]:</span><br><span class="line">                heapq.heappop(pq)</span><br><span class="line">                heapq.heappush(pq, -arr[i])</span><br><span class="line">        ans = [-x <span class="keyword">for</span> x <span class="keyword">in</span> pq]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><br>使用堆的平均时间复杂度为O(nlogk)，空间复杂度为O(k)。</p><h2 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h2><p>快速选择算法其实是快速排序的思想，我们可以先回忆下<a href="https://re0.top/2018/06/02/quicksort/">快排</a>的思想。使用快排思想可以将数组分隔为左右两边，数组下标为[0,a)与[a,n)，如果a刚好等于k-1的话，那么[0,a)就是我们要的前k小的数，如果a小于k-1则在右区间继续寻找a，如果a大于k-1的话则在左区间寻找。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickSelect</span><span class="params">(arr,left,right,k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left &lt;= right:</span><br><span class="line">                i = left</span><br><span class="line">                j = right</span><br><span class="line">                key = arr[left]</span><br><span class="line">                <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[j] &gt; key:</span><br><span class="line">                        j -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[i] &lt;= key:</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i &lt; j:</span><br><span class="line">                        arr[i],arr[j] = arr[j],arr[i]</span><br><span class="line">                arr[left],arr[j] = arr[j],arr[left]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> j == k:</span><br><span class="line">                    <span class="keyword">return</span> arr[:j+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> j &gt; k:</span><br><span class="line">                    <span class="keyword">return</span> quickSelect(arr,left,j<span class="number">-1</span>,k)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> quickSelect(arr,j+<span class="number">1</span>,right,k)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> quickSelect(arr,<span class="number">0</span>,len(arr)<span class="number">-1</span>,k<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p><p>这个算法的改进之处与快排的改进之处一致，在于每次对于key的选取，如果数组本身有序，并且key总是取左边一个数作为对比，或者说key的选取总是最大值或最小值，那么可能导致时间复杂度退化为O(n^2)，并且由于快速选择相较于快速排序，只需要对左区间或者右区间进行partition，而不是左右区间都要partition，因此时间复杂度为N + N/2 + N/4 + … + N/N = 2N，即O(N)时间复杂度。</p><h1 id="实践2"><a href="#实践2" class="headerlink" title="实践2"></a>实践2</h1><p>上面一道题我们解决了前k小的数，而TopK其实说的是top，即第k个大的数。我们使用leetcode第215题。<br><code>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</code></p><p>我们照样使用堆和快速选择来解决这个问题。</p><h2 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h2><p>这里我们使用小根堆，将数全部入堆，如果堆大小超过k，则poll出堆顶元素，最后在堆顶的就是第k大的数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; hp =</span><br><span class="line">            <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n: nums) &#123;</span><br><span class="line">          hp.add(n);</span><br><span class="line">          <span class="keyword">if</span> (hp.size() &gt; k)</span><br><span class="line">            hp.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hp.poll();        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在python的heapq模块中，我们可以使用nlargest方法来获取前k个大的数，并返回最后一个<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k, nums)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><h2 id="快速选择-1"><a href="#快速选择-1" class="headerlink" title="快速选择"></a>快速选择</h2><p>我们可以完全复制上一道题的代码，只需改动些许地方。1.当j==k时，返回的是一个数。2.由于上一道题代码是找第k个小的数，所以刚好是下标与k-1相等时返回，也就是说寻找第k大相当于寻找第n-k+1小的数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickSelect</span><span class="params">(arr,left,right,k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left &lt;= right:</span><br><span class="line">                i = left</span><br><span class="line">                j = right</span><br><span class="line">                key = arr[left]</span><br><span class="line">                <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[j] &gt; key:</span><br><span class="line">                        j -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[i] &lt;= key:</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i &lt; j:</span><br><span class="line">                        arr[i],arr[j] = arr[j],arr[i]</span><br><span class="line">                arr[left],arr[j] = arr[j],arr[left]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> j == k:</span><br><span class="line">                    <span class="keyword">return</span> arr[j]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> j &gt; k:</span><br><span class="line">                    <span class="keyword">return</span> quickSelect(arr,left,j<span class="number">-1</span>,k)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> quickSelect(arr,j+<span class="number">1</span>,right,k)</span><br><span class="line">        <span class="comment"># len(nums)-k 是数组下标</span></span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>,len(nums)-k)</span><br></pre></td></tr></table></figure></p><p>老生常谈的优化，对于key的选择很关键，在LeetCode中，如果key总是为左边那个数，则时间耗时1100ms，而如果使用随机下标与left进行交换，则时间降至50ms以内。并且减少了递归所需要的内存消耗。具体部分代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">            <span class="keyword">if</span> left &lt;= right:</span><br><span class="line">                i = left</span><br><span class="line">                j = right</span><br><span class="line">                a = random.randint(left, right)</span><br><span class="line">                arr[left],arr[a] = arr[a],arr[left]</span><br><span class="line">                key = arr[left]</span><br><span class="line">                <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[j] &gt; key:</span><br><span class="line">                        j -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[i] &lt;= key:</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i &lt; j:</span><br><span class="line">                        arr[i],arr[j] = arr[j],arr[i]</span><br><span class="line">                arr[left],arr[j] = arr[j],arr[left]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="partition思路"><a href="#partition思路" class="headerlink" title="partition思路"></a>partition思路</h2><p>在官方答案中是将右边作为起始点，其思想大同小异，这里简单讲讲与我思路的不同。<br>首先随机选取一个pivot，并将这个数与最右边那个数进行一次交换。<br>第二步，定义i,j指针，初始化为left，循环退出条件为j指针等于最右边数的下标。查看nums[j]是否小于等于pivot，如果不是，则j向右移动。如果是，交换i,j位置的元素，并且i,j都向右移动。<br>第三步，重复第二步，直到j==right，此时交换i与j的元素，此时，i左边元素都小于它，右边元素都大于它。<br>以上就是另一种partition的思路。<br>这篇文章中的partition思路与那篇<a href="https://re0.top/2018/06/02/quicksort/">快速排序</a>的文章相同。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>快速选择算法与快速排序思想一致，通过对数组进行partition来获取前k小的数，通过写这篇文章，再一次复习了快速排序算法，并对两种算法有了自己的认识与理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;TopK问题通常指的是寻找数组中第k大(小)的数或前k大(小)的数组。最简单的方法当然是使用排序，本文将从TopK问题入手，讲讲常见的几种解
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>几种二分查找的模板与理解</title>
    <link href="http://re0.top/2020/04/29/binary_search/"/>
    <id>http://re0.top/2020/04/29/binary_search/</id>
    <published>2020-04-29T08:10:00.000Z</published>
    <updated>2020-05-02T15:44:50.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>二分查找是常见的一种搜索方式，通常用在顺序列表中查找特定的数或者区间，虽然看起来十分简单，但是在写代码的时候极容易出错，原因在于边界判断上，本质上还是对二分查找理解不到位。这篇文章整理下二分查找的模板以及谈谈自己的理解。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="大体框架"><a href="#大体框架" class="headerlink" title="大体框架"></a>大体框架</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = ...</span><br><span class="line">    <span class="keyword">while</span> (...):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = ...</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = ...</span><br><span class="line">    <span class="keyword">return</span> ...</span><br></pre></td></tr></table></figure>   <p>二分查找的模板大致如上，其中…表示需要注意的地方。在写二分查找时尽量将所有情况都用else if的形式写出来，直观一些。<br>其次在一些语言中，使用left+right有可能会溢出，所以可以改写成<code>left + (right - left) // 2</code>。<br>基于以上模板，我们可以详细分为几类。</p><h2 id="寻找特定的一个数"><a href="#寻找特定的一个数" class="headerlink" title="寻找特定的一个数"></a>寻找特定的一个数</h2><p>这个是我们常用到的，即在数组中寻找一个特定的数，前提是这个数组已经采用升序排序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><br>这里需要注意的有：</p><ol><li><p>Q：为什么while的条件是<strong>left &lt;= right</strong>，而不是<strong>left &lt; right</strong>？<br>A：当条件为&lt;=时，相当于搜索的是[left,right]区间，而&lt;则相当于[left,right)的区间，当right的取值为len(nums)时，我们的nums[right]是越界的，此时右区间需要开。<br>&lt;=的终止条件为left == right + 1，此时区间为[right+1,right]，区间为空。<br>&lt; 的终止条件为left == right，即[left,left)，只有一个数的区间，但此时这个数并没有被扫描到，所以使用&lt;作为判断的话需要加入一个判断语句<code>if nums[left] == target left else -1</code></p></li><li><p>Q：left 和 right 到底需要怎么改变？<br>A：上述代码中left=mid+1与right=mid-1是因为我们已经明确搜索区间是闭区间，即左右边界都已经搜索过，或者说mid这个索引的数已经被搜索过，所以我们需要根据需要在mid的左右区间进行搜索，即[left,mid-1]或者[mid+1,right]。</p></li></ol><h2 id="寻找左边界的二分查找"><a href="#寻找左边界的二分查找" class="headerlink" title="寻找左边界的二分查找"></a>寻找左边界的二分查找</h2><p>如果一个数组存在重复元素，并且需要你返回第一个出现这个数的索引，那么显然我们使用普通的二分查找并不能获得这个元素的在数组中出现的左边界。<br>我们先给出使用<strong>left &lt; right</strong>为条件的代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left_bound</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)</span><br><span class="line">    <span class="keyword">while</span> (left &lt; rgiht):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>这个代码是许多人常用来搜索左边界的代码，但是在结果返回时存在着一个问题。我们先整理一下问题:</p><ol><li><p>Q：如果数组中不存在这个数，那么返回不就不对了吗？<br>A：确实如此。我们刚才说到，使用&lt;为条件的搜索为右开区间，当退出循环时，此时区间为[left,left)，并且left的取值有可能为数组边界,所以我们需要两个判断语句，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if left == len(nums) or nums[left] != target:</span><br><span class="line">    return -1 </span><br><span class="line">else: </span><br><span class="line">    return left</span><br></pre></td></tr></table></figure></li><li><p>Q：为啥是left &lt; right?<br>A：理由同上，因为right被初始化为len(nums)，需要采用右开区间保证下标不越界。</p></li><li><p>Q：为什么left = mid + 1,right = mid?<br>A：因为是左闭右开区间，需要将区间分为[left,mid)与[mid+1,right)。</p></li><li><p>Q：能不能统一为left&lt;=right?<br>A：我个人认为统一left &lt;= right 比较好，前提是理解了搜索区间这个概念。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left_bound</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= len(nums) <span class="keyword">or</span> nums[left] != target:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="寻找右边界的二分查找"><a href="#寻找右边界的二分查找" class="headerlink" title="寻找右边界的二分查找"></a>寻找右边界的二分查找</h2><p>与上面代码类似，这里我只写出left&lt;=right为条件的代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right_bound</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; <span class="number">0</span> <span class="keyword">or</span> nums[right] != target:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>注意的点为：</p><ol><li>搜索左右边间的区别在于当nums[mid] == target时需要缩小哪个边界，当我们需要寻找<strong>左侧</strong>边界时，我们应该在搜索到target后，去搜索左侧区间；而当我们需要寻找<strong>右侧</strong>边界时，在搜索到target时，去寻找右区间。</li><li>之所以检测right是因为right的取值为[-1,len(nums)-1]，即当target比所有元素小时，right会减至-1，需要防止越界。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们明确搜索区间概念之后，统一将条件写为left&lt;=right，并从中总结规律。<br>先是二分查找<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><br>其次寻找左边界<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left_bound</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= len(nums) <span class="keyword">or</span> nums[left] != target:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>最后是寻找右边界<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right_bound</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; <span class="number">0</span> <span class="keyword">or</span> nums[right] != target:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure></p><p>寻找左右边界区别在于nums[mid] == target时需要收缩左侧边界还是右侧边界，还有因为left属于[0,len(nums)]，right属于[-1,len(nums)-1]，所以需要判断各自越界情况。<br>这些便是从升序数组中二分查找的方法。如果理解了这些，那降序数组的二分搜索也是万变不离其宗的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;二分查找是常见的一种搜索方式，通常用在顺序列表中查找特定的数或者区间，虽然看起来十分简单，但是在写代码的时候极容易出错，原因在于边界判断上，
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>浅谈动态规划</title>
    <link href="http://re0.top/2020/04/05/dp1/"/>
    <id>http://re0.top/2020/04/05/dp1/</id>
    <published>2020-04-05T08:10:00.000Z</published>
    <updated>2020-04-07T07:23:13.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>动态规划（Dynamic programming，简称 DP），是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。这与递归的思想一致，所以动态规划往往用于优化递归问题，利用动态规划的思想可以减少计算量。</p><h2 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h2><p>最优子结构指的是，问题的最优解包含子问题的最优解。即我们可以通过子问题的最优解，推导出问题的最优解。</p><h2 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h2><p>无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。</p><h2 id="重复子问题"><a href="#重复子问题" class="headerlink" title="重复子问题"></a>重复子问题</h2><p>不同的决策序列，到达某个相同阶段时，会产生重复的状态。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h2><p>解决动态规划问题，一般有两种思路，分别为状态转移表法和状态转移方程法。</p><h3 id="状态转移表法"><a href="#状态转移表法" class="headerlink" title="状态转移表法"></a>状态转移表法</h3><p>一般情况下，能使用动态规划解决的问题，都可以使用回溯法解决。先通过回溯法，找到是否存在重复子问题，以及相应的规律，尝试是否能使用动态规划解决。<br>找到重复子问题之后，就可以使用状态转移表来处理问题。<br>先画出一个状态表，一般来说都是二维的，可以用二维数组来表示，其中每个状态包括三个变量，行，列，数组值。根据递归关系，填充状态表的每个状态，最后翻译成代码，就是动态规划的代码了。<br>但如果问题较为复杂，状态表就有可能是高维的，这时候人在思考问题的时候就不那么简单了。<br>举个例子，要从矩阵左上角走到矩阵右下角，但是每格都有相应的权重，我们需要选择权重最小的路径。<br>这里我们可以采用回溯算法(深度优先中的一种)，回溯在遍历时不保留完整的结构，而深度优先则保留。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    self.minDist = float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistBT</span><span class="params">(i:int,j:int,dist:int,w:list[list[int],n:int)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == n <span class="keyword">and</span> j == n:</span><br><span class="line">            <span class="keyword">if</span> dist &lt; minDist:</span><br><span class="line">                self.minDist = dist</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; n:</span><br><span class="line">            self.minDistBT(i + <span class="number">1</span>,j,dist + w[i][j] , w, n)</span><br><span class="line">        <span class="keyword">if</span> j &lt; n:</span><br><span class="line">            self.minDistBT(i,j + <span class="number">1</span>,dist + w[i][j] , w, n)</span><br></pre></td></tr></table></figure> </p><p>我们可以看出，一个状态即一个节点，包含三个变量(i,j,dist)，其中i,j表示行列，dist表示起点到(i,j)的路径长度，尽管(i,j,dist)没有重复值，但(i,j)重复，对于(i,j)重复的节点，我们只需要选择dist最小的节点便可以继续递归求解了。<br>我们翻译成代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistDP</span><span class="params">(matrix:list[list[int]],n:int)</span>:</span></span><br><span class="line">        states = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sum += matrix[<span class="number">0</span>][i]</span><br><span class="line">            states[<span class="number">0</span>][i] = sum</span><br><span class="line">        </span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sum += matrix[i][<span class="number">0</span>]</span><br><span class="line">            states[i][<span class="number">0</span>] = sum</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                states[i][j] = matrix[i][j] + min(states[i][j<span class="number">-1</span>],states[i<span class="number">-1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> states[n<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>这里我们初始化了第一行和第一列的数据，然后每一个节点都是让该节点的权重加上，上方和左方中的最小值，就是该状态表的这个节点的最小dist值。最后返回右下角节点的值，便可以获得最短路径。</p><h3 id="状态转移方程法"><a href="#状态转移方程法" class="headerlink" title="状态转移方程法"></a>状态转移方程法</h3><p>这种方法与递归的思想类似，我们需要知道，某个问题如何通过子问题求解，即寻找最优子结构，根据最优子结构写出递归公式，即状态转移方程。以上面的问题来说，状态转移方程为：<br><code>min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))</code><br>状态转移方程是解决动态规划的关键所在，接下来翻译成代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    self.matrix = [[random.randint(<span class="number">1</span>,<span class="number">10</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">    self.n = <span class="number">4</span></span><br><span class="line">    self.mem = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">    <span class="comment"># 调用minDist(n-1,n-1)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDist</span><span class="params">(i:int,j:int)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.matrix[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> self.mem[i][j] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.mem[i][j]</span><br><span class="line">        </span><br><span class="line">        minLetf = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">if</span> j - <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">            minLetf = self.minDist(i,j<span class="number">-1</span>)</span><br><span class="line">        minUp = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">if</span> i - <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">            minUp = self.minDist(i<span class="number">-1</span>,j)</span><br><span class="line"></span><br><span class="line">        currMinDist = self.matrix[i][j] + min(minLetf,minUp)</span><br><span class="line">        self.mem[i][j] = currMinDist</span><br><span class="line">        <span class="keyword">return</span> currMinDist</span><br></pre></td></tr></table></figure></p><p>我们从右下角回溯到左上角。每个节点的值等于该节点的权重加上上方和左方节点中的最小值。<br>其实和上面的状态转移表法的实现是差不多的，只是思考的思路不同。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>尽管动态规划比回溯算法高效，但并不是所有问题都可以使用动态规划，能使用动态规划的问题，需要满足三个条件，最优子结构，无后效性，重复子问题。在重复子问题上，动态规划与分治算法区分明显，分治算法要求分割成的子问题不能有重复子问题，而动态规划则恰恰相反，它之所以高效，是因为回溯算法中存在大量的重复子问题。<br>解决动态规划问题的思路分别是状态转移表法和状态转移方程法。其中，状态转移表法解题思路大致可以概括为<strong>回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码。</strong>状态转移方程法的大致思路可以概括为，<strong>找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码。</strong><br>之后的文章会通过实际问题继续探讨动态规划。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;动态规划（Dynamic programming，简称 DP），是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。若要解一个
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的广度优先(层次)遍历</title>
    <link href="http://re0.top/2020/03/30/tree-traversal2/"/>
    <id>http://re0.top/2020/03/30/tree-traversal2/</id>
    <published>2020-03-30T09:10:00.000Z</published>
    <updated>2020-03-30T09:02:34.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇讲的是二叉树的三种遍历方式，前中后序遍历方式，它们都属于深度优先遍历，所谓深度优先就是沿着树的深度遍历树的节点。而广度优先遍历则是从root开始，从左到右从上到下水平遍历树的节点，所以又称为层次遍历。<br>深度优先借助的数据结构为栈，而广度优先借助的则是队列。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p>由于在LeetCode中并没有找到相应的题目，所以我直接给出代码。<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">breadthTraversal</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            queue = []</span><br><span class="line">            res = []</span><br><span class="line">            queue.append(root)</span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>二叉树的广度优先遍历较为简单，只要借助队列，让节点先进先出，便可得到层次遍历的结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上篇讲的是二叉树的三种遍历方式，前中后序遍历方式，它们都属于深度优先遍历，所谓深度优先就是沿着树的深度遍历树的节点。而广度优先遍历则是从ro
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的前中后序遍历</title>
    <link href="http://re0.top/2020/03/30/tree-traversal/"/>
    <id>http://re0.top/2020/03/30/tree-traversal/</id>
    <published>2020-03-30T08:10:00.000Z</published>
    <updated>2020-03-30T09:02:35.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在看面试题，基本已经知道算法这块地方是自己的薄弱点，特意复习记录一下。<br>今天写的是二叉树的前中后序遍历，我会分别用递归还有迭代的方法实现。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>来源LeetCode第144题。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>官方特意在题目中标注递归算法很简单，那么就先来看看递归算法。<br>递归算法就是先得到结点值，然后递归遍历左子树和右子树。<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        result.append(root.val)</span><br><span class="line">        <span class="comment"># 由于递归返回list，需要使用extend合并两个列表。</span></span><br><span class="line">        result.extend(self.preorderTraversal(root.left))</span><br><span class="line">        result.extend(self.preorderTraversal(root.right))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p>Java代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        preOrder(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>与python大同小异。</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>我们知道递归的本质是使用栈来实现，那么我们也可以使用一个栈来帮助我们进行迭代。<br>而栈的进入顺序为<strong>先右子树然后左子树</strong>，因为栈是先进后出的数据结构，所以我们让右子树先进栈，让左子树先出栈，才能实现root-left-right的顺序。<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            rerurn []</span><br><span class="line">        stack = []</span><br><span class="line">        result = []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            result.append(node.val)</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><br>Java代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode temp = stack.pop();</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>来自LeetCode第94题。<br>中序遍历是left-root-right的顺序，递归方法依旧很简单。</p><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># 可以省略判断</span></span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="keyword">None</span>:</span><br><span class="line">                inorder(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.right != <span class="keyword">None</span>:</span><br><span class="line">                inorder(root.right)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>其实可以省略判断，因为函数开始就已经判断root是否为空。</p><p>Java代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root.left,result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        helper(root.right,result);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><p>中序遍历的迭代方法与前序遍历难一些。中序遍历需要先将<strong>所有左子树</strong>压入栈中，然后开始从二叉树左下角的节点开始出栈，将本节点的的值放入结果中，然后将该节点的右子树放入栈中。之后便可按照left-root-right的顺序将值放入结果中。<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure></p><p>Java代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            result.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以稍微修改下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                result.add(root.val);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>LeetCode第145题。前中后序遍历官方给的难度是递增的。后序遍历难度为困难。</p><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>当然我们如果使用递归的话就比较简单。与前序中序相似，只改变一下节点值加入结果的顺序。<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># 可以省略判断</span></span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="keyword">None</span>:</span><br><span class="line">                postorder(root.left)</span><br><span class="line">            <span class="keyword">if</span> root.right != <span class="keyword">None</span>:</span><br><span class="line">                postorder(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>Java代码类似<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root.left,result);</span><br><span class="line">        helper(root.right,result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h3><p>困难主要在于使用迭代实现后序遍历。后序遍历的顺序为left-right-root，由于我们先获得的是root节点，之后才能获取左右子树，所以我们改变思路，<br>我们可以先从root-right-left的顺序下手，之后再反序，就可以得到后序遍历的结果。<br>由于我们使用的是栈，我们先把根节点放入栈中，然后依次放入左子树和右子树，这样栈的弹出顺序就是由右子树到左子树，那么我们的思路就确定了：<br>先将根节点push到栈中，pop出来后将值存入结果中，然后分别push左右子树到栈中，右子树先出栈，得到了右子树的值，然后得到左子树的值，即遍历顺序就为根-右子树-左子树。<br>因此，我们的入栈顺序就是为root-left-right<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res.append(node.val)</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>Java代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode temp = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">            stack.push(temp.left);</span><br><span class="line">            stack.push(temp.right);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次总结了三种二叉树的遍历方式，相比于之前，确实又加深了不少理解。三种遍历方式使用递归方法都非常简单，但是使用迭代方法就有些难度了，<br>其中前序遍历最简单，只要将root-right-left依次放进栈中便可得到结果。<br>而后序遍历与前序遍历多了一个翻转的思想，入栈顺序为root-left-right，之后反转结果，便可得到后序遍历的结果。<br>最后是中序遍历，将所有左子树放入栈中，然后从左下角的节点开始出栈，每当出栈后，把节点值放入结果中，然后将右子树放入栈中，如此迭代，便可得到left-root-right的顺序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在看面试题，基本已经知道算法这块地方是自己的薄弱点，特意复习记录一下。&lt;br&gt;今天写的是二叉树的前中后序遍历，我会分别用递归还有迭代的方
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>初探celery任务队列</title>
    <link href="http://re0.top/2020/03/24/celery/"/>
    <id>http://re0.top/2020/03/24/celery/</id>
    <published>2020-03-24T08:10:00.000Z</published>
    <updated>2020-03-24T17:25:18.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前讲过，在自己开发的公众号后台中有一个比较费时的请求操作，由于微信限制5秒内返回，无法立即返回结果，因此我开始寻找解决办法，最终决定使用<strong>任务队列</strong>来进行实现。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>有些文章认为任务队列=消息队列，是一种解决方案，但我认为消息队列是任务队列的一部分，<strong>任务队列需要消息队列作支持</strong>。完整的任务队列不仅需要消息中间件（即消息队列），还需要生产者，消费者来提出任务与解决任务。<br>任务队列在架构中十分常见，常见的使用场景有</p><ul><li>费时操作交由任务队列系统异步执行，提高响应时间与吞吐量。</li><li>将请求的部分操作转交给任务队列执行，加快操作，如推送消息，发送验证码/邮件等。</li><li>定时任务。在生产环境下会有许多定时任务，如定时清理，定时备份等等，如果定时任务太多，又或者服务器数量过多，定时任务的管理就十分困难，此时任务队列就可以帮助管理员管理定时任务。</li></ul><p>市面上也有许多消息中间件供开发者使用，如rabbitMQ，rocketMQ等等，当然也可以使用redis作为消息中间件。<br>当然光有消息中间件是无法实现一个任务队列的，接下来我们手动实现一个任务队列。</p><h2 id="任务队列雏形"><a href="#任务队列雏形" class="headerlink" title="任务队列雏形"></a>任务队列雏形</h2><p>我们采用redis做消息中间件，利用redis的list数据结构，我们可以直接将list当作消息队列，作为消息存放处。同时redis还有lpush与rpop，生产者使用lpush将任务消息存放在list中，而消费者使用rpop或者使用阻塞的brpop来获取任务消息，并处理消息，之后将处理结果存在redis中，当需要结果时，从redis中取出结果。如此我们便实现了一个简单的任务队列。<br>我们假设生产者产生了一串数字，而消费者则是将数字进行简单hash处理。<br>我们可以实现一下代码<br>生产者：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis,random,time</span><br><span class="line">r = redis.Redis(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, decode_responses=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"producer开始工作"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        random_num = random.randint(<span class="number">1</span>,<span class="number">10000</span>)</span><br><span class="line">        print(random_num)</span><br><span class="line">        r.lpush(<span class="string">"task_list"</span>,random_num)</span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    producer()</span><br></pre></td></tr></table></figure><br>消费者：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis,random,time,hashlib</span><br><span class="line">r = redis.Redis(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, decode_responses=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_md5</span><span class="params">(str1)</span>:</span></span><br><span class="line">    str1 = str(str1)</span><br><span class="line">    h = hashlib.md5()</span><br><span class="line">    h.update(str1.encode(encoding=<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="keyword">return</span> h.hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"worker开始工作"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        random_num = r.brpop(<span class="string">"task_list"</span>)[<span class="number">1</span>]</span><br><span class="line">        num_md5 = get_md5(random_num)</span><br><span class="line">        r.set(random_num,num_md5)</span><br><span class="line">        print(<span class="string">"&#123;&#125; hash is: &#123;&#125;"</span>.format(random_num,r.get(random_num)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    worker()</span><br></pre></td></tr></table></figure><br>如此我们简单实现一个最原始的任务队列，接下来就是让生产者从redis中取出结果，实现方法很简单，将每个任务分配任务id，根据任务id去获取结果。我们改进代码，让producer将任务id整合进任务中。<strong>这里我们使用json将序列化对象存入list中，然后结果也是用json数据存储。</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"producer开始工作"</span>)</span><br><span class="line">    task_id = <span class="number">0</span> <span class="comment">#初始化任务id</span></span><br><span class="line">    task = &#123;<span class="string">'task_id'</span>:task_id,<span class="string">'random_num'</span>:<span class="number">0</span>&#125; <span class="comment">#定义task结构</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        random_num = random.randint(<span class="number">1</span>,<span class="number">10000</span>)</span><br><span class="line">        new_task = copy.copy(task)</span><br><span class="line">        new_task[<span class="string">'task_id'</span>] = (task_id+=<span class="number">1</span>)</span><br><span class="line">        new_task[<span class="string">'random_num'</span>] = random_num</span><br><span class="line">        print(new_task)</span><br><span class="line">        r.lpush(<span class="string">"task_list"</span>,json.dumps(new_task))</span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"worker开始工作"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        task = json.loads(r.brpop(<span class="string">"task_list"</span>)[<span class="number">1</span>])</span><br><span class="line">        print(task)</span><br><span class="line">        task_id = task[<span class="string">'task_id'</span>]</span><br><span class="line">        random_num = task[<span class="string">'random_num'</span>]</span><br><span class="line">        num_md5 = get_md5(random_num)</span><br><span class="line">        result = &#123;<span class="string">'task_id'</span>:task_id,<span class="string">'result'</span>:num_md5&#125;</span><br><span class="line">        r.set(task_id,json.dumps(result))</span><br><span class="line"></span><br><span class="line">        get_result = json.loads(r.get(task_id))[<span class="string">'result'</span>]</span><br><span class="line">        print(<span class="string">"&#123;&#125; hash is: &#123;&#125;"</span>.format(random_num,get_result))</span><br></pre></td></tr></table></figure><br>如此我们就可以根据任务id获取任务处理结果。</p><h2 id="Celery"><a href="#Celery" class="headerlink" title="Celery"></a>Celery</h2><p>上面讲了很多，是时候谈谈本篇文章的重点，celery。它是一个由python语言实现分布式的任务队列，其中包括以下几个组成部分</p><ul><li>Task。即用户定义的任务部分。</li><li>Broker。即上文所讲的消息中间件，一般采用redis或者rabbitMQ。</li><li>Worker。任务消费者，实时监控任务队列并处理。</li><li>Beat。定时任务调度器，将定时任务发送至broker，等待worker进行处理。</li><li>Backend。即任务执行的结果，worker将任务处理完成后将结果存放于此。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我们采用pip安装，并采用redis作为消息中间件<br><code>pip install -U &quot;celery[redis]&quot;</code></p><h3 id="第一个celery实例"><a href="#第一个celery实例" class="headerlink" title="第一个celery实例"></a>第一个celery实例</h3><p>这里我们假设要向某api请求搜索数据，这个操作耗时需要10秒以上。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">broker = <span class="string">'redis://localhost:6379/0'</span></span><br><span class="line">celery_app = Celery(<span class="string">'main'</span>,broker=broker)</span><br><span class="line"></span><br><span class="line"><span class="meta">@celery_app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_result_from_remote</span><span class="params">(keyword)</span>:</span></span><br><span class="line">    print(<span class="string">"正在搜索关键字为&#123;&#125;的数据"</span>.format(keyword))</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span></span><br></pre></td></tr></table></figure><br>注意创建celery实例时，第一个参数表示celery app所在的脚本名称，即入口点。<br>接下来我们同样在这个脚本中定义需要调用此任务的函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_from_remote</span><span class="params">()</span>:</span></span><br><span class="line">    keyword = input(<span class="string">"请输入关键字:"</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    get_result_from_remote.delay(keyword)</span><br><span class="line">    print(<span class="string">"一共耗时&#123;&#125;秒"</span>.format(time.time()-start))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    search_from_remote()</span><br></pre></td></tr></table></figure> </p><h3 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h3><p>此时我们就可以启动worker监听是否有任务存在于broker中。<br><code>celery worker -A main --loglevel=info</code><br>-A 参数表示celery的任务在哪个脚本当中，然后定义了日志级别。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> -------------- celery@ubuntu v4.4.2 (cliffs)</span><br><span class="line">--- ***** ----- </span><br><span class="line">-- ******* ---- Linux-4.4.0-105-generic-x86_64-with-Ubuntu-16.04-xenial 2020-03-24 21:02:29</span><br><span class="line">- *** --- * --- </span><br><span class="line">- ** ---------- [config]</span><br><span class="line">- ** ---------- .&gt; app:         tasks:0x7f5ba09f8ef0</span><br><span class="line">- ** ---------- .&gt; transport:   redis://localhost:6379/0</span><br><span class="line">- ** ---------- .&gt; results:     disabled://</span><br><span class="line">- *** --- * --- .&gt; concurrency: 1 (prefork)</span><br><span class="line">-- ******* ---- .&gt; task events: OFF (<span class="built_in">enable</span> -E to monitor tasks <span class="keyword">in</span> this worker)</span><br><span class="line">--- ***** ----- </span><br><span class="line"> -------------- [queues]</span><br><span class="line">                .&gt; celery           exchange=celery(direct) key=celery</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">[tasks]</span><br><span class="line">  . main.get_result_from_remote</span><br><span class="line"></span><br><span class="line">[2020-03-24 21:16:24,764: INFO/MainProcess] Connected to redis://localhost:6379/0</span><br><span class="line">[2020-03-24 21:16:24,804: INFO/MainProcess] mingle: searching <span class="keyword">for</span> neighbors</span><br><span class="line">[2020-03-24 21:16:25,865: INFO/MainProcess] mingle: all alone</span><br><span class="line">[2020-03-24 21:16:25,954: INFO/MainProcess] celery@ubuntu ready.</span><br></pre></td></tr></table></figure><br>由于还没启动生产者，所以worker不进行工作。或者说worker没有工作可做。<br>接着我们运行这个脚本<br><code>python3 main.py</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入关键字:123</span><br><span class="line">一共耗时0.3693723678588867秒</span><br></pre></td></tr></table></figure><br>可以发现定义在任务中延时并不会影响主线程运行，再看看worker的日志<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[2020-03-24 21:16:33,985: INFO/MainProcess] Received task: main.get_result_from_remote[1d4196cf-12e2-49be-acf1-0163b1b0d522]  </span><br><span class="line">[2020-03-24 21:16:33,990: WARNING/ForkPoolWorker-1] 正在搜索关键字为123的数据</span><br><span class="line">[2020-03-24 21:16:44,005: INFO/ForkPoolWorker-1] Task main.get_result_from_remote[1d4196cf-12e2-49be-acf1-0163b1b0d522] succeeded <span class="keyword">in</span> 10.015596589073539s: <span class="string">'success'</span></span><br></pre></td></tr></table></figure><br>十分完美，我们成功使用了celery做任务队列来处理耗时操作。</p><h3 id="获取返回结果"><a href="#获取返回结果" class="headerlink" title="获取返回结果"></a>获取返回结果</h3><p>接着我们看看在主线程中，任务的返回值究竟是什么。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_from_remote</span><span class="params">()</span>:</span></span><br><span class="line">    keyword = input(<span class="string">"请输入关键字:"</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    result = get_result_from_remote.delay(keyword)</span><br><span class="line">    print(result)</span><br><span class="line">    print(<span class="string">"一共耗时&#123;&#125;秒"</span>.format(time.time()-start))</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>发现返回了一串类似于任务id的数据.<code>f75232b5-e3be-4a6f-a077-0b7bf9bd8111</code><br>通过查看官方文档，我找到了使用方法<br>第一种办法是通过任务的AsyncResult方法来获取结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task_id = <span class="string">"f75232b5-e3be-4a6f-a077-0b7bf9bd8111"</span></span><br><span class="line">print(get_result_from_remote.AsyncResult(task_id).get())</span><br></pre></td></tr></table></figure><br>另一种方式是通过celery.result的AsyncResult方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task_id = <span class="string">"f75232b5-e3be-4a6f-a077-0b7bf9bd8111"</span></span><br><span class="line"><span class="keyword">from</span> celery.result <span class="keyword">import</span> AsyncResult</span><br><span class="line">AsyncResult(task_id).get()</span><br></pre></td></tr></table></figure> </p><h3 id="添加backend"><a href="#添加backend" class="headerlink" title="添加backend"></a>添加backend</h3><p>但是由于我们没有启动backend，所以无法获取结果。我们依旧把redis当作backend。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis_server = <span class="string">'redis://localhost:6379/0'</span></span><br><span class="line">celery_app = Celery(<span class="string">'main'</span>,broker=redis_server,backend=redis_server)</span><br></pre></td></tr></table></figure><br>我们重启worker，运行脚本之后获取任务id的结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task_id = <span class="string">"ed9e6f8a-913f-49a5-a3b6-99444003352a"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"result:"</span> + get_result_from_remote.AsyncResult(task_id).get())</span><br><span class="line">from celery.result import AsyncResult</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"result:"</span> + AsyncResult(task_id).get())</span><br><span class="line"><span class="comment">#result:success</span></span><br><span class="line"><span class="comment">#result:success</span></span><br></pre></td></tr></table></figure></p><h3 id="beat"><a href="#beat" class="headerlink" title="beat"></a>beat</h3><p>celery的几个组件就剩下beat。beat组件可以配置自动任务。我们另起一个新脚本。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mybeat.py</span></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">redis_server = <span class="string">'redis://localhost:6379/0'</span></span><br><span class="line">celery_app = Celery(<span class="string">'mybeat'</span>,broker=redis_server,backend=redis_server)</span><br><span class="line"></span><br><span class="line">celery_app.conf.beat_schedule = &#123;</span><br><span class="line">    <span class="string">'task-10-seconds'</span>: &#123;</span><br><span class="line">        <span class="string">'task'</span>: <span class="string">'test'</span>,</span><br><span class="line">        <span class="string">'schedule'</span>: datetime.timedelta(seconds=<span class="number">10</span>),</span><br><span class="line">        <span class="string">'args'</span>: (<span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@celery_app.task(name='test')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    print(<span class="string">'定时任务开始运行'</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></p><p>我们先启动worker进程<code>celery worker -A mybeat -l info</code><br>然后启动beat程序<code>celery beat -A mybeat</code><br>之后每10秒worker就会计算一遍1+1的结果并将结果缓存。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>尽管我们初步学习了celery的使用，但其实在项目中celery的配置是较为复杂的，在网上找了几篇文章，celery项目结构普遍为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── __init__.py</span><br><span class="line">├── celeryconfig.py</span><br><span class="line">├── celery.py</span><br><span class="line">└── tasks.py</span><br></pre></td></tr></table></figure>  </p><p>其中celery.py为主程序，作为整个celery的入口点，celeryconfig为配置存放处，而tasks则是各种任务。<br>在本篇文章的代码中，我只是设置了一个任务队列，celery支持多个任务队列，通过设置queue与route，并且制定任务名称，根据名称匹配路由，路由再将任务送至响应的queue中，实现不同类型的任务有不同的任务队列来处理。这里需要使用kombu对queue进行处理。简单给出代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">from</span> kombu <span class="keyword">import</span> Exchange, Queue</span><br><span class="line"><span class="comment">#broker 与 backend可以使用不同的redis数据库，如0和1</span></span><br><span class="line">redis_server = <span class="string">'redis://localhost:6379/0'</span></span><br><span class="line">celery_app = Celery(<span class="string">'celery'</span>,broker=redis_server,backend=redis_server)</span><br><span class="line"></span><br><span class="line"><span class="string">'''使用redis做broker可以无需配置exchange'''</span></span><br><span class="line">queue = (</span><br><span class="line">    Queue(<span class="string">'default'</span>, exchange=Exchange(<span class="string">'default'</span>, type=<span class="string">'direct'</span>), routing_key=<span class="string">'default'</span>),</span><br><span class="line">    Queue(<span class="string">'task1'</span>, exchange=Exchange(<span class="string">'task1'</span>, type=<span class="string">'direct'</span>), routing_key=<span class="string">'task1'</span>),</span><br><span class="line">    Queue(<span class="string">'task2'</span>, exchange=Exchange(<span class="string">'task2'</span>, type=<span class="string">'direct'</span>), routing_key=<span class="string">'task2'</span>),</span><br><span class="line">)</span><br><span class="line">route = &#123;</span><br><span class="line">    <span class="string">'task*'</span>: &#123;<span class="string">'queue'</span>: <span class="string">'task1'</span>, <span class="string">'routing_key'</span>: <span class="string">'task1'</span>&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">'task2'</span>: &#123;<span class="string">'queue'</span>: <span class="string">'task2'</span>, <span class="string">'routing_key'</span>: <span class="string">'task2'</span>&#125;,</span><br><span class="line">    <span class="string">'*'</span>: &#123;<span class="string">'queue'</span>: <span class="string">'default'</span>, <span class="string">'routing_key'</span>: <span class="string">'default'</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">app.conf.update(</span><br><span class="line">    task_serializer=<span class="string">'json'</span>,</span><br><span class="line">    accept_content=[<span class="string">'json'</span>],</span><br><span class="line">    result_serializer=<span class="string">'json'</span>,</span><br><span class="line">    timezone=<span class="string">'Asia/Shanghai'</span>,</span><br><span class="line">    enable_utc=<span class="keyword">False</span>,</span><br><span class="line">    <span class="comment"># 任务过期时间(超时时间)</span></span><br><span class="line">    <span class="comment"># result_expires=3600,</span></span><br><span class="line">    <span class="comment">#  Number of CPU cores.</span></span><br><span class="line">    <span class="comment"># worker_concurrency=4,</span></span><br><span class="line">    task_queues=queue,</span><br><span class="line">    task_routes=route,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#tasks.py</span></span><br><span class="line"><span class="meta">@app.task(name="task2")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"celery_task2,执行结果为:&#123;&#125;"</span>.format(arg)</span><br></pre></td></tr></table></figure>  </p><p>通过指定任务的name，celery选择合适的任务队列，如果需要worker配合，则需要使用-Q参数 指定队列的名称<code>celery worker -A tasks -l info -Q task1</code>此时这个worker只会处理这个队列中的任务。<br>但就一个小项目而言，则无需配置queue，将项目简单化，上面的代码就已经够用。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>至此我们成功完成了一个celery任务队列的模板，包括设置celery实例，添加了消息中间件与消息结果件，并且成功让worker执行。之后设置了beat定时任务，定时执行某些任务。<br>有没有发现，celery与我们所写的任务队列雏形十分相像？如果设置celery的任务与结果序列化方式为json的话，核心逻辑就是我们所写的demo。<br>另外这里需要注意的是，celery4.x在win10存在不兼容问题，所以我采用Ubuntu作为测试环境。</p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>这次学习了celery的基本使用方法，这篇文章的知识在简单和中型开发中已然够用。<br>celery虽然在python中很火，但是却无法使用在其他语言中，也限制了它的流行度，官网中的文档只有入门例子才有中文。网上的文章很多讲述地又不是很清楚，因此我总结了这篇文章，希望能更好地了解开发，不仅是代码，更是对架构的理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前讲过，在自己开发的公众号后台中有一个比较费时的请求操作，由于微信限制5秒内返回，无法立即返回结果，因此我开始寻找解决办法，最终决定使用&lt;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="python" scheme="http://re0.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>理解Java反射</title>
    <link href="http://re0.top/2020/03/22/java-reflection/"/>
    <id>http://re0.top/2020/03/22/java-reflection/</id>
    <published>2020-03-22T08:20:00.000Z</published>
    <updated>2020-03-22T16:08:00.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章鸽了好久，拖稿了好几天，趁着有精力的时候多写写文章。Java语言一直被我认为是常见语言中最难的语言，主要是概念繁多，然后就是JVM的知识点复杂，导致尽管有些人会写代码，但是问到某个知识点却不知道为何是这样。<br>今天谈谈Java中的反射机制。什么是反射呢？反射就是在Java编译期以外的时间可以动态的加载一个类。还可以实例化对象，获取变量，方法等。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>上面的概念刚开始我也不是很懂，为什么Java会有反射这种机制呢？假设有以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat cat = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure>  </p><p>JVM编译时会把代码编译成class文件加载到jvm的内存中，以上代码会使Cat.java文件编译成Cat.class然后加载到JVM的内存当中，然后执行new申请内存空间，然后返回实例。这种方法只适合已经知道需要什么对象，而如果在运行的时候才确定了对象，此时已经错过了编译期，所以需要动态地加载一个类，这样的操作我们称作<strong>反射</strong>。<br>那么反射有什么优点与缺点呢？优点就是十分灵活，类的加载无需重新编译，这种思想广泛用在了java生态当中，常见的框架都采用了反射的思想，如spring等。<br>而缺点就是影响性能，不建议使用在普通代码中，并且会使代码逻辑变得模糊，不利于维护。还有一点就是由于反射的功能强大，可以执行一些不被允许的操作（例如获取到类中的私有属性与方法），从而会引发某些问题。</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>在继续理解前，我们需要了解一下Java中的Class类。Class类是反射的基础。在Java中用来表示运行时类型信息的对应类就是Class类，存在于JDK的java.lang包中。手动编写一个类后，会产生一个Class对象，保存在同名的.class文件中。而这个类无论有多少个实例，内存中只有一个与之对应的Class对象。查看Class类的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">(ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        classLoader = loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们发现构造器为私有的，只有JVM能够创建Class对象，那么如何获得这个类的Class对象呢？有三种方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">Class c1 = Cat.class; <span class="comment">//任何类都有隐含的静态成员class用于获取Class对象</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">Class c2 = cat.getClass();<span class="comment">//实例有一个getClass方法获取Class对象</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">Class c3 = Class.forName(<span class="string">"Cat"</span>);<span class="comment">//Class类中的方法forName传入全量名可以获取这个类的Class对象</span></span><br></pre></td></tr></table></figure><br><strong>而通过Class对象获得类的信息的方法我们就称作反射(Reflection)。</strong></p><h2 id="反射的相关操作"><a href="#反射的相关操作" class="headerlink" title="反射的相关操作"></a>反射的相关操作</h2><h3 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h3><p>说了这么多，反射具体能做些啥呢？其实具体就以下几种：</p><ul><li>获取方法</li><li>获取属性(变量)</li><li>获取构造函数</li></ul><p>这里我统一使用Class.forName()获取Class对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id; <span class="comment">//特意将id设为public，开发中不这么写</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Class cls = Class.forName(<span class="string">"model.Cat"</span>);</span><br><span class="line">        Object o = cls.newInstance();</span><br><span class="line">        Method method = cls.getMethod(<span class="string">"setName"</span>, String.class);</span><br><span class="line">        method.invoke(o,<span class="string">"波斯猫"</span>);</span><br><span class="line">        System.out.println(cls.getMethod(<span class="string">"getName"</span>).invoke(o));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>首先使用Class.forName 获得Class对象，接着使用newInstance生成Cat的实例对象（之后会讲构造器的newInstance和直接的newInstance的区别），<br>使用getMethod可以获取某个方法，接着通过invoke方法传入对象与参数。<br>如果使用getMethods则可以获取所有方法。但是getMethod和getMethods获取的是public方法，如果需要获得私有方法，则使用getDeclaredMethod方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Method hello = cls.getDeclaredMethod(<span class="string">"hello"</span>);</span><br><span class="line">hello.setAccessible(<span class="keyword">true</span>); <span class="comment">//需要设置成可访问，才可以访问私有方法</span></span><br><span class="line">hello.invoke(o);</span><br></pre></td></tr></table></figure>  </p><h3 id="获取成员属性"><a href="#获取成员属性" class="headerlink" title="获取成员属性"></a>获取成员属性</h3><p>这里我们只写main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Class cls = Class.forName(<span class="string">"model.Cat"</span>);</span><br><span class="line">        Object o = cls.newInstance();</span><br><span class="line">        Method method1 = cls.getMethod(<span class="string">"setId"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        method1.invoke(o,<span class="number">1</span>);</span><br><span class="line">        Method method2 = cls.getMethod(<span class="string">"setName"</span>, String.class);</span><br><span class="line">        method2.invoke(o,<span class="string">"哈士奇"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取成员属性</span></span><br><span class="line">        Field field = cls.getField(<span class="string">"id"</span>);</span><br><span class="line">        System.out.println(<span class="string">"id: "</span> + field.get(o));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取成员private属性</span></span><br><span class="line">        Field field1 = cls.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        field1.setAccessible(<span class="keyword">true</span>);<span class="comment">//依旧需要设置成可访问</span></span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + field1.get(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><h3 id="获取构造函数"><a href="#获取构造函数" class="headerlink" title="获取构造函数"></a>获取构造函数</h3><p>反射还可以获取类的构造函数。在这之前，有一个之前说的问题，Class的newInstance和构造器的newInstance有什么差。其实他们的区别在于Class的newInstance方法只能创建无参数构造函数的类的实例，而构造器的newInstance方法则可以创建带有参数的类的实例。<br>我们另写两个类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Bird</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这两个类区别在于构造器分别是public和private。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Class cls = Class.forName(<span class="string">"model.Dog"</span>);</span><br><span class="line">        Constructor constructor = cls.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        Object o  = constructor.newInstance(<span class="number">100</span>);</span><br><span class="line">        Method method = cls.getMethod(<span class="string">"getId"</span>);</span><br><span class="line">        System.out.println(method.invoke(o));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Class cls1  = Class.forName(<span class="string">"model.Bird"</span>);</span><br><span class="line">        Constructor constructor1 = cls1.getDeclaredConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        constructor1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object o1 = constructor1.newInstance(<span class="number">101</span>);</span><br><span class="line">        System.out.println(cls1.getMethod(<span class="string">"getId"</span>).invoke(o1));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取构造器分别使用getConstructor与getDeclaredConstructor来获取公有和私有的构造器，而构造器的newInstance方法则是用来创建带参数的类的实例。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章差不多讲了Java反射的入门知识，学习了Class类与反射的基本知识。不同于new，反射可以在需要的时候动态加载类。尽管在开发中反射并不常见，但了解反射的思想有助于对框架源码的解读。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://tengj.top/2016/04/28/javareflect/" target="_blank" rel="noopener">http://tengj.top/2016/04/28/javareflect/</a><br><a href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html" target="_blank" rel="noopener">https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这篇文章鸽了好久，拖稿了好几天，趁着有精力的时候多写写文章。Java语言一直被我认为是常见语言中最难的语言，主要是概念繁多，然后就是JVM的
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="java" scheme="http://re0.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈python异步编程</title>
    <link href="http://re0.top/2020/03/11/python-sync/"/>
    <id>http://re0.top/2020/03/11/python-sync/</id>
    <published>2020-03-11T06:20:00.000Z</published>
    <updated>2020-03-12T09:39:47.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近开发的公众号后台需要有一个比较费时的检索操作，向某api接口请求数据，但接口返回时间不定，公众号又规定必须在5秒之内返回，不然会重发三次请求，还是无响应则显示公众号故障。由于公众号没有认证，无法主动给用户发送消息，所以我想了两天，想了几种解决方案：<br>1.直接使用requests的timeout，超过4秒的请求直接返回无结果，但是这对用户的体验很不友好。<br>2.超时之后返回“正在请求”，并继续将结果缓存到redis中，等下次用户请求相同数据时，直接从redis中返回，无需后端再向接口请求。<br>基于第二种方法，第一时间我想到的是异步编程，使用异步的http客户端请求接口，超时则返回，但请求依旧在进行，直到将结果缓存到redis中。<br>但是结果却出乎我的意料，在async函数1中await另一个async函数2，如果1已经返回，则2是强制被取消，原因大概是已经退出了事件循环，导致无法继续运行。<br>虽然最后没有用异步编程解决办法，但是还是重学一下python中的异步编程，梳理一下知识。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>异步编程中有许多概念，例如同步，异步，阻塞和非阻塞。我从网上找了许多解释，并加入了自己的理解。</p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步与异步最大的差别在与返回的结果是否立即返回，他们的关注点是消息的通信机制。举个例子：<br>假如函数1调用函数2，如果采用同步方式，则1要等待2返回结果后，才能返回。<br>而如果采用异步方式，则1无需关注2返回结果，继续运行，直到2返回后通过例如回调函数，通知等方式处理结果或通知调用者1完成了本次调用。<br>简单一点说，就是同步是调用者<strong>主动等待</strong>被调用者的结果，而异步则是被调用者<strong>主动通知</strong>调用者结果。</p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>这两个的关注点在于程序在等待调用结果时所在的状态。<br>阻塞调用是指在结果返回前，当前线程将被挂起。而调用线程只有在得到结果后才返回。<br>非阻塞调用是不能立即得到结果之前，该调用不会阻塞当前线程。还是举个简单例子：<br>如果是阻塞调用，则调用者会将自己挂起，不做其他事，直到得到调用结果。<br>而如果是非阻塞调用，则调用者可以做其他事情，但每隔一段时间就会查看是否得到调用结果。<br>所以同步通信可以阻塞也可以非阻塞。在编程中我们常见的逻辑基本上是同步阻塞的。这样逻辑较为清楚。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><p>python之父用了好几年的时间才将asyncio库编写完成，可见异步编程是值得这么做的。python中可以实现多线程和多进程，很多人认为有这两个就没有特别必要实现异步，但是多线程存在着许多问题，例如竞争，锁等问题，导致处理十分麻烦。基于这点python3.4加入了asyncio模块，加入了异步编程，并在3.7中加入了async与await关键字。<br>这个异步模块特点在于只有一个线程，这一点与JavaScript相同。由于只有一个线程，所以asyncio 是”多任务合作”模式（cooperative multitasking），即允许任务交出执行权给其他任务，等待其他任务完成后回收执行权。其实就是分享运行时间。<br>这样虽然没有合理使用多线程多进程来充分利用CPU，但代码逻辑清晰，符合编程思维。<br>asyncio在单线程中启动一个事件循环（event loop）时刻监听进入循环的事件，处理，重复过程，直到异步任务结束，而事件循环与<a href="https://wangdoc.com/javascript/async/general.html" target="_blank" rel="noopener">JavaScript的模型</a>相同。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程又叫微线程，Coroutine，协程的作用是可以随时中断去执行其他操作，虽然像是多线程，但协程只有一个线程在运行。其优点有：</p><ul><li>执行效率极高，因为子程序切换（函数）不是线程切换，由程序自身控制，没有切换线程的开销。所以与多线程相比，线程的数量越多，协程性能的优势越明显。</li><li>不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在控制共享资源时也不需要加锁，因此执行效率高很多。</li></ul><p>一个简单的demo(来自官方文档)：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"world"</span>)</span><br><span class="line">asyncio.run(func1())</span><br></pre></td></tr></table></figure><br>这个例子中，先打印了hello隔了一秒钟后打印world。<br>在asyncio中，提供了三种方式运行协程</p><ol><li>asyncio.run() 函数用来运行最高层级的入口点</li><li>等待一个协程，也就是await关键字。</li><li>asyncio.create_task() 函数用来<strong>并发</strong>运行作为 asyncio 任务的多个协程。</li></ol><h2 id="Future-对象"><a href="#Future-对象" class="headerlink" title="Future 对象"></a>Future 对象</h2><p>Future较为少用，因为这个比较底层，表示的是一个异步操作的结果。在Java中也有Future，在python的官方文档中讲的也不是很多，这里不过多讲述。</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>如上面第三个方式，任务是Future的子类，用来的是并发执行协程<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(delay)</span>:</span></span><br><span class="line"><span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">print(delay)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task1 = asyncio.create_task(</span><br><span class="line">        func1(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    task2 = asyncio.create_task(</span><br><span class="line">        func1(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure></p><p>这段代码等待的时间并不是3秒，而是2秒，因为task1和task2是并发执行。<br>在文档中还提到另一个并发执行任务的函数，asyncio.gather，那么它与create_task又有什么区别？<br>create_task将协程交给事件循环，返回task，并且可以通过cancel()取消任务。<br>而asyncio.gather用于你需要获得协程的结果，它返回的是各自的结果的列表。如果其中一个协程发生异常，则引发异常。</p><h2 id="同步与异步对比"><a href="#同步与异步对比" class="headerlink" title="同步与异步对比"></a>同步与异步对比</h2><p>这里要说的一点是time.sleep与asyncio.sleep的差别，time.sleep是阻塞的，而asyncio.sleep是非阻塞的。在异步方法中使用time.sleep会使整个线程阻塞。asyncio.sleep返回的是一个future对象，可等待。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同步示例</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        hello()</span><br><span class="line">        print(<span class="string">'Hello World:%s'</span> % time.time())</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="comment">#Hello World:1583993483.900457</span></span><br><span class="line"><span class="comment">#Hello World:1583993484.9013405</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#异步示例</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'Hello World:%s'</span> % time.time())</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">await</span> hello()</span><br><span class="line">     </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment">#Hello World:1583994087.0926125</span></span><br><span class="line"><span class="comment">#Hello World:1583994087.0926125</span></span><br></pre></td></tr></table></figure><p>这里要说的是，如果asyncio.sleep前加入await，则异步函数hello会等待sleep结束才继续输出，不加await会报warning，但是不影响运行。</p><h2 id="异步http"><a href="#异步http" class="headerlink" title="异步http"></a>异步http</h2><p>基于以上的代码可以知道，异步操作其实是就是将耗时操作异步化，使得代码运行时间缩短。<br>在爬虫中如果需要大量的请求，并且要缩短时间，通常使用异步的http客户端进行爬取。由于requests库是同步的，在请求的时候会阻塞，所以requests不支持异步操作，通常我们会使用grequests和aiohttp等库，这里我们使用aiohttp。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://www.example.com/"</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            response = <span class="keyword">await</span> response.read()</span><br><span class="line">            print(response)</span><br><span class="line">     </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    asyncio.run(hello())</span><br></pre></td></tr></table></figure><br>response.read()是一个耗时的io操作，前面加上await关键字等待响应。</p><h2 id="多链接同步请求与异步请求对比"><a href="#多链接同步请求与异步请求对比" class="headerlink" title="多链接同步请求与异步请求对比"></a>多链接同步请求与异步请求对比</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,time,asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://www.qq.com"</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            response = <span class="keyword">await</span> response.read()</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello2</span><span class="params">()</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        response = r.text</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">        task = asyncio.create_task(hello())</span><br><span class="line">        tasks.append(task) </span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"start time at &#123;&#125;"</span>.format(time.strftime(<span class="string">"%X"</span>)))</span><br><span class="line">    hello2()</span><br><span class="line">    print(<span class="string">"end time at &#123;&#125;"</span>.format(time.strftime(<span class="string">"%X"</span>)))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"start time at &#123;&#125;"</span>.format(time.strftime(<span class="string">"%X"</span>)))</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    print(<span class="string">"end time at &#123;&#125;"</span>.format(time.strftime(<span class="string">"%X"</span>)))</span><br><span class="line"><span class="comment">#start time at 16:59:05</span></span><br><span class="line"><span class="comment">#end time at 16:59:12</span></span><br><span class="line"><span class="comment">#start time at 16:59:12</span></span><br><span class="line"><span class="comment">#end time at 16:59:12</span></span><br></pre></td></tr></table></figure><p>可以发现使用异步操作爬取页面速度非常之快。</p><h2 id="使用同一个ClientSession"><a href="#使用同一个ClientSession" class="headerlink" title="使用同一个ClientSession"></a>使用同一个ClientSession</h2><p>而aiohttp文档中建议使用单个ClientSession，而不是每次连接都重新创建一个对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,time,asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line">url = <span class="string">"http://www.qq.com"</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            response = <span class="keyword">await</span> response.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">        task = asyncio.create_task(hello())</span><br><span class="line">        tasks.append(task) </span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello1</span><span class="params">(session)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">        response = <span class="keyword">await</span> response.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        tasks = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">            task = asyncio.create_task(hello1(session))</span><br><span class="line">            tasks.append(task)</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    print(time.time() - start)</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    asyncio.run(main2())</span><br><span class="line">    print(time.time() - start)</span><br></pre></td></tr></table></figure><br>这次我们使用了同一个ClientSession()，在测试了30，100，500，1000个请求后发现，使用同一个session速度略快一些，大概是两倍左右。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>学了几天基础的python异步编程，对异步编程又有了新的理解，学习了异步爬虫的基本原理，曾经使用过的scrapy框架，现在能够理解它对异步的支持。<br>虽然没有解决开发上的问题，但还是收获很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近开发的公众号后台需要有一个比较费时的检索操作，向某api接口请求数据，但接口返回时间不定，公众号又规定必须在5秒之内返回，不然会重发三次
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="python" scheme="http://re0.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>浅谈python中的引用与拷贝</title>
    <link href="http://re0.top/2020/03/04/python-copy/"/>
    <id>http://re0.top/2020/03/04/python-copy/</id>
    <published>2020-03-04T06:20:00.000Z</published>
    <updated>2020-03-04T08:19:56.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在爬取某游戏攻略的时候，发现写入到json的文件中全是重复的字典，但是数据库中的数据却是正常的，在寻找了一段时间的bug后，想起来python中对赋值操作本质上是对象的引用，而不是复制对象，所以将字典”复制”后append到list中，只要这个字典发生变化，整个list中的字典都是一样的值。心血来潮，重新学习一下引用与拷贝。</p><h1 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h1><p>类似代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dict1 = &#123;&apos;type_a&apos;:&apos;&apos;,&apos;type_b&apos;:&apos;&apos;&#125;</span><br><span class="line">all_list = []</span><br><span class="line">for i in range(2):</span><br><span class="line">    new_dict = dict1</span><br><span class="line">    new_dict[&apos;type_a&apos;] = i</span><br><span class="line">    new_dict[&apos;type_b&apos;] = i+10</span><br><span class="line">    all_list.append(new_dict)</span><br><span class="line">print(all_list) #[&#123;&apos;type_a&apos;: 1, &apos;type_b&apos;: 11&#125;, &#123;&apos;type_a&apos;: 1, &apos;type_b&apos;: 11&#125;]</span><br></pre></td></tr></table></figure><br>为什么会出现这样的问题，原因在于new_dict引用了dict1的内存地址，本质上两个变量指向的是同一个内存地址，并且list的append本质上也是对对象的引用。<br>使用id函数查看变量指向的内存地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(id(dict1)) #1584039349560</span><br><span class="line">print(id(new_dict)) #1584039349560</span><br></pre></td></tr></table></figure><br>可以发现两个字典的内存地址相同，那么解决办法很简单，<br>1.直接让new_dict = {},相当于建立的一个新的字典，这样两个变量之间就没有关系。<br>2.使用dict中的copy方法或者使用标准库中copy.copy，将dict1的对象复制过来(不是引用)。这两种办法都可以解决对象重复的问题，我刚开始之所以那么写，主要原因是字典的属性直观一点，java代码写多了，就不自觉的想要new一个对象，哈哈。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>虽然解决了问题，但是学习还没完，那么python中的引用究竟是怎么一回事？在python中，无论什么数据类型，都是按照引用进行赋值的。变量名和变量的真实值是分开保存的，变量名中保存的是真实值的一个指针，对变量赋值时，也是将这个指针赋值给新变量。<br>在python中有三类不可变型，数值型，字符串型，元祖，其他的都属于可变型，如字典，列表。<br>所谓不可变型，就是我们无法在内存中修改这个变量，如果尝试修改，则会断开对前一个对象的引用，重新分配内存地址。而可变型则是不会断开前一个对象的引用。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">print(id(a)) #1825271552</span><br><span class="line">a += 1</span><br><span class="line">print(id(a)) #1825271584</span><br><span class="line"></span><br><span class="line">list1 = [1,2,3]</span><br><span class="line">print(id(list1)) #1853070359112</span><br><span class="line">list1.append(a)</span><br><span class="line">print(id(list1)) #1853070359112</span><br></pre></td></tr></table></figure></p><p>python解释器在运行时，会根据是否为可变类型决定是在原来内存地址上修改还是进行重新引用。<br>而如果将参数传入函数时，刚开始形参与实参指向的是同一内存地址，而如果函数内部对参数进行修改的话，会根据是否为可变类型决定是否断开对原来对象的引用。<br>python中内置了引用计数器，每当进行一次引用时，该对象的引用计数器+1，而取消一次引用时，则-1，如果归0，则销毁这个对象，这也是python的垃圾回收机制之一。<br>结合文初的问题，new_dict其实引用的是dict1的内存地址(相当于C/C++中的指针)，而由于字典属于可变类型，所以进行修改时不会改变其内存对象。而append方法实际上追加的是该对象的引用。所以对该字典修改后则列表中的所有元素也会跟着修改。</p><h1 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h1><p>那标准库中的copy包又是怎么一回事呢。copy与deepcopy的差别又是什么？我们查看官方文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python 中赋值语句不复制对象，而是在目标和对象之间创建绑定 (bindings) 关系。</span><br><span class="line">浅层复制和深层复制之间的区别仅与复合对象 (即包含其他对象的对象，如列表或类的实例) 相关:</span><br><span class="line">一个 浅层复制 会构造一个新的复合对象，然后（在可能的范围内）将原对象中找到的 引用 插入其中。</span><br><span class="line">一个 深层复制 会构造一个新的复合对象，然后递归地将原始对象中所找到的对象的 副本 插入。</span><br></pre></td></tr></table></figure></p><p>通过官方文档我们可以知道：<br>copy是复制表层对象，如果对象中还存在对象，则内部对象依旧进行引用。字典可以使用dict.copy进行浅拷贝，而list则可以通过切片操作[:]进行浅拷贝。<br>而deepcopy则会递归复制对象中的对象。<br>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list1 = [1,2,3]</span><br><span class="line">a = &#123;&apos;1&apos;:&apos;&apos;,&apos;2&apos;:list1&#125;</span><br><span class="line">all_list = []</span><br><span class="line">for i in range(2):</span><br><span class="line">    new = copy.copy(a)</span><br><span class="line">    new[&apos;1&apos;] = i</span><br><span class="line">    all_list.append(new)</span><br><span class="line">print(all_list) #[&#123;&apos;1&apos;: 0, &apos;2&apos;: [1, 2, 3]&#125;, &#123;&apos;1&apos;: 1, &apos;2&apos;: [1, 2, 3]&#125;]</span><br><span class="line">list1[0] = 0</span><br><span class="line">print(all_list) #[&#123;&apos;1&apos;: 0, &apos;2&apos;: [0, 2, 3]&#125;, &#123;&apos;1&apos;: 1, &apos;2&apos;: [0, 2, 3]&#125;]</span><br></pre></td></tr></table></figure><br>可以发现内部对象依旧是进行引用，而使用深拷贝后修改list1中的元素也不会改变字典中的元素。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天重新学习了一下python的引用，即使之前就学过，但重新学习写文章后依旧收获颇丰。引用是python中最常接触的操作，引用相当于指针，但又与指针不同，当修改数据时python会根据类型是否可变来选择是否修改内存地址，还是直接在内存地址中修改数据。<br>而拷贝往往是因为需要对象的副本来进行操作。当然一不注意就会掉入陷阱，直接赋值导致引用了同一对象，当一处修改则所有值改变。而copy与deepcopy就是为了解决这个问题，而两者的区别就是在于是否对子对象进行拷贝。当然在使用deepcopy时要注意递归循环。而对象的拷贝也可以通过定义 __copy__() 和 __deepcopy__()来实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在爬取某游戏攻略的时候，发现写入到json的文件中全是重复的字典，但是数据库中的数据却是正常的，在寻找了一段时间的bug后，想起来pyt
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Springboot常用注解</title>
    <link href="http://re0.top/2020/02/10/spring-annotation/"/>
    <id>http://re0.top/2020/02/10/spring-annotation/</id>
    <published>2020-02-10T13:20:00.000Z</published>
    <updated>2020-03-04T08:24:59.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在使用springboot进行开发，也学习了不少spring的知识，记录一下spring中常用的注解，方便自己学习与查找。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p>bean是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。<br>该注解主要定义在@Configuration或者@Component注解的类里，声明该方法的返回值是一个bean。</p><h2 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h2><p>定义一个最普通的组件(spring管理bean)，注入到spring容器中进行管理。</p><h2 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h2><p>是@Component的拓展，被这个注解的类表示为DAO层实现。</p><h2 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h2><p>是@Component的拓展，被这个注解的类表示为Service层实现。</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h2><p>被这个注解的类表示为Web层实现。通常用于控制web逻辑。</p><h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p>Spring 4后加入的新注解，为@Controller 与 @ResponseBody的结合。在其注解的控制器中可直接在页面中返回数据。</p><h2 id="ControllerAdvice，-RestControllerAdvice"><a href="#ControllerAdvice，-RestControllerAdvice" class="headerlink" title="@ControllerAdvice，@RestControllerAdvice"></a>@ControllerAdvice，@RestControllerAdvice</h2><p>控制类增强，通常做全局处理。</p><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>最常用到的注解之一，会将HTTP请求映射到控制器中。</p><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p>用于获取请求中的参数。</p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><p>与@RequestParam类似，只不过一个在参数部分，另一个在URL路径部分。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过@PathVariable，例如/users/1</span><br><span class="line">通过@RequestParam，例如/users?userid=1</span><br></pre></td></tr></table></figure></p><h2 id="Valid"><a href="#Valid" class="headerlink" title="@Valid"></a>@Valid</h2><p>参数校验，在model里面设置每个参数的校验方法，例如@NotNull，@NotBlank，之后在controller中的方法参数上添加@Valid注解，就可以对请求参数进行校验，并将校验结果返回在一个BindingResult实例中，所以参数后一定要紧跟BindingResult！</p><h2 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h2><h3 id="1-在方法上使用"><a href="#1-在方法上使用" class="headerlink" title="1.在方法上使用"></a>1.在方法上使用</h3><p>标注在方法上的@ModelAttribute说明方法是用于添加一个或多个属性到model上。在同一个控制器中，注解了@ModelAttribute 的方法实际上会在@RequestMapping 方法之前被调用。通常被用来填充一些公共需要的属性或数据。</p><h3 id="2-在方法参数上使用"><a href="#2-在方法参数上使用" class="headerlink" title="2.在方法参数上使用"></a>2.在方法参数上使用</h3><p>标注在方法参数上的@ModelAttribute说明了该方法参数的值将由model中取得。在SpringMvc中称为数据绑定。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/login&quot;,method = RequestMethod.POST)</span><br><span class="line">public ReturnMsg login(@ModelAttribute User user, HttpServletResponse response)</span><br></pre></td></tr></table></figure></p><p>可直接把参数自动与user实例的字段进行绑定。</p><h2 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h2><p>用来定义函数针对的异常类型。如果@ExceptionHandler方法是在控制器内部定义的，那么它会接收并处理由控制器（或其任何子类）中的@RequestMapping方法抛出的异常。<br>如果将@ExceptionHandler方法定义在@ControllerAdvice类中，那么它会处理相关控制器中抛出的异常。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ExceptionHandler(value = CustomException.class)</span><br></pre></td></tr></table></figure></p><p>则是处理CustomException异常，对其他异常不处理。</p><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><p>自动装配注解，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private UserDAO userDAO;</span><br></pre></td></tr></table></figure></p><p>意思是让spring自动向userDAO中注入一个UserDAO的实例。<br>Spring IoC容器扫描到@Autowired注解会去查询其实现类，写法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private IUserDAO userDAO;</span><br></pre></td></tr></table></figure></p><p>其中IUserDAO为接口，而UserDAO为实现类。</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p>标注在类上，相当于把这个类作为spring的配置类。</p><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><p>将部分参数配置在application.properties 或 application.yml 文件中，通过这个注解，可以获取到这些值。<br>1.可以与@Component一起使用，使该类被Component Scan扫描到，并激活。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix=&quot;mail&quot;)</span><br><span class="line">public class ConnectionSettings &#123;</span><br><span class="line">    private String username;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.也可以使用@EnableConfigurationProperties与@Configuration，但是不推荐。<br>3.第三种则是使用@Bean方式在标有@Configuration的类进行注入，这种方式通常可以用在对第三方类进行配置属性注册。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConfigurationProperties(prefix = &quot;mail&quot;)</span><br><span class="line">public Mail mail()&#123;</span><br><span class="line">return new Mail();</span><br><span class="line">&#125;</span><br><span class="line">//当需要的时候使用Autowired进行注入</span><br></pre></td></tr></table></figure></p><p>这里有一个开发时发现的问题。在某个工具类中使用@Autowired注入获取对象时，发现无法其属性值总为null，查了许多资料，发现是spring在实例化Bean时，先通过反射调用构造方法生成一个基本对象，然后再填充属性。填充属性之前属性值都为默认值，引用类为null，构造方法中使用属性对象时属性对象还未被设置，所以为null。<br>这里需要在这个工具类的构造器中将Bean作为参数显式地传入，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//需要将该类定义为组件，添加到spring容器后spring才会自动注入实例(此时可以不使用@Autowired)</span><br><span class="line">@Component</span><br><span class="line">public class OneUtil &#123;</span><br><span class="line"></span><br><span class="line">    private A a;</span><br><span class="line"></span><br><span class="line">    // 构造器中将Bean作为参数显式的传入，spring装配时自动将实例的值传给该组件，可以有效避免NPE问题；</span><br><span class="line">    public OneUtil(A a)&#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="MapperScan"><a href="#MapperScan" class="headerlink" title="@MapperScan"></a>@MapperScan</h2><p>可以指定要扫描的Mapper类的包的路径，不用在每个Mapper类上注解@Mapper。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这篇查了许多资料，在用spring写了个demo后觉得需要理解这些注解。写完文章后发现要理解一个框架比使用一个框架难得多，接下来就是不断在开发中寻找问题与解决办法，总结经验。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在使用springboot进行开发，也学习了不少spring的知识，记录一下spring中常用的注解，方便自己学习与查找。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="web" scheme="http://re0.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>DNS投毒分析</title>
    <link href="http://re0.top/2020/01/05/dns-cache-pollution/"/>
    <id>http://re0.top/2020/01/05/dns-cache-pollution/</id>
    <published>2020-01-05T14:20:28.000Z</published>
    <updated>2020-01-05T15:31:58.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近因为研究了下DNSsec技术突然想起来著名的DNS投毒，就是DNS缓存污染，今天趁着有点时间研究下某知名防火墙对DNS是怎么进行污染的。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>由于DNS采用UDP协议来进行查询和应答，由于UDP是无连接的，所以当我们发送一个DNS请求时，如果有多个DNS响应包时，操作系统一般是以最先收到的响应包为准，这就使得了如果攻击者在正规DNS服务器的响应包到达之前伪造了一份DNS响应，便可将用户导向不一致的IP地址，如此便实现的DNS污染。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>在中国大陆的运营商DNS服务器（尤其是移动），一般情况下都会对某些域名进行屏蔽，即当你向该服务器请求DNS解析时(例如google)，服务器会响应一个ip地址为0.0.0.0的地址。我们以我本地移动的DNS为例：<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/3.png" alt=""><br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/5.png" alt=""><br>当我们对google主域名进行DNS查询时，我们可以发现移动的dns解析只返回了0.0.0.0的ip地址。<br>而尝试114dns与阿里DNS，<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/2.png" alt=""><br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/4.png" alt=""><br>除了会返回一个0.0.0.0的地址外，还会有另一个响应包，地址为69.172.225.13和31.13.71.23，这两个地址都不是指向google的，而是指向了其他地区，有法国的，有美国的，经过多次测试，这个ip地址并不是固定的，而是随机指向一个ip地址。<br>因此我猜测这个dns响应应该是防火墙所返回的。<br>进一步测试谷歌的DNS服务器。<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/7.png" alt=""><br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/6.png" alt=""><br>我们收到了多个DNS响应。我进行了多次测试，无论是8.8.8.8还是8.8.4.4，有时候会返回三个响应，有时候会返回四个响应，我猜测应该是多个出国网关都部署了防火墙，才会有此结果。<br>猜测可能是关键字匹配，我们接着测试不存在的域名会如何返回。<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/9.png" alt=""><br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/8.png" alt=""><br>我们可以发现8.8.4.4竟然还是返回了两个ip地址！<br>使用美国的服务器的进行dns查询，只会得到NXDOMAIN即域名不存在的结果。<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/10.png" alt=""><br>而在我进行重复测试时发现，无论是8.8.8.8还是8.8.4.4，有时候会有正常结果返回，而有时候却只有错误的ip地址，甚至连域名不存在都无法返回。这也是防火墙高明所在。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有一点要说明的是，在使用google dns进行正常域名解析时，是正常的。无论是8.8.8.8还是8.8.4.4。<br>那基本可以得出结论<br>1.运营商网络的DNS会将屏蔽域名解析为0.0.0.0<br>2.google的dns虽然在中国大陆可以使用，但防火墙制造了一种假象，使得每个人认为它返回域名都是正常，在对某些被屏蔽域名进行解析时，它并不会都返回正确的结果，我猜测正确结果会不时地被防火墙所拦截，从而营造出是DNS服务器自身的问题。而如果正确结果没被拦截，响应也通常会在最后到达，但这时候通常已经不管用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近因为研究了下DNSsec技术突然想起来著名的DNS投毒，就是DNS缓存污染，今天趁着有点时间研究下某知名防火墙对DNS是怎么进行污染的。
      
    
    </summary>
    
    
      <category term="web" scheme="http://re0.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈最近</title>
    <link href="http://re0.top/2019/11/12/2019-11-12/"/>
    <id>http://re0.top/2019/11/12/2019-11-12/</id>
    <published>2019-11-12T10:32:47.000Z</published>
    <updated>2019-11-16T13:57:12.635Z</updated>
    
    <content type="html"><![CDATA[<p>几个月没写文章，谈一谈最近一年都在干些啥事吧。<br>从18年末开始，我就很少参加CTF比赛，不管大的小的，虽然没有参加，但还是有在业余的时候看看一些大型比赛的解题思路和漏洞报告。<br>这一年来，也是学了不少东西，主要是使用python写了两个脚本，一个抢课脚本，一个群体签到软件，主要是感觉挺好玩的。18年末到19年1月左右，主要是深入学习了计算机组成还有数据库，然后学习了Vue结合PHP写了个简单的图书管理系统。<br>19年寒假的时候开始学习php的laravel框架，正好寒假后回学校有一门课程也是使用php设计web应用。<br>然后下半学期开始学习TensorFlow，起因是为了验证码识别，然后接着学了keras后端，写了一个针对学校某系统的验证码识别。<br>接着是两个月的中心放在深入学习计算机网络，网络协议，还有操作系统上面，特别是操作系统，深入之后也有了自己的理解，收获还是蛮大的。<br>暑假学习了点spring框架，但没有使用spring写点东西。然后就是学习了下网站渗透的各种姿势。剩下时间基本上在练车考驾照。<br>这学期开始课内主要是学习网络安全相关知识和python的编程，但这些基本上大一就自学过了。大部分时间在完善群体签到软件，Android端也从5月份开始学习了挺多。然后就是基本上在重学数据结构与算法，深入理解再与实际开发相结合，主要是为了之后的面试做准备，收获颇丰。<br>接下来我还是比较迷茫的，是走安全路线还是开发路线也还没想好。不过我想，基础还是得先打好吧，所以重学了数据结构。走一步看一步吧，加油。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;几个月没写文章，谈一谈最近一年都在干些啥事吧。&lt;br&gt;从18年末开始，我就很少参加CTF比赛，不管大的小的，虽然没有参加，但还是有在业余的时候看看一些大型比赛的解题思路和漏洞报告。&lt;br&gt;这一年来，也是学了不少东西，主要是使用python写了两个脚本，一个抢课脚本，一个群体
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://re0.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
