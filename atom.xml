<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zer0e&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://re0.top/"/>
  <updated>2024-07-10T14:50:06.133Z</updated>
  <id>https://re0.top/</id>
  
  <author>
    <name>Zer0e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【架构之路1】k8s集群搭建</title>
    <link href="https://re0.top/2024/07/10/devops1/"/>
    <id>https://re0.top/2024/07/10/devops1/</id>
    <published>2024-07-10T15:30:00.000Z</published>
    <updated>2024-07-10T14:50:06.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>k8s集群是目前中大型公司的首选微服务部署方案，包括高可用，便捷性等等，但是也有人建议中小厂最好不用k8s去部署，因为这意味着你需要有一个专门的精通k8s的运维工程师去解决各种大大小小的问题，但说实话不难，你遇到的问题，99%都能在网上搜索到。  </p><p>所以我个人的观点是能用则用，当然如果是裸金属服务器的话，成本那就比较高了，但是如果你是用虚拟化技术来创建集群的话成本就小一点。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>废话少说，开始干！</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>以我本次的demo为例，环境准备3台centOS7虚拟机。  </p><p>配置好国内源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">// 没有wget用curl</span><br><span class="line">curl -o Cenos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><p>安装ntp，同步时钟</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install ntp</span><br><span class="line">systemctl <span class="built_in">enable</span> ntpd</span><br><span class="line">// 手动同步时钟</span><br><span class="line">ntpdate ntp1.aliyun.com</span><br><span class="line">// 需要持续可用的话需要配合cron做定时同步</span><br></pre></td></tr></table></figure><p>关闭防火墙！！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p>安装新一点的docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker docker-common docker-selinux docker-engine</span><br><span class="line">// 添加docker仓库</span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure><p>修改三台虚拟机的hostname分别为worker1, worker2, worker3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/hostname</span><br><span class="line">worker1</span><br></pre></td></tr></table></figure><p>固定三台虚拟机的ip地址,子网根据vmnet8所分配的，你也可以自行更改。ip分别为192.168.28.138，192.168.28.139，192.168.28.140.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// vmware的虚拟机网卡基本上都叫ens33</span><br><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line">修改BOOTPROTO=static和ONBOOT=yes</span><br><span class="line">增加</span><br><span class="line">IPADDR=192.168.28.138</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">NETWORK=192.168.28.0</span><br><span class="line">BROADCAST=192.168.28.255</span><br><span class="line">DNS1=192.168.28.2</span><br><span class="line">GATEWAY=192.168.28.2</span><br></pre></td></tr></table></figure><p>增加dns映射，三台都加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/hosts</span><br><span class="line">192.168.28.138 worker1</span><br><span class="line">192.168.28.139 worker2</span><br><span class="line">192.168.28.140 worker3</span><br></pre></td></tr></table></figure><p>由于目前国内的网络环境，不管是rpm包还是docker镜像，都有可能拉取不下来，强烈建议在本机开放允许局域网的连接来使用飞机。在需要时可能会用到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;https://192.168.28.1:10801/&quot;</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://192.168.28.1:10801/&quot;</span></span><br><span class="line"><span class="built_in">export</span> no_proxy=<span class="string">&quot;localhost,127.0.0.1,.example.com,192.168.28.0/16&quot;</span></span><br></pre></td></tr></table></figure><p>配置docker代理或镜像源。镜像源我就不配置了，目前国内源懂得都懂，这里介绍配置docker pull使用代理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/systemd/system/docker.service.d</span><br><span class="line">vi /etc/systemd/system/docker.service.d/proxy.conf</span><br><span class="line">// 把以下代理内容写进去，注意不需要写http(s)协议</span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">&quot;HTTP_PROXY=192.168.28.1:10801&quot;</span></span><br><span class="line">Environment=<span class="string">&quot;HTTPS_PROXY=192.168.28.1:10801&quot;</span></span><br><span class="line">Environment=<span class="string">&quot;NO_PROXY=localhost,127.0.0.1,.example.com,192.168.28.0/16&quot;</span></span><br></pre></td></tr></table></figure><p>重启下docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line">docker info出现HTTP Proxy说明配置完成</span><br></pre></td></tr></table></figure><p>至此准备工作就此完成！</p><h2 id="创建k8s集群"><a href="#创建k8s集群" class="headerlink" title="创建k8s集群"></a>创建k8s集群</h2><p>这里我推荐使用<a href="https://docs.k3s.io/zh/">k3s</a>, 一个轻量的k8s集群，没有etcd作为存储，因此如果需要使用在生产环境中建议配置etcd，这里我们采取默认脚本来安装，十分简单。</p><p>先在终端中将代理export下，然后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sfL https://get.k3s.io | INSTALL_K3S_EXEC=<span class="string">&quot;--docker&quot;</span> sh -</span><br></pre></td></tr></table></figure><p>这里我们依旧采用docker作为容器运行时。</p><p>安装完成后kubeconfig文件被放在<code>/etc/rancher/k3s/k3s.yaml</code>中。</p><p>接着执行<code>cat /var/lib/rancher/k3s/server/node-toke</code>获取主节点的token。然后在其他节点上执行（也是记得export）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sfL https://get.k3s.io | K3S_URL=https://worker1:6443 K3S_TOKEN=获取的token INSTALL_K3S_EXEC=<span class="string">&quot;--docker&quot;</span> sh -</span><br></pre></td></tr></table></figure><p>子节点全部启动agent成功后，在主节点执行<code>kubectl get nodes</code>看见其他节点就说明安装完成了，前后不超过5分钟。</p><p>当然此时子节点还没有标签，我们可以打上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node worker2 node-role.kubernetes.io/worker=worker</span><br><span class="line">kubectl label node worker3 node-role.kubernetes.io/worker=worker</span><br><span class="line">// 当然主节点worker1也可以标上工作节点</span><br><span class="line">kubectl label node worker1 node-role.kubernetes.io/worker=worker</span><br></pre></td></tr></table></figure><p>这里还有个小点，就是当终端中有那些代理的变量时，这些变量会写入到<code>/etc/systemd/system/k3s.service.env</code>，作为后续kubectl的使用代理，如果没有配置no_proxy需要加上，当然你也可以去掉代理，然后重启k3s服务，否则例如<code>kubectl logs</code>可能会提示代理出错。可以参考官方<a href="https://docs.k3s.io/zh/advanced#%E9%85%8D%E7%BD%AE-http-%E4%BB%A3%E7%90%86">wiki</a>.</p><h2 id="安装kubepi面板"><a href="#安装kubepi面板" class="headerlink" title="安装kubepi面板"></a>安装kubepi面板</h2><p><a href="https://github.com/1Panel-dev/KubePi">kubepi</a>是一个开源的k8s面板，个人觉得挺好用的，装一个可以清楚看到容器的运行状态，不用再去一个个敲命令。<a href="https://github.com/1Panel-dev/KubePi/wiki/2%E3%80%81%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2">官方wiki</a>中也有详细的部署教程，但是持久化部署官方用的nfs，集群刚搭建起来怎么会有呢，因此我稍微改了一下，把存储放到本地了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">vim</span> <span class="string">kubepi-pvc.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubepi-user</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubepi-user</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubepi-user</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">local-storage</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">kubernetes.io/no-provisioner</span></span><br><span class="line"><span class="attr">volumeBindingMode:</span> <span class="string">WaitForFirstConsumer</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubepi-pv</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">kubepi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">local-storage</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Delete</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/home/k8s/kubepi</span></span><br><span class="line">  <span class="attr">nodeAffinity:</span></span><br><span class="line">    <span class="attr">required:</span></span><br><span class="line">      <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">          <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">worker1</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubepi-pv-claim</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">kubepi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">local-storage</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubepi</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">kubepi</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubepi</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">kubepi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/name:</span> <span class="string">kubepi</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app.kubernetes.io/name:</span> <span class="string">kubepi</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubepi</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">kubeoperator/kubepi-server:latest</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">securityContext:</span></span><br><span class="line">            <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubepi-persistent-storage</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/var/lib/kubepi</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubepi-persistent-storage</span></span><br><span class="line">          <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">            <span class="attr">claimName:</span> <span class="string">kubepi-pv-claim</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要修改的是节点亲和性相关，由于local-path使用的是本机存储需要指定主机，因此pv创建需要有节点条件，修改matchExpressions的[0].value改为你想部署的节点hostname即可。然后<code>/home/k8s/kubepi</code>可以提前创建目录出来，不确定k8s会不会自动创建。</p><p>接下来就是获取nodePort暴露的端口，这个官方有。</p><p><code>export NODE_PORT=$(kubectl -n kube-system get services kubepi -o jsonpath=&quot;&#123;.spec.ports[0].nodePort&#125;&quot;)</code></p><p>由于上述我们改了节点亲和性，因此访问的地址就是<code>http://worker1:$NODE_PORT</code>，账号为admin，密码为kubepi</p><p>当然我们也可以固定下来端口，例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubepi</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">31779</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">kubepi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此就完成了一个简单的三节点k8s集群的搭建了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;k8s集群是目前中大型公司的首选微服务部署方案，包括高可用，便捷性等等，但是也有人建议中小厂最好不用k8s去部署，因为这意味着你需要有一个专
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="架构" scheme="https://re0.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="运维" scheme="https://re0.top/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="从0.5开始的运维架构之路" scheme="https://re0.top/tags/%E4%BB%8E0-5%E5%BC%80%E5%A7%8B%E7%9A%84%E8%BF%90%E7%BB%B4%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>从0.5开始的运维架构之路0</title>
    <link href="https://re0.top/2024/07/10/devops0/"/>
    <id>https://re0.top/2024/07/10/devops0/</id>
    <published>2024-07-10T12:00:00.000Z</published>
    <updated>2024-07-10T14:42:48.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="随便聊聊"><a href="#随便聊聊" class="headerlink" title="随便聊聊"></a>随便聊聊</h1><p>最近离职了无聊想写一个系统，用于在k8s上部署应用，也是我们内部在用的一个部署平台，想着通过这个，把一些技术都给用上。没想到没写多久就遇到困难了，在想ceph是如何挂载到k8s上，运维老师又是如何把数据从原先的docker swarm迁移到k8s上。以上种种，在我写代码时暴露出来，因此我花了很久的时间，学习与踩坑，从k8s环境搭建，到ceph集群搭建，再到存储挂载。  </p><p>网上的教程五花八门，有的太老，有的根本用不了，包括ceph-csi驱动官方在readme中也写的不够详细，因此我决定自己写文章。  </p><p>至于为什么是从0.5开始，因为我自认为懂点架构知识，虽然可能不多，但是姑且从0.5开始吧。  </p><p>这个系列会记录我在运维，架构上的一些问题和解决方案，也想持续的把它写下去，我也不知道这次能坚持多久，也许下一份工作开始就被遗忘了，也许是转行的那天，但是此时我是想记录的，那就遵从心意努力前进吧!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;随便聊聊&quot;&gt;&lt;a href=&quot;#随便聊聊&quot; class=&quot;headerlink&quot; title=&quot;随便聊聊&quot;&gt;&lt;/a&gt;随便聊聊&lt;/h1&gt;&lt;p&gt;最近离职了无聊想写一个系统，用于在k8s上部署应用，也是我们内部在用的一个部署平台，想着通过这个，把一些技术都给用上。没想到
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="架构" scheme="https://re0.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="运维" scheme="https://re0.top/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="从0.5开始的运维架构之路" scheme="https://re0.top/tags/%E4%BB%8E0-5%E5%BC%80%E5%A7%8B%E7%9A%84%E8%BF%90%E7%BB%B4%E6%9E%B6%E6%9E%84%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>2024面试复盘2</title>
    <link href="https://re0.top/2024/06/24/2024-06-24-replay/"/>
    <id>https://re0.top/2024/06/24/2024-06-24-replay/</id>
    <published>2024-06-24T15:00:00.000Z</published>
    <updated>2024-06-25T05:21:34.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h1><h2 id="快排原理，时间空间复杂度"><a href="#快排原理，时间空间复杂度" class="headerlink" title="快排原理，时间空间复杂度"></a>快排原理，时间空间复杂度</h2><p>原理  </p><ol><li><p>选择基准元素</p></li><li><p>分区操作（Partition）。通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据要小。这个过程称为分区操作。</p></li><li><p>递归排序。递归地（recursive）把小于基准值元素的子数组和大于基准值元素的子数组排序。</p></li><li><p>合并。通常，这个步骤并不需要实际的合并操作，因为在分解和递归排序阶段已经完成了排序。</p></li></ol><p>  时间复杂度O(nlogn)。空间复杂度O(logn)。<br>  代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">log.info(<span class="string">&quot;开始排从【arr[&#123;&#125;]】到【arr[&#123;&#125;]】数据&quot;</span>, left, right);</span><br><span class="line"><span class="keyword">int</span> pivot = partition(arr, left, right);</span><br><span class="line">log.info(<span class="string">&quot;返回的基准位置是：&#123;&#125;,分区排序后的结果：&#123;&#125;&quot;</span>, pivot, arr);</span><br><span class="line"><span class="comment">// 基准元素一定比左边的数大，所以左边分区最大值是：pivot - 1，分区范围是[left, pivot - 1]</span></span><br><span class="line">quickSort(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 基准元素一定比右边的数小，所以右边分区最小值是：pivot + 1，分区范围是[pivot + 1, right]</span></span><br><span class="line">quickSort(arr, pivot + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义基准元素</span></span><br><span class="line"><span class="keyword">int</span> pivotValue = arr[left];</span><br><span class="line"><span class="comment">// 遍历（条件就是分区左边索引小于右边索引）</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="comment">// 从右边right开始遍历，找到一个数比基准数小</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivotValue) &#123;</span><br><span class="line"><span class="comment">// 未找到，继续往前找</span></span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到了，则把找到小值放到此时左边索引的位置</span></span><br><span class="line"><span class="comment">// 第一次进入时,基准元素已存放到临时值pivotValue了，第一次就相当于放到基准位置了，同时，arr[right]也腾出了一个位置</span></span><br><span class="line">arr[left] = arr[right];</span><br><span class="line"><span class="comment">// 从左边left开始遍历，找到一个数比基准数大</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivotValue) &#123;</span><br><span class="line"><span class="comment">// 未找到，继续往后找</span></span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到了，则把找到大值放到此时右边索引的位置（也就是腾出的位置）</span></span><br><span class="line"><span class="comment">// 同时，arr[left]也腾出了一个位置</span></span><br><span class="line">arr[right] = arr[left];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// left等于right说明遍历结束了，把基准元素插入到腾出的位置，也就是arr[left]或者arr[right]</span></span><br><span class="line">arr[left] = pivotValue;</span><br><span class="line"><span class="comment">// 返回基准元素插入的位置</span></span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mysql-innodb索引的结构？"><a href="#mysql-innodb索引的结构？" class="headerlink" title="mysql innodb索引的结构？"></a>mysql innodb索引的结构？</h2><p>InnoDB使用B+树作为其索引结构的基础。</p><ul><li>聚簇索引<br>InnoDB的主键索引被称为聚簇索引。聚簇索引的特点是表中的数据行按照主键的顺序进行物理存储。这意味着主键查询非常快，因为数据库可以直接定位到数据行。聚簇索引的另一个优点是它可以有效地支持范围查询，因为数据行在磁盘上是连续存储的。  </li><li>二级索引<br>除了聚簇索引外，InnoDB还支持二级索引（也称为非聚簇索引）。二级索引的叶子节点包含相应的主键值，而不是实际的数据行。当通过二级索引查询数据时，InnoDB首先定位到二级索引的叶子节点，获取对应的主键值，然后再通过聚簇索引定位到实际的数据行。因此，相对于聚簇索引，二级索引的查询性能会有所降低。  </li></ul><h2 id="b-和b树的区别？"><a href="#b-和b树的区别？" class="headerlink" title="b+和b树的区别？"></a>b+和b树的区别？</h2><p>B树（B树、BTree、B-Tree都是同一个概念，都称为BTree），B树是一种多路自平衡搜索树，它类似普通的二叉树，但是B树允许每个节点有更多的子节点（二叉树一个节点下最多两个节点，而B树下一个节点可以有超过两个的节点），特点是：</p><ul><li>所有节点中即包含记录的索引key值和这条记录的所有数据，以及指向下一个节点的指针；</li><li>任何一条记录出现且只出现在一个节点中；</li><li>搜索可能在非叶子节点时就结束了（因为节点中包含这条记录的所有数据，查到某条记录可以直接返回）；</li></ul><p>B+树是对B树的升级，非叶子节点只存储索引列和下一个节点的指针（不再存储数据了），叶子节点存储索引列和数据以及下一个节点的指针（叶子节点是相连的），以现实中的树木比喻说明就是，BTree更加繁茂，而B+树相对精简<br>B+树相对于B树：</p><ul><li>B+树非叶子节点只存储索引键和指针，相对B树来讲可以存储更多的索引键，这样的话B+树的深度也会更低，一次性读入内存的索引键也会更多，IO的次数也会变少，查询效率更高</li><li>B+树的所有数据都存储在叶子节点上，如果要取数据的话，那么每次查询IO的次数都是相同的，也就是说查询是稳定的</li><li>B+树叶子节点之间通过双向链表连接，可以很方便的进行范围查询 总结就是B+树比B树查询效率更高更稳定，而且方便范围查询。</li></ul><p>B+树相对于平衡二叉树或红黑树：</p><ul><li>平衡二叉树追求绝对平衡，条件比较苛刻，而红黑树是对平衡二叉树的弱实现，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单，然而不管是平衡二叉树还是红黑树它们的任一节点最多有两个子节点，假设使用平衡二叉树或红黑树作为索引结构，那么一个节点只能存储一个索引键和指针，在数据量非常大的情况下，平衡二叉树或红黑树的深度会变的更深，这就意味着查询需要更多的IO，这显然不能被接受。</li></ul><h2 id="可重复读会什么情况？实现原理"><a href="#可重复读会什么情况？实现原理" class="headerlink" title="可重复读会什么情况？实现原理"></a>可重复读会什么情况？实现原理</h2><p>会有幻读的情况。<br>针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。<br>针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。<br>这两个解决方案是很大程度上解决了幻读现象，但是还是有个别的情况造成的幻读现象是无法解决的。</p><ul><li>对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。</li><li>对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。  </li></ul><h2 id="并发包锁的实现原理，AQS原理，数据结构？"><a href="#并发包锁的实现原理，AQS原理，数据结构？" class="headerlink" title="并发包锁的实现原理，AQS原理，数据结构？"></a>并发包锁的实现原理，AQS原理，数据结构？</h2><p>Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。</p><p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p><p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。<br>这里引用下美团的图片：  </p><p><img src="https://cdn.re0.top/blog/replay/27605d483e8935da683a93be015713f331378.png" alt="img"><br><img src="https://cdn.re0.top/blog/replay/3f1e1a44f5b7d77000ba4f9476189b2e32806.png" alt="img"></p><p>具体可以参考<a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">文章</a>.</p><h2 id="synchronized关键字实现方式？"><a href="#synchronized关键字实现方式？" class="headerlink" title="synchronized关键字实现方式？"></a>synchronized关键字实现方式？</h2><p>Monitorenter和Monitorexit指令，会让对象在执行时，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一：</p><ul><li>monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待</li><li>如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加</li><li>这把锁已经被别的线程获取了，等待锁释放</li></ul><p>JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。<strong>不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销</strong>。</p><p><code>锁粗化(Lock Coarsening)</code>：也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。</p><p><code>锁消除(Lock Elimination)</code>：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本的Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。</p><p><code>轻量级锁(Lightweight Locking)</code>：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。</p><p><code>偏向锁(Biased Locking)</code>：是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。</p><p><code>适应性自旋(Adaptive Spinning)</code>：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。</p><p>锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)</p><table><thead><tr><th><strong>锁</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>适用于只有一个线程访问同步块的场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了响应速度</td><td>如线程始终得不到锁竞争的线程，使用自旋会消耗CPU性能</td><td>追求响应时间，同步块执行速度非常快</td></tr><tr><td>重量级锁</td><td>线程竞争不适用自旋，不会消耗CPU</td><td>线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td><td>追求吞吐量，同步块执行速度较长</td></tr></tbody></table><h2 id="分布式锁的实现原理？setnx的缺点？watchdog的实现机制？"><a href="#分布式锁的实现原理？setnx的缺点？watchdog的实现机制？" class="headerlink" title="分布式锁的实现原理？setnx的缺点？watchdog的实现机制？"></a>分布式锁的实现原理？setnx的缺点？watchdog的实现机制？</h2><p>redis分布式锁主要依靠setnx实现。</p><p>redis在 2.6.12 版本开始，为 SET 命令增加一系列选项.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value[EX seconds][PX milliseconds][NX|XX]</span><br></pre></td></tr></table></figure><ul><li>EX seconds: 设定过期时间，单位为秒</li><li>PX milliseconds: 设定过期时间，单位为毫秒</li><li>NX: 仅当key不存在时设置值</li><li>XX: 仅当key存在时设置值</li></ul><p>缺点  </p><ul><li><strong>超时时间不好设置</strong>。如果锁的超时时间设置过长，会影响性能，如果设置的超时时间过短会保护不到共享资源。</li><li><strong>redis 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性</strong></li></ul><p>watchdog源码解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当leaseTime = -1 时 启动 watch dog机制</span></span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                            commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                            TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    <span class="comment">//执行完lua脚本后的回调</span></span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// watch dog </span></span><br><span class="line">            scheduleExpirationRenewal(threadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleExpirationRenewal</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    ExpirationEntry entry = <span class="keyword">new</span> ExpirationEntry();</span><br><span class="line">    <span class="comment">//将线程放入缓存中</span></span><br><span class="line">    ExpirationEntry oldEntry = EXPIRATION_RENEWAL_MAP.putIfAbsent(getEntryName(), entry);</span><br><span class="line">    <span class="comment">//第二次获得锁后 不会进行延期操作</span></span><br><span class="line">    <span class="keyword">if</span> (oldEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldEntry.addThreadId(threadId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        entry.addThreadId(threadId);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一次获得锁 延期操作</span></span><br><span class="line">        renewExpiration();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入 renewExpiration()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">renewExpiration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="comment">//如果缓存不存在，那不再锁续期</span></span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Long threadId = ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//执行lua 进行续期</span></span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">//延期成功，继续循环操作</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每隔internalLockLeaseTime/3=10秒检查一次</span></span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lua脚本 执行包装好的lua脚本进行key续期</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">renewExpirationAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 0;&quot;</span>,</span><br><span class="line">            Collections.singletonList(getName()),</span><br><span class="line">            internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li> watch dog 在当前节点存活时每10s给分布式锁的key续期 30s；</li><li> watch dog 机制启动，且代码中没有释放锁操作时，watch dog 会不断的给锁续期；</li><li> 从可2得出，如果程序释放锁操作时因为异常没有被执行，那么锁无法被释放，所以释放锁操作一定要放到 finally {} 中；</li></ol><h1 id="随便聊聊"><a href="#随便聊聊" class="headerlink" title="随便聊聊"></a>随便聊聊</h1><p>不管是大小公司，都喜欢深挖项目中的一些细节啊改进啊之类的，聊着聊着我就对内部的项目产生了深深的怀疑，草台班子竟是我自己。   </p><p>其次都热衷于去讨论底层实现，对业务其实并不是特别关心。     </p><p>搞得我心态有点炸裂，但还是该学习就学习吧。慢慢来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;复盘&quot;&gt;&lt;a href=&quot;#复盘&quot; class=&quot;headerlink&quot; title=&quot;复盘&quot;&gt;&lt;/a&gt;复盘&lt;/h1&gt;&lt;h2 id=&quot;快排原理，时间空间复杂度&quot;&gt;&lt;a href=&quot;#快排原理，时间空间复杂度&quot; class=&quot;headerlink&quot; title=&quot;快
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="随想" scheme="https://re0.top/tags/%E9%9A%8F%E6%83%B3/"/>
    
      <category term="架构" scheme="https://re0.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2024面试复盘1</title>
    <link href="https://re0.top/2024/06/23/2024-06-23-replay/"/>
    <id>https://re0.top/2024/06/23/2024-06-23-replay/</id>
    <published>2024-06-23T15:00:00.000Z</published>
    <updated>2024-06-23T15:17:37.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天又再一次面试了字节，在复习准备不足的情况下，我还是接受了面试邀请。<br>很遗憾又在二面挂了，三年前我也曾经面过字节的校园招聘，那时候也是在二面挂了。  </p><h1 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h1><h2 id="缓存穿透-缓存击穿"><a href="#缓存穿透-缓存击穿" class="headerlink" title="缓存穿透/缓存击穿"></a>缓存穿透/缓存击穿</h2><p>这两个概念面试的时候搞混了，还是没复习好，说实话接触的系统没能有这种场景。<br>缓存穿透指的是有大量请求获取<strong>既不在缓存中也不在数据库中的数据</strong>，会导致数据库压力增大，这种情况一般是黑客在攻击或者数据被误删除了，相应的解决方案有限制非法请求，缓存控制或者默认值，使用布隆过滤器判断数据是否存在。<br>缓存击穿指的是<strong>一些热点数据的过期，很容易导致大量请求到db上。</strong>解决方案一是加互斥锁或者分布式锁去更新缓存，没能获取的锁的返回空置或默认值，二是不给热点数据设置过期时间，由后台去统一更新缓存。  </p><h2 id="redis大key的解决方案。"><a href="#redis大key的解决方案。" class="headerlink" title="redis大key的解决方案。"></a>redis大key的解决方案。</h2><p>大key指的是value大小超过一定阈值的key。这个阈值根据系统可能指标是不同的。大key可能导致的问题可能有一是数据倾斜，如在redis集群里，大key所在的节点上内存占用率过高。二是服务器资源耗费比较严重，包括网络带宽CPU和内存。三就是redis是单线程的会导致阻塞。<br>而解决方案有一是规范使用，从业务上断绝大key，如拆分存储，考虑使用数据库等。二是监控报警和强制删除。三是对大key进行处理，如果value是string，那么可以使用压缩算法进行压缩，如果还是比较大，拆分数据，使用mget获取数据；如果value是list/set等集合，那么可以根据规则进行分片，即拆分key，不同元素计算hash后分到不同的key中，比如productList1，productList2等。</p><h2 id="rabbitmq如何保证消息的可靠性，不丢失。"><a href="#rabbitmq如何保证消息的可靠性，不丢失。" class="headerlink" title="rabbitmq如何保证消息的可靠性，不丢失。"></a>rabbitmq如何保证消息的可靠性，不丢失。</h2><p>首先明确消息的传递阶段有哪些。一是从生产者到rabbmitmq。二是从exchange到queue。三是未持久化消息导致意外丢失。四是消费者消费异常。下面一个个来分析。  </p><ol><li>生产者到mq。rabbitmq提供了两种机制去保证生产者的消息到达了服务。一是使用事务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RabbitMQConfig &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 配置事务管理器</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RabbitTransactionManager transactionManager(ConnectionFactory connectionFactory) &#123;</span><br><span class="line">        return new RabbitTransactionManager(connectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class RabbitMQServiceImpl &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    @Transactional // 事务注解</span><br><span class="line">    public void sendMessage() &#123;</span><br><span class="line">        // 开启事务</span><br><span class="line">        rabbitTemplate.setChannelTransacted(true);</span><br><span class="line">        // 发送消息</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.Direct_Exchange, routingKey, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用事务去确认发送消息成功是一个同步操作，会阻塞等待mq应答。<br>第二种方案就是使用发送方确认机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    publisher-confirm-type: correlated  # 开启发送方确认机制</span><br><span class="line"></span><br><span class="line">none：表示禁用发送方确认机制</span><br><span class="line">correlated：表示开启发送方确认机制</span><br><span class="line">simple：表示开启发送方确认机制，并支持 waitForConfirms() 和 waitForConfirmsOrDie() 的调用。</span><br></pre></td></tr></table></figure><p>simple是串行的应答，与事务机制一样性能较差。这里主要讨论correlated。可以通过setConfirmCallback去实现异步confirm 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class RabbitMQServiceImpl &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sendMessage() &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.Direct_Exchange, routingKey, message);</span><br><span class="line">        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">            /**</span><br><span class="line">             * MQ确认回调方法</span><br><span class="line">             * @param correlationData 消息的唯一标识</span><br><span class="line">             * @param ack 消息是否成功收到</span><br><span class="line">             * @param cause 失败原因</span><br><span class="line">             */</span><br><span class="line">            @Override</span><br><span class="line">            public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123;</span><br><span class="line">                // 记录日志</span><br><span class="line">                log.info(&quot;ConfirmCallback...correlationData[&quot;+correlationData+&quot;]==&gt;ack:[&quot;+ack+&quot;]==&gt;cause:[&quot;+cause+&quot;]&quot;);</span><br><span class="line">                if (!ack) &#123;</span><br><span class="line">                    // 出错处理</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>exchange到queue投递失败。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    publisher-confirm-type: correlated  # 开启发送方确认机制</span><br><span class="line">    publisher-returns: true   # 开启消息返回</span><br><span class="line">    template:</span><br><span class="line">      mandatory: true     # 消息投递失败返回客户端</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mandatory 分为 true 失败后返回客户端 和 false 失败后自动删除两种策略。通过调用 setReturnCallback() 方法设置路由失败后的回调方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class RabbitMQServiceImpl &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sendMessage() &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.Direct_Exchange, routingKey, message);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">  </span><br><span class="line">            @Override</span><br><span class="line">            public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        // 设置路由失败回调方法</span><br><span class="line">        rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() &#123;</span><br><span class="line">            /**</span><br><span class="line">             * MQ没有将消息投递给指定的队列回调方法</span><br><span class="line">             * @param message 投递失败的消息详细信息</span><br><span class="line">             * @param replyCode 回复的状态码</span><br><span class="line">             * @param replyText 回复的文本内容</span><br><span class="line">             * @param exchange 消息发给哪个交换机</span><br><span class="line">             * @param routingKey 消息用哪个路邮键</span><br><span class="line">             */</span><br><span class="line">            @Override</span><br><span class="line">            public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) &#123;</span><br><span class="line">                // 记录日志</span><br><span class="line">                log.info(&quot;Fail Message[&quot;+message+&quot;]==&gt;replyCode[&quot;+replyCode+&quot;]&quot; +&quot;==&gt;replyText[&quot;+replyText+&quot;]==&gt;exchange[&quot;+exchange+&quot;]==&gt;routingKey[&quot;+routingKey+&quot;]&quot;);</span><br><span class="line">                // 出错处理</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>持久化消息。rabbitmq支持将消息持久化保证服务异常后可恢复。在定义queue和exchange时就可以指定队列和交换机的持久化参数。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Queue queue() &#123;</span><br><span class="line">    // 四个参数：name（队列名）、durable（持久化）、 exclusive（独占）、autoDelete（自动删除）</span><br><span class="line">    return new Queue(MESSAGE_QUEUE, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public DirectExchange exchange() &#123;</span><br><span class="line">    // 四个参数：name（交换机名）、durable（持久化）、autoDelete（自动删除）、arguments（额外参数）</span><br><span class="line">    return new DirectExchange(Direct_Exchange, true, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于消息持久化，可以在发送时指定消息类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Message message = MessageBuilder.withBody(&quot;test&quot;.getBytes(StandardCharsets.UTF_8)).setDeliveryMode(MessageDeliveryMode.PERSISTENT).build();</span><br><span class="line">rabbitTemplate.convertAndSend(RabbitMQConfig.Direct_Exchange, routingKey, message);</span><br></pre></td></tr></table></figure><p>因此如果需要持久化，必须交换机，队列，消息都进行持久化，否则该丢失的还是会丢失。</p><ol start="4"><li>保证消费者消费的消息不丢失。rabbitmq也提供了消费者确认机制感知消费者是否消费成功。消费成功后才删除消息，否则会继续投递。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    listener:</span><br><span class="line">      simple:</span><br><span class="line">        acknowledge-mode: manual</span><br></pre></td></tr></table></figure><p>默认情况下acknowledge-mode的参数是auto，即自动确认，一般情况下使用@RabbitListener注解的方法没有抛出异常，则会自动进行确认。可以结合springboot中提供的retry来实现消息重试策略。<br>注意这里重试并不是mq重新发送了消息，仅仅是消费者内部进行的重试，换句话说就是重试跟mq没有任何关系；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    listener:</span><br><span class="line">      simple:</span><br><span class="line">        acknowledge-mode: auto  # 开启自动确认消费机制</span><br><span class="line">        retry:</span><br><span class="line">          enabled: true # 开启消费者失败重试</span><br><span class="line">          initial-interval: 5000ms # 初始失败等待时长为5秒</span><br><span class="line">          multiplier: 1  # 失败的等待时长倍数（下次等待时长 = multiplier * 上次等待时间）</span><br><span class="line">          max-attempts: 3 # 最大重试次数</span><br><span class="line">          stateless: true # true无状态；false有状态（如果业务中包含事务，这里改为false）</span><br></pre></td></tr></table></figure><p>这里重试次数达到上限后，会被自动ack。如果存在RepublishMessageRecoverer那么会被投递到指定交换机。<br>接着来讲讲手动ack。其实就是做basicAck和basicNack，其中basicNack是可以指定是否返回队列的，需要注意的是，如果requeue了，那么很大概率会出现消息重复投递又再次入队，会影响其他正常的消息消费。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = RabbitMQConfig.MESSAGE_QUEUE)</span><br><span class="line">public void onMessage(Message message, Channel channel) &#123;</span><br><span class="line">    long deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">    // 解析消息</span><br><span class="line">    byte[] body = message.getBody();</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        // 业务处理</span><br><span class="line"></span><br><span class="line">        // 手动确认</span><br><span class="line">        channel.basicAck(deliveryTag, false);</span><br><span class="line">    &#125;catch (Exception e) &#123;</span><br><span class="line">        // 记录日志</span><br><span class="line">        log.info(&quot;出现异常：&#123;&#125;&quot;, e.getMessage());</span><br><span class="line">        try &#123;</span><br><span class="line">            channel.basicNack(deliveryTag, false, false);</span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line">            log.info(&quot;nack消息异常&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即便有了以上方案，其实也无法保证消息100%不丢失，最好的方案还是消息落库，再加消息补偿的机制去保证消息的100%正常处理。</p><h2 id="rabbitmq的事务消息。"><a href="#rabbitmq的事务消息。" class="headerlink" title="rabbitmq的事务消息。"></a>rabbitmq的事务消息。</h2><p>rabbitmq的事务我没有接触过，所以直接就回答不清楚，仔细一查结果还真有。<br>它的事务在上一个问题中也提到过，主要是用在生产者消息投递的确认上，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    channel.txSelect();</span><br><span class="line">    channel.basicPublish(exchange, routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());</span><br><span class="line">    int result = 1 / 0;</span><br><span class="line">    channel.txCommit();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    channel.txRollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码和3中的rabbitTemplate.setChannelTransacted(true)是一样的，aop会自动去txSelect和txCommit。<br>由此我们可以知道，rabbitmq的事务消息其实是作为生产者发送确认来使用的，它的作用在于可以先往mq中投递消息，再根据本地事务的结果去决定mq消息是否回滚，同时也保证了生产者投递消息的可靠性。但其实相较于rocketmq它少了一个消息回查的机制。可以参考<a href="https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage/">rocketmq文档</a>。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>系统复杂度主要体现在哪些地方。<br>对现有系统有哪些优化空间。<br>这两个问题我会后面写文章单独去聊聊简历上的项目存在什么问题。</p><h1 id="随便聊聊"><a href="#随便聊聊" class="headerlink" title="随便聊聊"></a>随便聊聊</h1><p>我其实很不解，一度陷入自我怀疑，难道我三年来真的没长进吗？不，我想不是的。<br>作为一名测试开发，对系统的理解很难同大厂的研发去交流，也许测开真的是测试领域？！我对系统的架构，使用，未来展望上不能说没有，只能说少之又少！<br>我自认为良好的一个系统，在面试官眼中可能漏洞百出。<br>我也许对开发的认知有些偏离了，在海康的这三年，磨灭了自己些许的钻研心，每天就重复性工作，排查问题，技术支持。<br>反思了一下，已经很久了，我对技术的钻研只停留在使用，而且是简单使用。并且与业务结合已经是去年的事了。<br>但幸运的是，我已经离开了，去尝试不敢打破的规则和生活。尽管可能非常难，实际上确实很难，但总体上我还是觉得是庆幸的。<br>回到刚开始的问题，我这几年真的没长进吗？我想不是的，我了解一个系统从设计到开发再到运维的全过程，尽管这些长进可能相对于开发岗是微小的，或者说相较于大厂的应用只是个弟弟。  但我愿意相信这些知识有一天能起到真正的作用。<br>我其实想过自己是否真正适合这一行，我自认为比上不足比下有余，当然同事朋友老是捧杀我应该去更高的平台拿更高的工资，但我想去冲但是能力和胆量又不够。<br>我不知道我除了代码还能做些什么，迷茫啊，但是人生就是这样，人一辈子都是在迷茫中度过的。<br>今天不如意没关系，明天太阳也会照常升起。人生苦短，慢慢加油吧。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天又再一次面试了字节，在复习准备不足的情况下，我还是接受了面试邀请。&lt;br&gt;很遗憾又在二面挂了，三年前我也曾经面过字节的校园招聘，那时候也
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="随想" scheme="https://re0.top/tags/%E9%9A%8F%E6%83%B3/"/>
    
      <category term="架构" scheme="https://re0.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>写于6月离职之后</title>
    <link href="https://re0.top/2024/06/11/2024-resign/"/>
    <id>https://re0.top/2024/06/11/2024-resign/</id>
    <published>2024-06-11T12:00:00.000Z</published>
    <updated>2024-06-11T13:43:41.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2024年已经快过去一半了，4月下旬的时候我提出了离职，尽管我还不知道未来的路如何，不管休息也好找下一份工作也罢，我决定离开康子。<br>6月4日特殊的日子，我办理了离职手续，经历了人生中的第一次离职。</p><h1 id="随便聊聊"><a href="#随便聊聊" class="headerlink" title="随便聊聊"></a>随便聊聊</h1><h2 id="为什么离开"><a href="#为什么离开" class="headerlink" title="为什么离开"></a>为什么离开</h2><p>在23年的总结中我写到，目前的自己有点迷茫，不知道之后的方向在哪，我其实休息的时候一直在思考我目前的境地。<br>诚然在康子，我是组内的核心，是大家口中的”大佬”，但说实话我感觉自己远远不够，简单来说是系统设计层面。由于内部系统没有太多的技术可言，唯一能做的就是内部业务如何与技术相结合，说实话，这一年半以来我主导了很多的业务与方案，确实结合了不少技术，但是终究也只是自娱自乐而已，开发模式不完善以至于能学习的对象也少之又少。<br>其次就是内部角色定位模糊，开发模式与周期不敢苟同。我一个人既要做产品负责需求的整理，分析，又要做开发人员出方案设计与开发，又要与前端同学沟通与协调，临近发布日我还得自测系统。说实话我不认为这样的一个开发模式是合理的，我一个人要做不同角色的活，关键是迭代周期还是短短的两周！！！最近半年更是一周一个迭代发布，每次周四发布日我都得干到凌晨。就算不是发布日我也得每天加班加点完成做不完的任务。真的累了。<br>最后是作为技术负责人话语权依然不足。离职前我的定位是某些产品的负责人，兼组内技术顾问的角色。作为产品负责人，我对自己产品做哪些东西其实没有特别大的话语权，一旦领导认为这个东西就得做，那不管我从业务角度还是技术角度去阐述这个需求实现的难度也好，合理性也罢，这个需求都是一定要做的，而且都是紧急的。其实我没太明白，作为一个持续迭代的产品，用户的每一个需求都是紧急的吗？当我去追问用户后，其实往往并不是那么紧急，因为本来就是新的东西。<br>那作为技术顾问呢，我经常看到组内有非常多不合理的需求在季度前的会上讨论，也是一样，这些需求负责人明白是不合理的，从我一个外部的技术角度去看这个需求的时候，也是不合理的，但是呢，就是要做，我没法将这些需求在前期就过滤掉，往往是在完成中或者完成后发现问题后，才意识到不对劲，但他也不会去承认不合理，只是硬着头皮做下去吧。  </p><p>我反思了一下，既然我无法改变目前的现状，也没法提升自身，我决定给自己放个假，沉淀下技术，思考下未来。<br>尽管很多人都说不要轻易裸辞，环境不好之类的，但我自认为还是有点技术的，混口饭吃其实问题不太大。  </p><h2 id="这几年经历了什么"><a href="#这几年经历了什么" class="headerlink" title="这几年经历了什么"></a>这几年经历了什么</h2><p>有一说一，康子作为我毕业后的第一份工作，确实给了我一个相对比较大的发挥平台，刚开始没有合并组织架构前，作为新人我也可以直接参与到新功能的讨论与开发，甚至可以能见证一个产品从零到一，确实是有成就感。<br>度过了新人阶段后，由于转正考核优秀，我开始作为核心开发成员参与到一些产品迭代中，度过了一段也还算有意思的阶段，负责完成方案设计与代码任务，强度不高。<br>又过了一年左右，由于绩效考核较好，转向产品负责人，我开始接手一些系统，也负责搭建一些底层基础服务。<br>其中经历了组内服务部署从docker compose转向k8s的过程，对架构和运维产生了莫大兴趣，从<strong>服务架构选型</strong>到<strong>服务部署</strong>再到<strong>服务治理</strong>到<strong>线上问题排查</strong>，都觉得十分有趣。<br>领导也比较赏识，连续两年都给了我良好绩效，目前的职级相比同一年来的一些小伙伴还高一点。但是有一说一，尽管职级高了但是工资还是比较低的。</p><h2 id="之后做啥"><a href="#之后做啥" class="headerlink" title="之后做啥"></a>之后做啥</h2><p>目前是离职一周了，这一周我看了身上的小毛病，花去了1700块钱，看病真贵啊。怪不得有的人说赚的钱都拿来看病了。<br>之后可能会再稍微休息一小段时间，然后开始找下一份工作，可能确实会不太好找，不过目前我压力还可以，足够支撑我慢慢来，实在不行那就回老家吧。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;2024年已经快过去一半了，4月下旬的时候我提出了离职，尽管我还不知道未来的路如何，不管休息也好找下一份工作也罢，我决定离开康子。&lt;br&gt;6
      
    
    </summary>
    
    
      <category term="随想" scheme="https://re0.top/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2023年度总结</title>
    <link href="https://re0.top/2024/01/01/2023-summary/"/>
    <id>https://re0.top/2024/01/01/2023-summary/</id>
    <published>2024-01-01T08:00:00.000Z</published>
    <updated>2024-06-11T12:56:20.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2023年又过去了。时间飞快，不知不觉中工作已经两年多，忘记去年有没有写总结了，过去的文件都放在原来的笔记本里不想去翻了。那么就来总结下2023年我的经历吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>说实话，平常没有记录的习惯，导致今年发生了什么完全想不起来，那么我就按照季度来总结吧。</p><h2 id="一季度"><a href="#一季度" class="headerlink" title="一季度"></a>一季度</h2><p>2023年一季度就是春节吧，首先是去年工作表现还算可以，年终多发了一点，但是工资还是过于少了。春节那次赶车是我最赶的一次，检票时距离发车只有4分钟，从下地铁就是一路狂奔，印象特别深刻。<br>然后就是网易暴雪分手，在关服前特意去炉石里看了看，算了算也有三年没玩了。<br>2月份的时候崩三第一部主线更新，本来我应该在那时候写下我这几年的感慨，但是真到的那刻我却难以表述我心中的感情。<br>作为陪伴我7年时光的游戏，在那一刻迎来了结束，紧接着毕业旅行的动画短片，我哭了，不仅是对主角琪亚娜经历点点滴滴的感动，也是对我见证这段故事结束时的不舍。但未来总要继续，我们应该笑着走向未来。终点亦是起点，太阳依旧会升起，而每个人依旧要前进。这是这个故事带给我的力量，也是我喜欢这个故事的理由。人生能有几个七年，随着我的年度歌曲Da Capo的落幕，我的七年青春就此结束，我从故事的开始见证到最后，从学生时代的美好到社会人士的残酷。所以这个故事就让它留在过去吧，但它的美好依旧指引着我前进。</p><h2 id="二季度"><a href="#二季度" class="headerlink" title="二季度"></a>二季度</h2><p>4月份开头的时候去看了新海诚的铃芽之旅，个人觉得一般，新海诚的电影从你的名字过后感觉就是为了迎合市场做的，挺难评价的。<br>4月26日米忽悠的新游戏崩铁上线，作为内测玩家我也是马上就登录了，但相较于内测时我填写问卷里所选的上线后可能不会去尝试，结果还是真香了，星铁作为一个休闲游戏爆杀原神，合理利用碎片化时间完成游玩，福利还特别好，不愧与年度最佳移动端游戏！尤其是boss战配合野火直接点燃游戏。<br>5月，加班，二阳，总得来说是很难受的一个月。月末去看了刀剑剧场版，我的评价是非常不错。<br>6月份，天气逐渐热起来，我的小米10s后盖开裂了，电池鼓包，大概率是我经常使用无线充电的原因，电池温度经常过高。换了块电池花了100来块。<br>二季度加班也比较多，但闲暇之余我还是学习了rust语言，做了一些笔记。相较于cpp，我更看好rust的前景，可惜日常中使用它的场景太少，没能有效练习，导致我现在回想起来只记得基本语法了。其次我在工作时开始使用不常使用的架构与中间件实现一些功能，例如spring cloud nacos，rabbitmq，redis集群，es等等。曾经这些其实都是我的设想或者只是旧服务的维护。当我要把这些用在生产环境时总是一个又一个问题，从环境搭建到服务上的使用都有，但最终从搭建部署到使用，自己总结了一些经验，这也许是今年工作相关内容最大的收获了。  </p><h2 id="三季度"><a href="#三季度" class="headerlink" title="三季度"></a>三季度</h2><p>7月份，收到崩三的邀请，去线下参加了林海琦律音乐会，正好地点也在杭州，现场氛围很好，有很多coser，场景布置也非常好，最重要的米忽悠还白送了我一袋子周边，哭死，不过想起来我给崩三充值的金额，想想好像也没啥。现场音乐会比在家看直播好非常多，得益于电影院的音效，听起来确实很好。可惜的是coser就坐在我旁边，但是我却不敢找她们拍照，哈哈。<br>9月4日是我的生日，我本想在这一天请个假休息一下，但好像那周有什么事，我最后没有请假，本想在那天写个人总结，但也搁置了。<br>整个三季度也是比较压抑的，一是随着同事的离职，我也在反思自己到底为啥要待在这里，自己也一直在考虑是否应该换个环境。二是股市动荡比较大，虽然我投资比较少，而且我也不是那种想短期看到收益的人，但看着账户里的资金越来越少其实自己也是蛮无奈的，大A，永远的骗局，不要对股市抱有不切实际的幻想！<br>三季度也收到了多个预定的手办，非常nice，有时候看着这些手办，虽然她们放着确实吃灰，但是回到家看到她们心情确实会变好一些。  </p><h2 id="四季度"><a href="#四季度" class="headerlink" title="四季度"></a>四季度</h2><p>10月份，国庆假期，大概率是宅了一个假期，既有打游戏也有学习，稍微看了岗位详情，但简历却无从下手。10月番剧也开始追起来了，现在想想，当初对16bit给予过大的期待了。其他一些番剧，比如芙莉莲，药屋少女等一些还是非常不错的。<br>11月份，换了小米14pro，玩游戏比以前流畅了，这次直接干到16+1T了，再也不用关心存储空间不够用了。这个月团建去爬山。总体来说还是非常不错的，除了某个领导不断指责导游之外，体验还是很好的，虽然爬山很累，但是山上的风景非常nice。还用14pro拍了非常多照片，不得不说新手机的拍照真的好。<br>11月原神新主线更新，这次的主线剧情应该是我觉得最好的一章，配乐也是巅峰水准，感觉一年到头一直来将米家相关的东西。<br>11-12月就是满无休止的加班加班加班，说实话我受够了这样的工作，明明工资没多少却不断的加班不断的催促不断的内卷，四季度又有两位同事离职了，说实话我挺羡慕他们，考虑了年底离职的风险，能去更好的地方，拿更多的工资。听隔壁组说，两千份简历招了6个人，结果来了2个，还都是校招进来的，由此说明我们岗位工资是真的太低太低了。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>今年，在对工作有用的学习其实不多，主要是在一些架构的设计，运维，学习了一些k8s的东西，但没有特别深入。有一说一目前的岗位对于我能力的提升已经到了瓶颈。说实话我对自己挺迷茫的，迷茫自己的定位，曾经我希望慢慢转型成架构师或者产品经理，但当我尝试去整理需求时我发现我不擅长这个，或许产品这个岗位不适合我，我只想钻研技术，但会不会有一天我也会感觉到厌倦呢？<br>随着工作越来越忙，我在生活中也逐渐变懒，回家只想打游戏休息，虽然偶尔刷视频看见感兴趣的工作相关的也会看，但学习算是比较搁置的，都是碎片化学习。曾经偶尔会写文章，现在都是年更了。我有时候也会反思自己，但总是以工作太累的理由推脱，我想我不能再这样下去了，虽然同事大家都说我很厉害，但我也清楚自己的不足。新的一年希望自己可以再加把劲，去个新环境再提升自己。</p><p>2023年12月31日22:19。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;2023年又过去了。时间飞快，不知不觉中工作已经两年多，忘记去年有没有写总结了，过去的文件都放在原来的笔记本里不想去翻了。那么就来总结下20
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="随想" scheme="https://re0.top/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2022年度总结</title>
    <link href="https://re0.top/2022/12/31/2022-2023/"/>
    <id>https://re0.top/2022/12/31/2022-2023/</id>
    <published>2022-12-31T08:00:00.000Z</published>
    <updated>2022-12-31T08:28:23.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><p>又是半年过去没写文章的日子，时间真的挺快的，转眼又到年末了。今天是2022年的最后一天，在日本这个日子称作大晦日，主要是做大扫除。昨天安排了一下今天的日程，主要是打扫卫生与写年度总结。今天中午起床，吃了点面休息了一会便开始打扫卫生。<br>没想到在12月份的最后几个星期阳了，好在现在已经恢复了七七八八，又可以快乐跨年了。今天把床上用品都拆下来洗了一下，房间打扫了一下，喷了喷酒精消毒。整理完后打开半年不见的笔记本开始码字。  </p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>今年又是平淡的一年，这一年算是见证了历史。长跑三年的疫情终于落下了帷幕。有网友调侃2022年的总价就是1-11月做核酸，12月阳了。哈哈哈，我觉得非常准确，因为我就是这样。<br>杭州，算是一个有温度的城市，核酸基本上是3天一检测，一周2.5次，频率算中规中矩吧。好在这个阶段已经结束了，剩下的就只能靠自己了。希望新的一年大家都能平平安安不生病吧。<br>今年又是单身的一年，哈哈，我其实很少提这件事，但同事总是问我为什么没有女朋友，家里人也一直在催我。仔细想想，2023年我竟然25岁了，时光是真的快啊。但是我没想法，主要还是因为自己一个人真的挺舒服的，工作回家，打打游戏，周末自己一个选择睡觉打游戏，或者出去和朋友聚餐，挺自由的。总之我不太愿意另一个人来打搅我现在的生活。<br>今年因为疫情，大部分休息时间我都宅在家里，和朋友聚餐也少了（没疫情说不定也是宅家）。大部分时间都在看视频打游戏看书。说到看书，今年看的书挺少，前段时间买了两本哲学书，结果到货的时候阳了就没心情看，结果到现在还没看。<br>今年，我的亲姐姐终于结婚了，让我挺感慨的。没想到几年前还在说她为啥不谈不结婚，现在竟然遇到了人生的另一半并且决定结婚。正好那段时间疫情影响较小，顺利把婚礼办下来了。她总说没遇到合适的人，如今终于遇到了。我问她结婚是什么感觉，她说结婚其实和平常并没有什么区别。嘛，我是不理解的。也在这祝福她吧。  </p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>今年算是我参加工作的第二个年头。不知不觉我从毕业进入这个公司以来，到现在已经在这个公司待了一年半了。去年主要做了自动化测试工具。今年一整年都围绕这个工具进行展开，包括4月份的时候做了全平台的录制功能，重构了框架一些代码。通过参加今年的一些技术大会，我意识到目前我们的东西，在业界都是前沿，这让我挺意外的。<br>其次是接手了类似云真机平台，并对接了持续集成，打通了设备，测试流程，测试执行的一整条链路。<br>最后下半年主要做了兼容性测试与其他系统的对接。所谓的兼容性测试，目前就是有规律的selenium的遍历，做了两套流程之后我个人有点不想写了。感觉很繁琐，需要根据不同页面去适配。其次是统一平台，对接了组内的一些系统，可以从平台体验其他系统。有一说一，对接其他平台算是后端的噩梦，各个系统的字段都不一样，需要充分了解各个系统，并将各个系统逻辑抽离公共与独有部分，对整个系统字段设计考验还是非常大的。最终我设计并重构了三版，才让目前的逻辑更加清楚一些。<br>但问题依旧存在，为了做数据隔离，不同类型的系统我采取了分表的操作。这一分，后续要统合数据时，就必须根据类型来判断。现在也不知道是好是坏，只能等时间去验证了。  </p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>今年在工作之余写代码又少了，去年还会偶尔写写，今年就没怎么写了。11月份的时候心血来潮，刷了刷LeetCode，刷了半个月每天一到两题，后面就刷不动了，有工作原因太忙，也有自己下班只想休息的原因。技术类书籍今年还是看了一些的，spring源码解析，golang圣经，当然小说也看了不少，东野圭吾的小说，其他轻小说等等。  </p><h1 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h1><p>听说隔壁阿里又裁了不少人，今年也是困难的一年啊，各行各业都在裁人，我也挺迷茫的。我不知道23年要做些什么改变现状，待在目前公司算是一种选择，但是感觉学习进展不多，一直在用原来的东西，新的东西也有但总感觉不是很多。但是离开我又不知道做什么，大概率23年又是迷茫一整年。<br>最后，希望2023年自己能多看点书，在工作之余多写点代码，多看看其他项目的源码，多学习。也希望自己，家人，朋友在新的一年健健康康，工作顺利。<br>让我们在下一篇文章再见！新年快乐！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;杂谈&quot;&gt;&lt;a href=&quot;#杂谈&quot; class=&quot;headerlink&quot; title=&quot;杂谈&quot;&gt;&lt;/a&gt;杂谈&lt;/h1&gt;&lt;p&gt;又是半年过去没写文章的日子，时间真的挺快的，转眼又到年末了。今天是2022年的最后一天，在日本这个日子称作大晦日，主要是做大扫除。昨天安排了
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="随想" scheme="https://re0.top/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>devtools协议分析与自动化录制实现</title>
    <link href="https://re0.top/2022/04/08/devtools/"/>
    <id>https://re0.top/2022/04/08/devtools/</id>
    <published>2022-04-08T10:00:00.000Z</published>
    <updated>2022-04-08T14:12:20.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近有个需求是做web自动化脚本录制，简单来说就是点击页面上的一个元素，就能把对应节点的xpath和自动化语法添加到脚本中。在airtest中，已经实现了这个功能，这里不再演示，通过实际使用，我认为这一技术实现的关键在于devtools，即通过与浏览器devtools的交互，实现当前节点的选取与脚本录制。<br>目前网上能搜索到的文章有限，本文将详细描述与自动化相关的devtools协议的研究与demo实现。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>首先是去寻找下devtools的<a href="https://chromedevtools.github.io/devtools-protocol/">文档</a>。CDP协议，全程Chrome DevTools Protocol，是用来检测、检查、调试和分析 Chromium、Chrome 和其他基于 Blink 的浏览器。通过开启调试端口，就能与devtools进行通信，从而实现事件与监听。  </p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先使用<code>chrome.exe --remote-debugging-port=9222</code>开启chrome的远程调试端口。也可以加上<code>--headless</code>启用无头浏览器。<br>当启动完成后，访问<code>http://localhost:9222/json</code>即可获取到可交互的devtools地址。<strong>devtools采用websocket协议进行通信</strong>，通过与webSocketDebuggerUrl进行websocket连接即可与devtools进行通信。<br>到这，准备工作已经完成，现在需要分析需要的devtools协议。</p><h2 id="使用原有工具观察协议"><a href="#使用原有工具观察协议" class="headerlink" title="使用原有工具观察协议"></a>使用原有工具观察协议</h2><p>相信各位都使用过devtools的inspect模式，这个模式能高亮选中的元素，并且当点击这个元素后，elements标签里会跳到对应节点的html代码处。<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/devtools/1.png" alt="1.png"><br>要观察devtools协议传输了什么，可以通过打开devtools前端的协议观察器。在devtools的试验设置里可以打开。打开后，在更多里打开协议监听器。<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/devtools/2.png" alt="2.png"><br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/devtools/3.png" alt="3.png"><br>点击inspect，选中页面上的元素，即可出现相关的协议请求，包括请求方法，请求参数，还有响应。  </p><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>当然，知道了通信具体参数并不代表可以直接发送数据了，我们还需了解交互的格式，在官方文档中，我们找到了一份<a href="https://github.com/aslushnikov/getting-started-with-cdp/blob/master/README.md">getting-start</a>，这份文档用js写了份示例，根据示例我们可以清楚看到websocket交互的请求体。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;params&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中id作为请求的唯一标识，用于让请求方标识返回的内容是对应哪个请求的，当devtools返回时，会将此id返回，因此当需要当出现多个请求同时发出时，需要确保id唯一。<br>method字段对应响应的方法，而params字段则是方法对应的参数。<br>最后发送的是json数据的stringfy。  </p><h2 id="大体实现"><a href="#大体实现" class="headerlink" title="大体实现"></a>大体实现</h2><p>回到protocol monitor，我们可以发现当启用inspect模式时，会发送<code>Overlay.setInspectMode</code>方法，开启检查模式。虽然也可以在官方文档中看到，但是官方文档方法实在太多了，不如这种方式来的直接。<br>其次在页面上选中元素时，会接收一个<code>Overlay.nodeHighlightRequested</code>事件，会返回一个nodeId，而当在页面上点击一个元素时会接收一个<code>Overlay.inspectNodeRequested</code>事件，返回一个backendNodeId。<br>而无论是nodeId还是backendNodeId，都可以通过<code>DOM.describeNode</code>方法发送指定参数的请求，获取这个节点的详细信息。这个方法的参数如下：  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;nodeId&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="attr">&quot;backendNodeId&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="attr">&quot;objectId&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="attr">&quot;depth&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="attr">&quot;pierce&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>实际使用中，我们只需要发送nodeId或者backendNodeId即可。<br>其他实现自动化需要的事件还有<code>DOM.documentUpdated</code>，这个事件说明dom被更新了，需要重新获取dom，否则前后端的节点会不一致，可以通过<code>DOM.getDocument</code>方法重新获取dom，顺带一提，连接完成后，也应该执行一次这个方法。<br>至此，我们已经可以完成一个简单的自动化节点监控。下面简单写下代码。  </p><h2 id="简易实现代码"><a href="#简易实现代码" class="headerlink" title="简易实现代码"></a>简易实现代码</h2><p>这里我们使用websocket-client作为websocket的客户端连接到devtools。<br>先从<code>http://127.0.0.1:9222/json</code>获取到webSocketDebuggerUrl。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">send_msg_template = &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;method&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;params&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">searchForNode = &#123;</span><br><span class="line">    <span class="string">&quot;mode&quot;</span>: <span class="string">&quot;searchForNode&quot;</span>,</span><br><span class="line">    <span class="string">&quot;highlightConfig&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;showInfo&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;showRulers&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;showStyles&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;showAccessibilityInfo&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;showExtensionLines&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;contentColor&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;r&quot;</span>: <span class="number">111</span>,</span><br><span class="line">            <span class="string">&quot;g&quot;</span>: <span class="number">168</span>,</span><br><span class="line">            <span class="string">&quot;b&quot;</span>: <span class="number">220</span>,</span><br><span class="line">            <span class="string">&quot;a&quot;</span>: <span class="number">0.66</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">disableSearchForNode = deepcopy(searchForNode)</span><br><span class="line">disableSearchForNode[<span class="string">&#x27;mode&#x27;</span>] = <span class="string">&quot;none&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">ws, msg</span>):</span></span><br><span class="line">        data = json. loads(msg)</span><br><span class="line">        pprint(data)</span><br><span class="line">        method = data[<span class="string">&#x27;method&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> method == <span class="string">&#x27;Overlay.inspectNodeRequested&#x27;</span>:</span><br><span class="line">            <span class="comment"># 当在Inspector模式下，节点被按下时触发的事件</span></span><br><span class="line">            backend_node_id = data[<span class="string">&quot;params&quot;</span>][<span class="string">&#x27;backendNodeId&#x27;</span>]</span><br><span class="line">            <span class="comment"># pprint(backend_node_id)</span></span><br><span class="line">            <span class="comment"># 获取下详细的节点信息</span></span><br><span class="line">            send_msg(ws, <span class="string">&quot;DOM.describeNode&quot;</span>, &#123;<span class="string">&#x27;backendNodeId&#x27;</span>: backend_node_id&#125;)</span><br><span class="line">            <span class="comment"># 然后关闭Inspector模式</span></span><br><span class="line">            send_msg(ws, <span class="string">&quot;Overlay.setInspectMode&quot;</span>, disableSearchForNode)</span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">&quot;Overlay.nodeHighlightRequested&quot;</span>:</span><br><span class="line">            <span class="comment"># 这个方法是Inspector模式下，节点被选中时触发的，前提是已经获取过dom</span></span><br><span class="line">            send_msg(ws, <span class="string">&quot;DOM.describeNode&quot;</span>, &#123;<span class="string">&#x27;nodeId&#x27;</span>: data[<span class="string">&#x27;params&#x27;</span>][<span class="string">&#x27;nodeId&#x27;</span>]&#125;)</span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">&quot;DOM.documentUpdated&quot;</span>:</span><br><span class="line">            <span class="comment"># 收到这个方法说明dom被更新，需要重新获取下dom</span></span><br><span class="line">            send_msg(ws, <span class="string">&quot;DOM.getDocument&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_msg</span>(<span class="params">ws, method, params=<span class="literal">None</span></span>):</span></span><br><span class="line">        send_msg_template[<span class="string">&#x27;id&#x27;</span>] += <span class="number">1</span></span><br><span class="line">        msg = deepcopy(send_msg_template)</span><br><span class="line">        msg[<span class="string">&#x27;method&#x27;</span>] = method</span><br><span class="line">        msg[<span class="string">&#x27;params&#x27;</span>] = params <span class="keyword">if</span> params <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">        ws.send(json.dumps(msg))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_open</span>(<span class="params">ws</span>):</span></span><br><span class="line">        send_msg(ws, <span class="string">&quot;DOM.enable&quot;</span>)</span><br><span class="line">        send_msg(ws, <span class="string">&quot;Overlay.enable&quot;</span>)</span><br><span class="line">        send_msg(ws, <span class="string">&quot;Inspector.enable&quot;</span>)</span><br><span class="line">        send_msg(ws, <span class="string">&quot;DOM.getDocument&quot;</span>)</span><br><span class="line">        send_msg(ws, <span class="string">&quot;Overlay.setInspectMode&quot;</span>, searchForNode)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> websocket <span class="keyword">import</span> WebSocketApp</span><br><span class="line">    ws = WebSocketApp(<span class="string">&quot;ws://127.0.0.1:9222/devtools/page/EA63C0AE33770FD58FB89FD3A6ACB165&quot;</span>, on_message=on_message,</span><br><span class="line">                      on_open=on_open)</span><br><span class="line"></span><br><span class="line">    ws.run_forever()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    t = threading.Thread(target=main)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure><p>这里我们在连接完成后，立即发送几个方法，分别是<code>DOM.enable</code>,<code>Overlay.enable</code>,<code>Inspector.enable</code>,<code>DOM.getDocument</code>,<code>Overlay.setInspectMode</code>，其中几个enable是开启对应的功能，这里不再赘述，然后是立即获取一次dom，随后开启inspect模式，这里我们不需要浏览器中devtools的inspect那么多显示，如元素的padding，因此我们只保留最基础的设置。<br>随后我们在收到消息后就监听几个事件，分别是我们前文所讲的几个事件，随后在节点被按下后，取消inspect模式。<br>可以看看效果  </p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","preload":"none","video":{"url":"https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/devtools/1.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>这里当我们移动到一个元素上时，会打印出该节点的详细信息，在按下节点后，inspect模式随即解除。  </p><h2 id="使用第三方库监听"><a href="#使用第三方库监听" class="headerlink" title="使用第三方库监听"></a>使用第三方库监听</h2><p>当然，我们也可以专注于事件的监听和方法的发送，无需关注websocket的实现，<a href="https://github.com/fate0/pychrome">pychrome</a>就是这样的一个库，它的核心代码不过二百多行，它可以通过设置listener来实现指定方法的监听，根据官方示例，我们可以简单改造下上面的代码。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pychrome</span><br><span class="line">browser = pychrome.Browser(url=<span class="string">&quot;http://127.0.0.1:9222&quot;</span>)</span><br><span class="line">tab = browser.list_tab()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_node</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">result = tab.call_method(<span class="string">&quot;DOM.describeNode&quot;</span>, **kwargs)</span><br><span class="line">pprint(result)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_node_and_stop_inspect</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">result = tab.call_method(<span class="string">&quot;DOM.describeNode&quot;</span>, **kwargs)</span><br><span class="line">pprint(result)</span><br><span class="line">tab.call_method(<span class="string">&quot;Overlay.setInspectMode&quot;</span>, **disableSearchForNode)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_dom</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">tab.call_method(<span class="string">&quot;DOM.getDocument&quot;</span>)</span><br><span class="line"></span><br><span class="line">tab.set_listener(<span class="string">&quot;Overlay.inspectNodeRequested&quot;</span>, get_node_and_stop_inspect)</span><br><span class="line">tab.set_listener(<span class="string">&quot;Overlay.nodeHighlightRequested&quot;</span>, get_node)</span><br><span class="line">tab.set_listener(<span class="string">&quot;DOM.documentUpdated&quot;</span>, update_dom)</span><br><span class="line"></span><br><span class="line">tab.start()</span><br><span class="line">tab.call_method(<span class="string">&quot;DOM.enable&quot;</span>)</span><br><span class="line">tab.call_method(<span class="string">&quot;Overlay.enable&quot;</span>)</span><br><span class="line">tab.call_method(<span class="string">&quot;Inspector.enable&quot;</span>)</span><br><span class="line">tab.call_method(<span class="string">&quot;DOM.getDocument&quot;</span>)</span><br><span class="line">tab.call_method(<span class="string">&quot;Overlay.setInspectMode&quot;</span>, **searchForNode)</span><br><span class="line"></span><br><span class="line">tab.wait(<span class="number">10</span>)</span><br><span class="line">tab.stop()</span><br></pre></td></tr></table></figure><p>改造完成后，瞬间就很清爽，我们只需要对指定事件监听即可，脚本运行的情况与之前脚本相同，这里就不再演示。<br>唯一遗憾的是pychrome不支持一个event监听多个方法，新方法会覆盖旧方法。之后有机会提下pr吧。  </p><h2 id="获取节点xpath"><a href="#获取节点xpath" class="headerlink" title="获取节点xpath"></a>获取节点xpath</h2><p>至此，我们的自动化录制已经实现了一大部分，那么剩下就是获取这个节点的xpath，唯一确定这个节点的位置，就可以在selenium准确点击这个元素了。<br>回到刚刚的<code>DOM.describeNode</code>方法，这个方法的返回如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;node&#x27;</span>: &#123;<span class="string">&#x27;attributes&#x27;</span>: [<span class="string">&#x27;href&#x27;</span>,</span><br><span class="line">                                    <span class="string">&#x27;https://www.iana.org/domains/example&#x27;</span>],</span><br><span class="line">                     <span class="string">&#x27;backendNodeId&#x27;</span>: <span class="number">14</span>,</span><br><span class="line">                     <span class="string">&#x27;childNodeCount&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                     <span class="string">&#x27;localName&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;nodeId&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">                     <span class="string">&#x27;nodeName&#x27;</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;nodeType&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                     <span class="string">&#x27;nodeValue&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>我们知道这个节点的名称，attributes，但是我们却没有结构，来完成路径组装。其实<code>DOM.getDocument</code>是可以获取到完整结构树的，如果没有参数传递，那么最多只会获取1层的子树，我们可以指定depth参数为-1获取整个document结构。<br>有了整个dom树，那么我们就可以从上到下遍历树，从而获取节点的路径，我们也无需再次通过<code>DOM.describeNode</code>获取节点的数据。代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">dom_root = tab.call_method(<span class="string">&quot;DOM.getDocument&quot;</span>, depth=-<span class="number">1</span>)[<span class="string">&#x27;root&#x27;</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_path_from_root</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">backend_node_id = kwargs.get(<span class="string">&quot;backendNodeId&quot;</span>)</span><br><span class="line">path = _get_path(dom_root, backend_node_id, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;path: &quot;</span> + <span class="built_in">str</span>(path))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_path</span>(<span class="params">node, backend_node_id, path</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">递归获取结构</span></span><br><span class="line"><span class="string">:param node:</span></span><br><span class="line"><span class="string">:param backend_node_id:</span></span><br><span class="line"><span class="string">:param path</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> node[<span class="string">&#x27;backendNodeId&#x27;</span>] == backend_node_id:</span><br><span class="line"><span class="keyword">return</span> path + <span class="string">&quot;/&quot;</span> + node[<span class="string">&#x27;localName&#x27;</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> node.get(<span class="string">&#x27;children&#x27;</span>, []):</span><br><span class="line">child_path = _get_path(child, backend_node_id, path + <span class="string">&quot;/&quot;</span> + node[<span class="string">&#x27;localName&#x27;</span>])</span><br><span class="line"><span class="keyword">if</span> child_path:</span><br><span class="line"><span class="keyword">return</span> child_path</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>我们点击页面上超链接，得到<code>path: //html/body/div/p/a</code>，这里前面多个/符号是因为root没有名称，获取后做下处理即可。下面的代码会改进。<br>当然只用路径肯定不够，当有id时，我们优先使用id来实现，顺便改造下之前的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_path</span>(<span class="params">node, backend_node_id, path</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">递归获取结构</span></span><br><span class="line"><span class="string">:param node:</span></span><br><span class="line"><span class="string">:param backend_node_id:</span></span><br><span class="line"><span class="string">:param path</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">node_attributes = node.get(<span class="string">&#x27;attributes&#x27;</span>, [])</span><br><span class="line">node_id = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(node_attributes), <span class="number">2</span>):</span><br><span class="line"><span class="keyword">if</span> node_attributes[i] == <span class="string">&quot;id&quot;</span>:</span><br><span class="line">node_id = node_attributes[i + <span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> node_id:</span><br><span class="line">new_path = <span class="string">&quot;//*[@id=\&quot;&#123;&#125;\&quot;]&quot;</span>.<span class="built_in">format</span>(node_id)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">new_path = (path + <span class="string">&quot;/&quot;</span> + node[<span class="string">&#x27;localName&#x27;</span>]) <span class="keyword">if</span> node[<span class="string">&#x27;localName&#x27;</span>] <span class="keyword">else</span> path</span><br><span class="line"><span class="keyword">if</span> node[<span class="string">&#x27;backendNodeId&#x27;</span>] == backend_node_id:</span><br><span class="line"><span class="keyword">return</span> new_path</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> node.get(<span class="string">&#x27;children&#x27;</span>, []):</span><br><span class="line">child_path = _get_path(child, backend_node_id, new_path)</span><br><span class="line"><span class="keyword">if</span> child_path:</span><br><span class="line"><span class="keyword">return</span> child_path</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="也许是完善？"><a href="#也许是完善？" class="headerlink" title="也许是完善？"></a>也许是完善？</h2><p>当然这个获取xpath的代码还不完全，当节点有其他attr时也可以以这些属性作为xpath，并且还需要考虑同级别下有相同节点，此时需要用序号来标识。<br>并且通过id获取xpath也不能确保准确，因为网站的编写者可能重复使用id。(<del>CV程序员</del>)<br>例如，如下的html文件，我们在devtools的element里选中第一个p元素后右键复制XPath后，显示的path是<code>//*[@id=&quot;1&quot;]</code>，但这明显是有问题的，虽然是网页编写者的问题，但我们为了兼容所有系统，可以使用完整的path作为真正的xpath。  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&#x27;1&#x27;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&#x27;2&#x27;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&#x27;1&#x27;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&#x27;2&#x27;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基于以上观点，我们在这不使用带有attribute的xpath，只使用完整的xpath路径作为节点的唯一路径。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_path</span>(<span class="params">node, backend_node_id, path, idx=<span class="number">1</span></span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">递归获取结构</span></span><br><span class="line"><span class="string">:param node:</span></span><br><span class="line"><span class="string">:param backend_node_id:</span></span><br><span class="line"><span class="string">:param path</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">new_path = (path + <span class="string">&quot;/&quot;</span> + node[<span class="string">&#x27;localName&#x27;</span>]) <span class="keyword">if</span> node[<span class="string">&#x27;localName&#x27;</span>] <span class="keyword">else</span> path</span><br><span class="line"><span class="keyword">if</span> idx != <span class="number">1</span> <span class="keyword">and</span> new_path:</span><br><span class="line">new_path = new_path + <span class="string">&quot;[&#123;&#125;]&quot;</span>.<span class="built_in">format</span>(idx)</span><br><span class="line"><span class="keyword">if</span> node[<span class="string">&#x27;backendNodeId&#x27;</span>] == backend_node_id:</span><br><span class="line"><span class="keyword">return</span> new_path</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">children = node.get(<span class="string">&#x27;children&#x27;</span>, [])</span><br><span class="line">tag_map = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(children)):</span><br><span class="line">child = children[i]</span><br><span class="line"><span class="keyword">if</span> child[<span class="string">&#x27;localName&#x27;</span>] <span class="keyword">in</span> tag_map:</span><br><span class="line">tag_map[child[<span class="string">&#x27;localName&#x27;</span>]] += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tag_map[child[<span class="string">&#x27;localName&#x27;</span>]] = <span class="number">1</span></span><br><span class="line">child_path = _get_path(child, backend_node_id, new_path, tag_map[child[<span class="string">&#x27;localName&#x27;</span>]])</span><br><span class="line"><span class="keyword">if</span> child_path:</span><br><span class="line"><span class="keyword">return</span> child_path</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>通过以上代码我们已经能初步实现步骤的自动化录制。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文就网页自动化录制提出了自己的一些思路与代码实现，初步实现了自动化录制。当然，我相信仍旧有许多实际问题没有被我发现，只能等之后的具体开发才能发现会有什么问题。<br>其次，就airtest的功能来看，它认为节点的id不会重复，并且attribute大概率不会重复，因此它的xpath是多样的。<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/devtools/4.png" alt="4.png"><br>相较于airtest的录制功能，这篇文章最后代码使用的是完整的xpath路径，保证路径唯一。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近有个需求是做web自动化脚本录制，简单来说就是点击页面上的一个元素，就能把对应节点的xpath和自动化语法添加到脚本中。在airtest
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://re0.top/tags/Python/"/>
    
      <category term="自动化测试" scheme="https://re0.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>由于代码架构设计不佳而引发的异常消失</title>
    <link href="https://re0.top/2022/01/01/2022-first/"/>
    <id>https://re0.top/2022/01/01/2022-first/</id>
    <published>2022-01-01T10:00:00.000Z</published>
    <updated>2022-01-01T11:37:40.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>真的好久没写文章了，上一篇还是21年的6月写的。工作上事情再加上回来只想打游戏，这半年就没输出文章，中间其实有几次想过写写，但是不知道写点啥。  </p><p>打扫完房间，坐下打开电脑，正好原神预下载，也想想好久没写文章了，正好最近有个有意思的也是自己遇到问题，就边下载边码字了。  </p><p>今天是2022年的元旦，先祝看到这篇文章的朋友新年快乐吧。</p><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>这篇文章聊聊finally关键字，这个关键字Python和Java程序员肯定都不陌生。相信很多程序员其实都看过很多文章说finally关键字里面最好不要有return关键字，这点肯定很多人都知道，鉴于可能有人不知道，这里还是讲讲(水字数石锤)。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="由多个return导致返回值缺失"><a href="#由多个return导致返回值缺失" class="headerlink" title="由多个return导致返回值缺失"></a>由多个return导致返回值缺失</h2><p>上文说，很多文章警告不要在finally中使用return，他们文章里给出的例子很简单，这里我以Python为例，假设有以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">finally</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么其实这个函数返回值是2，而不是1，容易引起误解，所以大多数情况下，我们不会再finally中写任何return，防止返回值与预期不一致。</p><h2 id="脚本执行架构设计"><a href="#脚本执行架构设计" class="headerlink" title="脚本执行架构设计"></a>脚本执行架构设计</h2><p>而这篇文章要讲的也是finally，但不是因为返回值不一致。要讲这个之前，我想先讲一讲为啥我会遇到这个问题。  </p><p>大概是21年10月份，我们的测试框架打算引入前置与后置功能，那这部分的实现就落在我身上了，领导也很看重，希望能实现一个健硕的执行架构，那我也看了一些执行框架源码，比如rebot，但是其实关键部分光看源码其实看不出所以然出来，所以我决定先写下第一行代码再说。  </p><p>熟悉测试的同学应该知道，测试脚本呢，其实分为三部分，一是环境的准备（setup），测试主体（main），资源回收（teardown），用户只关心的是测试主体是否成功。那基于我们的测试执行框架，其实这三部分并没有什么差别，是分为三个脚本去执行，因此就需要一个调度框架去控制执行的顺序。  </p><p>执行的代码我们可以简化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self, stage</span>):</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> stage == <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;执行main&quot;</span>)</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">elif</span> stage == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;执行setup&quot;</span>)</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">elif</span> stage == <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;执行teardown&quot;</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">print</span>(<span class="string">&quot;发生异常，记录，置该脚本状态为FAIL&quot;</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">finally</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;根据stage不同，回填不同阶段的日志到服务器上&quot;</span>)</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;回填日志失败，记一下错误&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大概就是这个样子，这个就是最基础的执行方法，通过传入不同的stage，执行方法和回填日志。那调度方法可以简化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_case</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​        execute(<span class="number">0</span>)  <span class="comment"># 执行setup</span></span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> self.result == <span class="string">&quot;PASS&quot;</span>:</span><br><span class="line"></span><br><span class="line">​            execute(<span class="number">1</span>)  <span class="comment"># setup成功才执行main</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">finally</span>:</span><br><span class="line"></span><br><span class="line">​        execute(<span class="number">2</span>)  <span class="comment"># 无论如何都需要执行teardown</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然真实情况远没有那么简单，因为是一个执行树，所以需要递归调用，但这个地方不是重点，这里只讲最简单的架构。  </p><p>起初我对这个设计还是比较满意的，借助try和finally实现了对不同阶段的调用，之后我便考虑如何去停止正在执行的脚本。而关于停止，我设计了两套实现，其一是停止后，继续执行已执行过setup的脚本的teardown内容，其二是真正停止运行，不执行teardown。</p><p>我在类中声明了两个类变量，self.exit 和 self.real_exit，分别代表两种退出。其中当real_exit为True时，exit一定为True，但反过来不一定。因此上面的调度代码被我改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_case</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​        execute(<span class="number">0</span>)  <span class="comment"># 执行setup</span></span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> <span class="keyword">not</span> self.exit <span class="keyword">and</span> self.result == <span class="string">&quot;PASS&quot;</span>:</span><br><span class="line"></span><br><span class="line">​            execute(<span class="number">1</span>)  <span class="comment"># setup成功才执行main</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">finally</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> self.real_exit:</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">​        execute(<span class="number">2</span>)  <span class="comment"># 无论如何都需要执行teardown</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>请注意，这段代码是有问题的。</strong> </p><p>这里先说说exit和real_exit的赋值，上面有说过，因为是执行树，其实这两个变量在使用前其实必须使用self.exit = self.parent.get_exit()，通过递归来获取最顶层的状态，这里暂且提一下，这个不是本文的重点。</p><p>请注意，这里我在finally中用了return关键字，乍一看没啥问题，我当初觉得也没啥问题。首先run_case这个方法是没有返回值的，执行结果全在类变量中，然后是execute这个方法，全程也是在try/except的代码块中的，因此当初我认为不会有什么问题。这里run_case方法上层其实还有一层，为用户实际执行的层次，可以简化为：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">job</span>):</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​        job.run_case()</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">print</span>(<span class="string">&quot;执行发生异常，做个标记&quot;</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">finally</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">print</span>(<span class="string">&quot;有异常就通知用户，没有就通知已完成执行&quot;</span>)</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">print</span>(<span class="string">&quot;发送邮件&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，这个执行调度架构也直接上线了。期间也没出现过什么离谱的问题，满意度还是比较高的。</p><h2 id="开始意识到不对"><a href="#开始意识到不对" class="headerlink" title="开始意识到不对"></a>开始意识到不对</h2><p>我们服务器是保留1个月的日志，所以有概率seaweed会爆满的，当爆满时，日志无法回填，但其实测试脚本还是会继续跑的。所以有用户与我反馈说能不能上传失败就停下脚本，这样很浪费时间，执行完也没报告看，还不如不执行。我觉得有道理，便开始了改造，这改造不要紧，结果发现了这个架构中的大问题，也是我写这篇文章的原因。  </p><p>由于日志回填是在execute方法中，因此我们改造这个方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self, stage</span>):</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> stage == <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;执行main&quot;</span>)</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">elif</span> stage == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;执行setup&quot;</span>)</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">elif</span> stage == <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;执行teardown&quot;</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">print</span>(<span class="string">&quot;发生异常，记录，置该脚本状态为FAIL&quot;</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">finally</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;根据stage不同，回填不同阶段的日志到服务器上&quot;</span>)</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;回填日志失败，记一下错误&quot;</span>)</span><br><span class="line"></span><br><span class="line">​            self.upload_error_time += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">​            <span class="keyword">if</span> self.upload_error_time &gt;= <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">​                self.root_case.real_exit = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">​                <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;上传错误次数累计超过上限&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我在日志回填的时候，增加了简单的错误次数判断，那么如果顺利的话，当上传错误超过3次时，应该是这么一个流程：execute方法在finally中抛出了一个异常，由于没有捕获，抛给了它的调用方run_case，run_case是在try中接收了这个异常，但由于也没有捕获，又向上抛给了run方法，run方法捕获了这个异常，停止执行，并通知用户。</p><p>而之所以加入了self.root_case.real_exit，其实是为了不让run_case中finally执行，即不执行teardown。但我在写这篇文章的时候意识到，其实应该让teardown执行才对，不然环境没回收也是个问题，找个时间改下。当然这个也不是重点，因为我们就只想要上传失败3次后停下来，不想多执行其他的脚本了。</p><p>写完这个需求，我笑到，这个需求也是蛮简单的。但当我进行调试时，却发现事情的不对。首先我在回填日志时每次都抛出一个异常来模拟出现问题，这里便不多说。然后批量执行几个脚本，观察是否会如同预期一样，3次后直接抛出异常。这里要说的是，不管脚本的前置后置有没有内容，日志都会回填，我的执行树大概是这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root_case</span><br><span class="line">    folder</span><br><span class="line">        case1</span><br><span class="line">        case2</span><br><span class="line">        case3</span><br></pre></td></tr></table></figure><p>那么失败3次，就是root_case，folder，case1的setup都失败，此时发生异常退出。</p><p>但并没有像我预想的一样异常退出，而是正常退出？！我觉得可能是哪里有问题，又多执行了几次，但是还是这样。我就开始调试代码了。调试了很久，因为执行树是递归调用，所以调试很不容易，调了半个下午，这时候我才意识到我的异常被run_case中的finally中的return给吞噬了。</p><p>虽然run_case没有返回值，但是finally中的return还是出现了问题，这就是这次经历给我带来的教训，无论如何，不要在finally中写下return！不管是什么原因。</p><p>那么后来我便改成了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_case</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​        execute(<span class="number">0</span>)  <span class="comment"># 执行setup</span></span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> <span class="keyword">not</span> self.exit <span class="keyword">and</span> self.result == <span class="string">&quot;PASS&quot;</span>:</span><br><span class="line"></span><br><span class="line">​            execute(<span class="number">1</span>)  <span class="comment"># setup成功才执行main</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">finally</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> <span class="keyword">not</span> self.real_exit:</span><br><span class="line"></span><br><span class="line">​            execute(<span class="number">2</span>)  <span class="comment"># 无论如何都需要执行teardown</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时候异常就顺利向上抛出了。趁着没人发现这个bug，偷偷把它修了，哈哈。虽然没造成什么影响就是了，因为下层的一些会发生异常的操作方法，都会捕获异常。实际使用时并不会向上抛异常。</p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>这篇文章其实废话有点多，其实关键就一点，就是finally中不要写任何return，无论什么原因，除非你保证没有返回值或者下层绝对不会抛出异常。</p><p>除开这个，也讲了讲自己设计和编写的执行架构，我个人认为这个架构还是挺不错的，鉴于篇幅只讲了其中的一小部分，有机会的话可以来讲讲这个框架里我的callback设计，即执行单个脚本或者整个批次后进行一些调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;真的好久没写文章了，上一篇还是21年的6月写的。工作上事情再加上回来只想打游戏，这半年就没输出文章，中间其实有几次想过写写，
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://re0.top/tags/Python/"/>
    
      <category term="架构" scheme="https://re0.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>zbot架构畅谈</title>
    <link href="https://re0.top/2021/06/08/zbot/"/>
    <id>https://re0.top/2021/06/08/zbot/</id>
    <published>2021-06-08T06:10:00.000Z</published>
    <updated>2021-06-08T06:53:49.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>zbot是由我个人编写的简易机器人框架，它依赖于mirai与mirai_api_http，目前实现了关键字回复与定时功能，<a href="https://github.com/zer0e/zbots">zbot项目地址</a>。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>本文的目的是聊聊zbot的项目架构，这个项目应该是我第一个思考并运用架构知识所编写的框架应用，虽然功能简单，但其中架构部分却值得思考与拓展。<br>zbot主要由以下几部分组成：</p><ul><li>handler，主要用于处理消息或者定时处理</li><li>receiver，从mirai_api_http接收消息的websocket客户端</li><li>pluginLoader，负责从外部加载用户自定义插件到框架中</li><li>Api，封装mirai_api_http的部分功能供用户插件使用</li><li>registry，注册中心，负责插件注册，调度和转发请求 </li></ul><h2 id="借鉴主流RPC框架架构"><a href="#借鉴主流RPC框架架构" class="headerlink" title="借鉴主流RPC框架架构"></a>借鉴主流RPC框架架构</h2><p>zbot前期架构准备中，借鉴了主流RPC框架的架构，以dubbo框架为例，这是一张dubbo的架构图。<img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/zbot/dubbo1.jpg" alt="dubbo架构"><br>在dubbo中，provider，即服务提供方通过主动方式向注册中心注册服务；而消费端则是通过向注册中心获取已经注册的服务列表，需要时通过协议直接对服务提供方进行调用。这么做的好处是注册中心只负责了服务注册与发现，不转发请求，减小了注册中心的压力，这对整个架构是必须的。  </p><h2 id="更换架构"><a href="#更换架构" class="headerlink" title="更换架构"></a>更换架构</h2><p>虽然dubbo框架的架构方案十分不错，但考虑到以下几点</p><ul><li>需要设计私有协议</li><li>服务提供方必须提供其注册中心地址进行注册，但zbot插件必须是无配置或者少配置的，因为需要令插件无需配置就能运行在各个环境中</li><li>为了开箱即用，注册中心无需成为单独节点，如zk，而是直接整合进框架中</li><li>对提供方可能得编写单独依赖，如TCP支持，自动注册等等</li></ul><p><strong>zbot的目的是插件开发简单，并且开箱即用。</strong>综合以上几点，主流RPC框架的架构其实并不适用与zbot。随后我借助RPC框架的各个节点角色重新设计架构。以下是项目架构图。<img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/zbot/zbot.jpg" alt="zbot架构">   </p><h2 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h2><p>首先谈谈关键的插件部分，对应到RPC框架中就是服务提供方，那在zbot中，服务提供方不再通过主动方式去注册，而是通过pluginLoader对服务进行扫描，主要做法是读取框架配置与目录下的插件，再将开启的有效插件进行统一注册。那在后续的思考中，我认为zbot的架构中registry与pluginLoader应该合并为一个新的registry，由注册中心主动扫描并注册插件。但考虑到框架整体已经完成，并没有太大必要去整合架构，此处只是提出个人看法。  </p><hr><p>其次就是服务消费端的调用流程，在zbot中，服务消费端就是msghandler，他通过订阅注册中心的关键词列表，负责消息的处理。重点是，在RPC框架中，当需要消费提供者的服务时，是由消费端主要通过协议调用提供者，而在zbot中，则是消费端需要调用服务时，将消息与服务端的id转发至注册中心，由注册中心进行调用。<br>这么做的好处是消费端不用存储服务端的地址，前面提到，提供方需要简单开发，尽管通过依赖与注解或许能暴露服务端的接口，但需要占用端口，并且框架的开发难度也会加大。那么坏处就是注册中心的压力变大，不仅需要负责服务发现并且需要请求转发。  </p><hr><p>最后是调用方式，从消费端转发给注册中心，再从注册中心调用消费端，均采用异步方式，因为消费端不依赖与服务提供者，所以可以不用同步进行调用。这样可以防止服务提供方的故障，或者说避免API方面故障使得框架出现异常卡死。</p><h1 id="后续思考"><a href="#后续思考" class="headerlink" title="后续思考"></a>后续思考</h1><p>目前想到的点其实是插件热加载。如果以目前的架构来说，热加载只能让pluginLoader再次去加载插件，因此需要从头开始扫描。如果是主动服务注册的方式，那么热加载实现可能会更灵活。只能说各有利弊，前面也有提到，插件不能分离与框架，插件不应该独立运行，而是依托于整个框架。并且采用主动注册方式也就需要重新加载所有插件，令插件自行去注册。从这方面来看，zbot不管采用主动注册方式还是被动加载方式都没有什么差别。<br>目前的实现方案还是在zbot框架前套一个启动器，zbot包含以上几个部分，因为需要将这几个部分组合起来。在不影响现有代码的情况下，通过编写不同工厂方法能在原有zbot的基础上封装一个类似命令行的界面，reload命令实现重新加载插件与配置，这是目前的方案。至于实现日期，<del>咕咕咕</del>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;zbot是由我个人编写的简易机器人框架，它依赖于mirai与mirai_api_http，目前实现了关键字回复与定时功能，&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="架构" scheme="https://re0.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="Java" scheme="https://re0.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>对bsgamesdk的签名逆向分析</title>
    <link href="https://re0.top/2021/04/05/bsgamesdk-re/"/>
    <id>https://re0.top/2021/04/05/bsgamesdk-re/</id>
    <published>2021-04-05T06:10:00.000Z</published>
    <updated>2021-04-05T08:40:54.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近看到pcr查看个人信息的脚本，比较感兴趣就稍微研究了一下。之前很早的时候对pcr进行过抓包，没想到是基于http协议的，感觉日本那边的it技术比国内的稍微落后一点。<br>pcr接入的是bilibili游戏，要登录游戏得先登录b站账号，抓包之后发现登录过程还是比较简单的，首先是从服务器获取rsa公钥，然后把密码进行rsa加密，添加公共请求头就可以登录了。但是请求中存在的sign参数文档并没有公开。<br>虽然网上的脚本已经把逻辑写清楚，但是我还是决定深入sdk源码，查看签名的逻辑。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>从<a href="http://open.biligame.com/wiki/">官网</a>上下载最新的SDK和demo，用AndroidStudio打开工程就可以准备开始了。  </p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>在左侧的external libraries点开demo项目所依赖的sdk。有classes.jar和r-classes.jar。r里面就只有与Alipay相关的东西，应该不是所要找的代码。<br>点开classes.jar，随便点开几个发现都被简单混淆了。随后翻到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classes.jar!\com\bsgamesdk\android\api</span><br></pre></td></tr></table></figure><p>这个包应该是与api请求相关的。<br>大部分类都被混淆了。只留下三个有名字的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BSGameSdkAuth</span><br><span class="line">BSGameSdkExceptionCode</span><br><span class="line">BSGameSdkHttpQueryMap</span><br></pre></td></tr></table></figure>  <p>一个一个看，Auth类基本上都是parse方法，对传入的参数进行json解析。ExceptionCode则是各类错误码和错误提示。<br>那重点可能会在HttpQueryMap中。  </p><h2 id="初露曙光"><a href="#初露曙光" class="headerlink" title="初露曙光"></a>初露曙光</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">a</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">    var1 = var1.replace(<span class="string">&quot;+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">    var1 = var1.replace(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;%2A&quot;</span>);</span><br><span class="line">    var1 = var1.replace(<span class="string">&quot;%7E&quot;</span>, <span class="string">&quot;~&quot;</span>);</span><br><span class="line">    var1 = var1.replace(<span class="string">&quot;!&quot;</span>, <span class="string">&quot;%21&quot;</span>);</span><br><span class="line">    var1 = var1.replace(<span class="string">&quot;(&quot;</span>, <span class="string">&quot;%28&quot;</span>);</span><br><span class="line">    var1 = var1.replace(<span class="string">&quot;)&quot;</span>, <span class="string">&quot;%29&quot;</span>);</span><br><span class="line">    var1 = var1.replace(<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;%27&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>首先是个转义方法，pass。接着看下一个方法：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendToUri</span><span class="params">(Builder var1, String var2)</span> <span class="keyword">throws</span> UnsupportedEncodingException, NoSuchAlgorithmException </span>&#123;</span><br><span class="line">    BSGameSdkHttpQueryMap.a var3 = <span class="keyword">this</span>.getSignedQuery(var2);</span><br><span class="line">    Iterator var4 = <span class="keyword">this</span>.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">        Entry var5 = (Entry)var4.next();</span><br><span class="line">        String var6 = (String)var5.getKey();</span><br><span class="line">        String var7 = (String)var5.getValue();</span><br><span class="line">        var1.appendQueryParameter(var6, var7);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var1.appendQueryParameter(<span class="string">&quot;sign&quot;</span>, var3.b);</span><br><span class="line">    String var9 = var1.build().getEncodedQuery();</span><br><span class="line">    String var8 = <span class="keyword">this</span>.a(var9);</span><br><span class="line">    var1.encodedQuery(var8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>我们看到了sign，就是我们想要知道的，也就是sign的值应该是var3.b，而var3则是从getSignedQuery方法获得的。并且是一个<code>BSGameSdkHttpQueryMap.a</code>类，这是一个内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">a</span> </span>&#123;</span><br><span class="line">    String a;</span><br><span class="line">    String b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>接着看getSignedQuery方法。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BSGameSdkHttpQueryMap.<span class="function">a <span class="title">getSignedQuery</span><span class="params">(String var1)</span> <span class="keyword">throws</span> UnsupportedEncodingException, NoSuchAlgorithmException </span>&#123;</span><br><span class="line">    BSGameSdkHttpQueryMap.a var2 = <span class="keyword">new</span> BSGameSdkHttpQueryMap.a();</span><br><span class="line">    StringBuilder var3 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Iterator var4 = <span class="keyword">this</span>.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">        Entry var5 = (Entry)var4.next();</span><br><span class="line">        String var6 = (String)var5.getKey();</span><br><span class="line">        String var7 = (String)var5.getValue();</span><br><span class="line">        String var8 = URLEncoder.encode(var7, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        var8 = <span class="keyword">this</span>.a(var8);</span><br><span class="line">        var3.append(var6.toLowerCase(Locale.US));</span><br><span class="line">        var3.append(<span class="string">&#x27;=&#x27;</span>).append(var8).append(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> var13 = var3.length();</span><br><span class="line">    <span class="keyword">if</span> (var13 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        var3.deleteCharAt(var13 - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var2.a = var3.toString();</span><br><span class="line">    MessageDigest var14 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">    var14.reset();</span><br><span class="line">    var14.update(var2.a.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    var14.update(var1.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    StringBuffer var15 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">byte</span>[] var16 = var14.digest();</span><br><span class="line">    <span class="keyword">byte</span>[] var17 = var16;</span><br><span class="line">    <span class="keyword">int</span> var9 = var16.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var10 = <span class="number">0</span>; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">        <span class="keyword">byte</span> var11 = var17[var10];</span><br><span class="line">        <span class="keyword">int</span> var12 = var11 &amp; <span class="number">255</span>;</span><br><span class="line">        <span class="keyword">if</span> (var12 &lt; <span class="number">16</span>) &#123;</span><br><span class="line">            var15.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var15.append(Integer.toHexString(var12));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var2.b = var15.toString().toLowerCase(Locale.US);</span><br><span class="line">    <span class="keyword">return</span> var2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>先看前一部分，首先是对var4进行迭代，把所有的参数和值以<code>key=value&amp;</code>的方式进行拼接，然后去掉最后一个&amp;符号。<br>接着是调用MessageDigest对所有参数进行md5，但是注意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var14.update(var2.a.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">var14.update(var1.getBytes(&quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure><p>var14除了对参数进行update外还对var1进行了update。值得一提的是，messagedigest进行多次update相当于两个拼接后再进行update。因此这个var1是关键，而var1又是appendToUri的var2，因此只需要寻找appendToUri的调用者就知道这个参数是什么了。<br>但是遗憾的是，ide对源码中的usage的支持不怎么样。因此到这里线索断了。  </p><h2 id="再辟新径"><a href="#再辟新径" class="headerlink" title="再辟新径"></a>再辟新径</h2><p>没办法，只能一个个看api包下的其他混淆类。这里因为是源码是用class文件编译出来的，所以高级搜索没法用。<br>幸运的是，我们在e类中找到了请求的api。因为在抓包的时候，我们发现客户端会对<code>/api/client/rsa</code>进行获取rsa公钥。我们在e类中发现了这个地址。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BSGameSdkAuth <span class="title">b</span><span class="params">(<span class="keyword">final</span> Context var1)</span> <span class="keyword">throws</span> BSGameSdkExceptionCode, HttpException, IOException </span>&#123;</span><br><span class="line">    c var2 = <span class="keyword">new</span> c&lt;BSGameSdkAuth&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> BSGameSdkAuth <span class="title">b</span><span class="params">(String var1x)</span> <span class="keyword">throws</span> BSGameSdkExceptionCode, HttpException, IOException </span>&#123;</span><br><span class="line">            Builder var2 = Uri.parse(var1x).buildUpon();</span><br><span class="line">            var2.path(<span class="string">&quot;/api/client/rsa&quot;</span>);</span><br><span class="line">            Map var3 = e.c(var1, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.a(var3);</span><br><span class="line">            e.<span class="keyword">this</span>.a(var1, var3, var1x);</span><br><span class="line">            e.c(var3);</span><br><span class="line">            BSGameSdkAuth var4 = <span class="keyword">new</span> BSGameSdkAuth();</span><br><span class="line">            Uri var5 = var2.build();</span><br><span class="line">            HttpPost var6 = HttpDNSConfig.queryCachePost(var5.toString(), var3);</span><br><span class="line">            var6.addHeader(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 BSGameSDK&quot;</span>);</span><br><span class="line">            String var7 = HttpManager.executeForString(var1, var6);</span><br><span class="line">            var4.parseRSAResponse(var7);</span><br><span class="line">            <span class="keyword">return</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (BSGameSdkAuth)var2.a(<span class="number">0</span>, a.s(), <span class="string">&quot;rsa&quot;</span>, (String)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>主要还是看中间的几行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map var3 = e.c(var1, 1);</span><br><span class="line">this.a(var3);</span><br><span class="line">e.this.a(var1, var3, var1x);</span><br><span class="line">e.c(var3);</span><br></pre></td></tr></table></figure><p>先看e.c方法。cr^b进入方法。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">c</span><span class="params">(Context var0, <span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">    a();</span><br><span class="line">    HashMap var2 = <span class="keyword">new</span> HashMap();</span><br><span class="line">    var2.put(<span class="string">&quot;game_id&quot;</span>, com.bsgamesdk.android.model.c.a);</span><br><span class="line">    var2.put(<span class="string">&quot;merchant_id&quot;</span>, com.bsgamesdk.android.model.c.f);</span><br><span class="line">    var2.put(<span class="string">&quot;version&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    var2.put(<span class="string">&quot;timestamp&quot;</span>, <span class="string">&quot;&quot;</span> + com.bsgamesdk.android.api.b.b());</span><br><span class="line">    var2.put(<span class="string">&quot;client_timestamp&quot;</span>, <span class="string">&quot;&quot;</span> + System.currentTimeMillis());</span><br><span class="line">    var2.put(<span class="string">&quot;server_id&quot;</span>, com.bsgamesdk.android.model.c.g);</span><br><span class="line">    var2.put(<span class="string">&quot;sdk_ver&quot;</span>, com.bsgamesdk.android.model.c.l);</span><br><span class="line">    var2.put(<span class="string">&quot;sdk_type&quot;</span>, com.bsgamesdk.android.model.c.s);</span><br><span class="line">    var2.put(<span class="string">&quot;c&quot;</span>, a.c());</span><br><span class="line">    var2.put(<span class="string">&quot;isRoot&quot;</span>, com.bsgamesdk.android.model.c.q);</span><br><span class="line">    var2.put(<span class="string">&quot;udid&quot;</span>, com.bsgamesdk.android.model.c.p);</span><br><span class="line">    var2.put(<span class="string">&quot;support_abis&quot;</span>, com.bsgamesdk.android.model.c.r);</span><br><span class="line">    var2.put(<span class="string">&quot;mac&quot;</span>, TextUtils.isEmpty(ab.d()) ? <span class="string">&quot;&quot;</span> : ab.d());</span><br><span class="line">    var2.put(<span class="string">&quot;imei&quot;</span>, TextUtils.isEmpty(ab.b(var0)) ? <span class="string">&quot;&quot;</span> : ab.b(var0));</span><br><span class="line">    var2.put(<span class="string">&quot;android_id&quot;</span>, TextUtils.isEmpty(l.b(var0)) ? <span class="string">&quot;&quot;</span> : l.b(var0));</span><br><span class="line">    <span class="keyword">boolean</span> var3 = com.bsgamesdk.android.b.b.checkIsLogined(var0);</span><br><span class="line">    <span class="keyword">boolean</span> var4 = com.bsgamesdk.android.b.b.checkIsTouristLogined(var0);</span><br><span class="line">    String var5 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String var6 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (var3) &#123;</span><br><span class="line">        UserParcelable var7 = (<span class="keyword">new</span> m(var0)).c();</span><br><span class="line">        var5 = var7.uid_long + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        var6 = var7.access_token + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var4) &#123;</span><br><span class="line">        TouristUserParceable var10 = (<span class="keyword">new</span> com.bsgamesdk.android.model.k(var0)).c();</span><br><span class="line">        var5 = var10.uid_long + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        var6 = var10.access_token + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var2.put(<span class="string">&quot;uid&quot;</span>, var5);</span><br><span class="line">    var2.put(<span class="string">&quot;access_key&quot;</span>, var6);</span><br><span class="line">    var2.put(<span class="string">&quot;app_id&quot;</span>, com.bsgamesdk.android.model.c.a);</span><br><span class="line">    var2.put(<span class="string">&quot;sdk_log_type&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    var2.put(<span class="string">&quot;ver&quot;</span>, com.bsgamesdk.android.model.c.i);</span><br><span class="line">    var2.put(<span class="string">&quot;version_code&quot;</span>, com.bsgamesdk.android.model.c.j);</span><br><span class="line">    var2.put(<span class="string">&quot;channel_id&quot;</span>, com.bsgamesdk.android.model.c.c);</span><br><span class="line">    h.a(var2);</span><br><span class="line">    var2.put(<span class="string">&quot;platform_type&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">    var2.put(<span class="string">&quot;model&quot;</span>, h.c(var0));</span><br><span class="line">    var2.put(<span class="string">&quot;brand&quot;</span>, h.d(var0));</span><br><span class="line">    var2.put(<span class="string">&quot;net&quot;</span>, h.a(var0));</span><br><span class="line">    var2.put(<span class="string">&quot;operators&quot;</span>, h.b(var0));</span><br><span class="line">    var2.put(<span class="string">&quot;pf_ver&quot;</span>, h.e(var0));</span><br><span class="line">    var2.put(<span class="string">&quot;dp&quot;</span>, com.bsgamesdk.android.model.c.t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String var11 = TextUtils.isEmpty(o.a(var0).c) ? <span class="string">&quot;&quot;</span> : o.a(var0).c;</span><br><span class="line">        String var8 = TextUtils.isEmpty(o.a(var0).d) ? <span class="string">&quot;&quot;</span> : o.a(var0).d;</span><br><span class="line">        var2.put(<span class="string">&quot;old_buvid&quot;</span>, var11);</span><br><span class="line">        var2.put(<span class="string">&quot;cur_buvid&quot;</span>, var8);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">        var2.put(<span class="string">&quot;old_buvid&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        var2.put(<span class="string">&quot;cur_buvid&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        LogUtils.printThrowableStackTrace(var9);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(b)) &#123;</span><br><span class="line">        b = com.bsgamesdk.android.utils.a.a(var0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var2.put(<span class="string">&quot;apk_sign&quot;</span>, b);</span><br><span class="line">    var2.put(<span class="string">&quot;oaid&quot;</span>, TextUtils.isEmpty(com.bsgamesdk.android.model.c.z) ? <span class="string">&quot;&quot;</span> : com.bsgamesdk.android.model.c.z);</span><br><span class="line">    var2.put(<span class="string">&quot;fingerprint&quot;</span>, TextUtils.isEmpty(com.bsgamesdk.android.model.c.A) ? <span class="string">&quot;&quot;</span> : com.bsgamesdk.android.model.c.A);</span><br><span class="line">    <span class="keyword">return</span> var2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中，参数var1是个遗留参数，并没有使用。应该只是为了重载方法。这个方法的作用就是添加各种参数，这些参数在抓包的时候param里面基本上都有。除了个别参数。和sign无关，往回看。接下来是两个this.a方法，也都是添加参数。<br>接下来是另一个c方法。<code>e.c(var3);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">(Map&lt;String, String&gt; var0)</span> </span>&#123;</span><br><span class="line">    String var1 = d(var0);</span><br><span class="line">    var0.put(<span class="string">&quot;sign&quot;</span>, var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>很好，这可能是我们需要的，继续跟进d方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">d</span><span class="params">(Map&lt;String, String&gt; var0)</span> </span>&#123;</span><br><span class="line">    String var1 = a(var0);</span><br><span class="line">    String var2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    var2 = p.a(var1, com.bsgamesdk.android.model.c.b);</span><br><span class="line">    <span class="keyword">return</span> var2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>先看第一行<code>String var1 = a(var0);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">(Map&lt;String, String&gt; var0)</span> </span>&#123;</span><br><span class="line">    ArrayList var1 = <span class="keyword">new</span> ArrayList(var0.keySet());</span><br><span class="line">    Collections.sort(var1);</span><br><span class="line">    String var2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var1.size(); ++var3) &#123;</span><br><span class="line">        String var4 = (String)var1.get(var3);</span><br><span class="line">        <span class="keyword">if</span> (var4 != <span class="keyword">null</span> &amp;&amp; !var4.equalsIgnoreCase(<span class="string">&quot;item_name&quot;</span>) &amp;&amp; !var4.equalsIgnoreCase(<span class="string">&quot;item_desc&quot;</span>)) &#123;</span><br><span class="line">            String var5 = (String)var0.get(var4);</span><br><span class="line">            var2 = var2 + var5;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>逻辑很简单，对map的参数key进行排序，然后把value拼接到一起。<br>接着看<code>var2 = p.a(var1, com.bsgamesdk.android.model.c.b);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">a</span><span class="params">(String var0, String var1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String var2 = var0 + var1;</span><br><span class="line">        MessageDigest var3 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        var3.update(var2.getBytes(Charset.defaultCharset()));</span><br><span class="line">        <span class="keyword">byte</span>[] var4 = var3.digest();</span><br><span class="line">        <span class="keyword">return</span> a(var4);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException var5) &#123;</span><br><span class="line">        LogUtils.printExceptionStackTrace(var5);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>其实就是把两个参数拼接起来然后进行MD5摘要。这就是我们的sign。<br>总结：sign就是所有参数排序后保留value然后拼接<code>com.bsgamesdk.android.model.c.b</code>的值进行hash。<br>那新的问题来了，这个model.c.b的值又是什么呢？</p><h2 id="接近答案"><a href="#接近答案" class="headerlink" title="接近答案"></a>接近答案</h2><p>跟进model.c类，b是一个静态String，而b的赋予在c类的a方法中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(Context var0, String var1, String var2, String var3, String var4, String var5, String var6, <span class="keyword">boolean</span> var7, String var8)</span> </span>&#123;</span><br><span class="line">    f = var1;</span><br><span class="line">    a = var2;</span><br><span class="line">    g = var3;</span><br><span class="line">    d = var7;</span><br><span class="line">    i = f(var0);</span><br><span class="line">    j = g(var0);</span><br><span class="line">    k = var5;</span><br><span class="line">    l = var6;</span><br><span class="line">    m = var8;</span><br><span class="line">    b = var4;</span><br><span class="line">    c = d(var0);</span><br><span class="line">    e = com.bsgamesdk.android.utils.o.a(var0).a();</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>之后就没有了，既然反向不行，那就从正向开始。<br>我们找到demo的MainActivity，跟进官方的文档，必须在oncreate中调用BSGameSdk.initialize方法完成sdk的初始化。我们跟进initialize方法。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BSGameSdk <span class="title">initialize</span><span class="params">(<span class="keyword">boolean</span> var0, Activity var1, String var2, String var3, String var4, String var5, InitCallbackListener var6, ExitCallbackListener var7)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">        com.bsgamesdk.android.utils.f.a(var1.getApplicationContext());</span><br><span class="line">        f = <span class="keyword">new</span> BSGameSdk(var0, var1, var2, var3, var4, var5, var6, var7);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <p>跟进BSGameSdk</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressLint(&#123;&quot;NewApi&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">BSGameSdk</span><span class="params">(<span class="keyword">boolean</span> var1, Activity var2, String var3, String var4, String var5, String var6, <span class="keyword">final</span> InitCallbackListener var7, ExitCallbackListener var8)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    com.bsgamesdk.android.model.c.a(var2, var3, var4, var5, var6, var9.getSDK_NAME(), var9.getSDK_Version(), var9.isBiliSDK(), var9.getVersion());</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>我们找到了刚才model.c的中a方法的调用方。<br>a方法中我们需要的值是参数中的var4也就是a方法中的第5个参数。对应到BSGameSdk构造方法就是var6，而var6在这则是第6个参数，再往上走是initialize方法，第6个参数是var5，也是第6个参数。<br>最后是MainActivity调用方，第6个参数对应的是app_key，至此破案。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们从源码中得到了sign的计算方式，是一堆参数排序后取value，然后拼接app_key后进行md5摘要。刚开始的HttpQueryMap可能是针对get方法在其他地方使用到，毕竟进行了url转义，当然也可能是一个遗留类，我们不得而知。<br>这次源码分析还是比较顺利，主要还是源码没有强加密和混淆，使得分析更加容易些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近看到pcr查看个人信息的脚本，比较感兴趣就稍微研究了一下。之前很早的时候对pcr进行过抓包，没想到是基于http协议的，感觉日本那边的i
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://re0.top/tags/Java/"/>
    
      <category term="Android" scheme="https://re0.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Spring Boot自动配置</title>
    <link href="https://re0.top/2020/12/13/autoConfiguration/"/>
    <id>https://re0.top/2020/12/13/autoConfiguration/</id>
    <published>2020-12-13T06:10:00.000Z</published>
    <updated>2020-12-13T09:41:54.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久没写技术性文章了，今天就来谈谈SpringBoot中最常见但是却很少人去了解的知识，那就是SpringBoot是如何让你免去如此多的xml配置的。<br>本人技术有限，文章如有错误请谅解。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>用过SpringBoot的人都很清楚，它很方便，不用配置xml，开箱即用，那你是否想过SpringBoot是如何实现自动配置的呢？我也很好奇，那本文就深入源码看看SpringBoot都做了些什么来自动配置的吧。  </p><h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>那我们当然是新建一个项目啦，我们很清楚，springboot项目都用一个以@SpringBootApplication为注解的主类，这是我们项目的入口点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FirstDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>那通过上面的导入，我们知道@SpringBootApplication来自autoconfigure包中，看名字就知道这是我们需要的自动配置相关的包。那我们跟进这个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <p>这个注解里面使用@AliasFor将多个注解组合，简单解释就是将它上面的注解合并成当前注解，即SpringBootApplication。换句话来说，@SpringBootApplication就相当于@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解一起作用。<br>那其中@ComponentScan是我们比较熟悉的，用于扫描bean组件装配到ioc容器中，这里我们便不展开。<br>然后是@SpringBootConfiguration，跟进后我们发现其实就是@Configuration中的一种，也就是配置类，这里我们也不多讲。<br>本文的主角就是@EnableAutoConfiguration。</p><h2 id="深入-EnableAutoConfiguration"><a href="#深入-EnableAutoConfiguration" class="headerlink" title="深入@EnableAutoConfiguration"></a>深入@EnableAutoConfiguration</h2><p>我们跟进@EnableAutoConfiguration。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>有两个主要注解，@AutoConfigurationPackage和@Import({AutoConfigurationImportSelector.class})。<br>我们先来看看@AutoConfigurationPackage。</p><h3 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(&#123;Registrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>这里提一下，import注解是spring提供的，它的作用是将某个类实例化后加入ioc容器中。<br>那么我们就可以知道@AutoConfigurationPackage其实就是将Registrar.class实例化后加入ioc容器当中。继续跟进Registrar类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line">    Registrar() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        AutoConfigurationPackages.register(registry, (String[])(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>我们发现是一个静态内部类，其中有两个方法registerBeanDefinitions和determineImports。我们分别在两个方法中加入断点，调试下。其中<code>(String[])(new AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(new String[0])</code>返回的是@SpringBootApplication注解所在的类的包名，在这个项目中就是<code>com.example.first_demo</code>。<br>然后就是determineImports，在项目中没有触发断点，我们通过无敌的google大法知道返回的是一组代表要导入项的对象。这对本文的主题无多大关系，因此就略过。<br><strong>至此，@AutoConfigurationPackage的作用就是将主配置类所在的包及子包中的所有组件扫描到ioc容器当中。</strong></p><h3 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h3><p>重新回到@EnableAutoConfiguration，发现它将AutoConfigurationImportSelector添加到容器中。这应该就是自动配置的核心所在，我们跟进这个类。这个类中的方法很多，我们挑一些重要的来讲。<br>像getAutoConfigurationEntry方法，源码中还特意添加了注释。这个方法用于获取需要自动装配的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the &#123;<span class="doctag">@link</span> AutoConfigurationEntry&#125; based on the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125;</span></span><br><span class="line"><span class="comment"> * of the importing &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotationMetadata the annotation metadata of the configuration class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the auto-configurations that should be imported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>在这个方法中又有一个比较重要的方法，getCandidateConfigurations。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the auto-configuration class names that should be considered. By default</span></span><br><span class="line"><span class="comment"> * this method will load candidates using &#123;<span class="doctag">@link</span> SpringFactoriesLoader&#125; with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #getSpringFactoriesLoaderFactoryClass()&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the source metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> attributes the &#123;<span class="doctag">@link</span> #getAttributes(AnnotationMetadata) annotation</span></span><br><span class="line"><span class="comment"> * attributes&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a list of candidate configurations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">            getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">            + <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>这个方法返回所有候选配置类，即包括需要加载的和用户指定排除的。<br>在这个方法中使用了SpringFactoriesLoader.loadFactoryNames，SpringFactoriesLoader是Spring框架的一个内部工具类，用于加载类。继续跟进方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the fully qualified class names of factory implementations of the</span></span><br><span class="line"><span class="comment"> * given type from &#123;<span class="doctag">@value</span> #FACTORIES_RESOURCE_LOCATION&#125;, using the given</span></span><br><span class="line"><span class="comment"> * class loader.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As of Spring Framework 5.3, if a particular implementation class name</span></span><br><span class="line"><span class="comment"> * is discovered more than once for the given factory type, duplicates will</span></span><br><span class="line"><span class="comment"> * be ignored.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factoryType the interface or abstract class representing the factory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader the ClassLoader to use for loading resources; can be</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125; to use the default</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if an error occurs while loading factory names</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadFactories</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    ClassLoader classLoaderToUse = classLoader;</span><br><span class="line">    <span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    String factoryTypeName = factoryType.getName();</span><br><span class="line">    <span class="keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>这个方法返回加载类的全名，通过loadSpringFactories私用方法，我们详细来看这个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line">                String[] factoryImplementationNames =</span><br><span class="line">                        StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line">                <span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">                    result.computeIfAbsent(factoryTypeName, key -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;())</span><br><span class="line">                            .add(factoryImplementationName.trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Replace all lists with unmodifiable lists containing unique elements</span></span><br><span class="line">        result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()</span><br><span class="line">                .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>那么简单看下源码我们可以得知，该方法就是读取每个类中的META-INF/spring.factories文件中设置的所有xxxAutoConfiguration类，并使用PropertiesLoaderUtils.loadProperties获取其所有属性值，将这些值作为自动配置类添加到ioc容器当中，相当于完成了配置，以前需要手动配置的东西，自动配置帮我们添加了默认值。<br>我们可以看看spring-boot-autoconfigure中的spring.factories。这些都是默认自动装配的。<br>简单贴一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br></pre></td></tr></table></figure>  <p>比如我们看看AopAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(Advice.class)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">        <span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = false)</span></span><br><span class="line">        <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;,</span></span><br><span class="line"><span class="meta">                matchIfMissing = false)</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">        <span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line">        <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">                matchIfMissing = true)</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingClass(&quot;org.aspectj.weaver.Advice&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">            matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassProxyingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassProxyingConfiguration(BeanFactory beanFactory) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">                BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">                AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>可以清楚地看到，springboot提供了默认配置类，并通过条件注解来加载配置到容器中。</p><h2 id="第三方jar自动配置"><a href="#第三方jar自动配置" class="headerlink" title="第三方jar自动配置"></a>第三方jar自动配置</h2><p>从上面我们已经可以知道springboot会扫描所有类的spring.factories，并从中读取自动配置类。就比如常用的mybatis，我们在项目中导入mybatis，并查看它的依赖。<br>一般来说，我们在springboot项目中都是使用mybatis-spring-boot-starter导入到pom文件中，我们查看这个包的依赖，其实就是导入mybatis，jdbc，还有mybatis-spring-boot-autoconfigure，看到autoconfigure，我们知道肯定就是这个包完成自动配置。<br>我们查看这个包的资源文件，果然发现了spring.factories文件。里面就几行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span><br></pre></td></tr></table></figure>  <p>这里默认配置类我就不贴了，就是通过条件注解将默认配置添加到spring中。</p><h2 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h2><p>上文提到了条件注解，它作用在类上就是满足一定条件时类才会进行装配，其中条件注解有：</p><ul><li>ConditionalOnBean 容器中存在某个bean时生效</li><li>ConditionalOnClass classpath中存在某类时生效</li><li>ConditionalOnCloudPlatform 当指定的云平台处于活动状态时生效</li><li>ConditionalOnExpression SpEL表达式结果为true时生效</li><li>ConditionalOnJava 指定的Java版本存在时生效</li><li>ConditionalOnJndi 指定的JNDI存在时生效</li><li>ConditionalOnMissingBean 容器中不存在某个bean时生效</li><li>ConditionalOnMissingClass classpath中不存在某类时生效</li><li>ConditionalOnNotWebApplication 非Web应用环境下生效</li><li>ConditionalOnProperty 参数设置或者值一致时生效</li><li>ConditionalOnResource 指定的文件存在时生效</li><li>ConditionalOnSingleCandidate 容器中该类型Bean只有一个或@Primary的只有一个时生效</li><li>ConditionalOnWarDeployment 使用WAR部署时生效</li><li>ConditionalOnWebApplication Web应用环境下生效</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那本文简单从源码入手，讲解了springboot是如何自动配置的，@SpringBootApplication注解中包含了@EnableAutoConfiguration，这个注解帮助我们自动配置。<br>首先springboot在启动时扫描同一个包类的所有的组件，并检查各个jar包中是否存在META-INF/spring.factories 文件，然后如果第三方jar中存在这个文件，会根据文件中设置的自动装配类进行加载，使之生效。如此便实现了自动配置。<br>不过话说回来，说是自动配置，其实就是源码和第三方包中帮你把配置的功夫省下来了，节约不少时间，也能防止很多bug的出现。<br>那本文也留下很多没提到的，比如springboot怎么开始自动配置的，我们知道它如何装配，但是我们却不知道如何开始。这个也是个有趣的点，之后会写一写springboot的生命周期相关的文章。</p><h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><p>那本文写到这里就结束了，2020年马上也要过去了，时间是真的快，有空的话也会写写2020年的总结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;好久没写技术性文章了，今天就来谈谈SpringBoot中最常见但是却很少人去了解的知识，那就是SpringBoot是如何让你免去如此多的xm
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://re0.top/tags/Java/"/>
    
      <category term="Spring" scheme="https://re0.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>回顾数据库事务隔离级别</title>
    <link href="https://re0.top/2020/11/01/transaction_isolation/"/>
    <id>https://re0.top/2020/11/01/transaction_isolation/</id>
    <published>2020-11-01T06:10:00.000Z</published>
    <updated>2020-11-02T07:24:22.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于数据库隔离级别，前前后后可能复习了好多遍，但是很经常就忘记，今天就简单整理下概念和实例，方便以后回顾。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>首先我们先明确事务是什么？为什么要有事务？<br>事务(Transaction)，其实就是一个操作序列，我们知道，操作数据库是什么一条条SQL语句来实现的，那么事务就是包含这些SQL操作的清单。<br>至于为什么要有事务，是因为事务是为了解决并发情况下如何保持数据一致性的问题。通过事务，我们能在并发情况下保持数据的一致性。    </p><h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><p>事务的四大特性简称ACID，分别为原子性(Atomicity)，一致性(Consistency)，隔离性(Isolation)，持久性(Durability)。<br>所谓原子性，是指事务中包含的所有操作必须全部成功或者全部失败。<br>一致性，是指事务执行前后，数据的状态是一致的。一般来说，就是指数据不会凭空产生或消失。就拿库存和订单来说，商品的订单增加必定伴随着库存的减少，两者涉及的商品总量是一致的。<br>隔离性，是指多个事务并发执行时，彼此之间要相互隔离，简单来说就是事务感受不到其他事务的存在。这就是我之后要讲的隔离级别。<br>持久性，是指事务一旦提交，那么对于数据库中数据的改变是永久性的。  </p><h2 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h2><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p>通常情况下，对mysql命令行的所有语句都是自动提交的，可以简单理解成每条SQL语句都是一个独立的事务，在我们写SQL之前就开启了事务，当我们回车之后自动帮我们提交给数据库。<br>那这只是单条SQL语句，如果在命令行中要执行多条SQL语句的事务，需要使用begin和commit命令来显示开启事务。在事务提交之前，所有的修改都不会应用到数据上。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | abc  |</span><br><span class="line">|  2 | asd  |</span><br><span class="line">+----+------+</span><br><span class="line">2 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user values (3,&quot;aaa&quot;);</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | abc  |</span><br><span class="line">|  2 | asd  |</span><br><span class="line">|  3 | aaa  |</span><br><span class="line">+----+------+</span><br><span class="line">3 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected</span><br></pre></td></tr></table></figure><p>如果我们在commit之前打开另一个命令行进行查询，我们可以发现新插入的数据并没有在数据库中。  </p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>那在Spring中我们要使用事务，简单来说就是使用@Transactional注解来实现，即在方法上标注注解就可以实现。简单写下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDAO userDAO;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = userDAO.insert(user);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;显式抛出异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在addUser方法中手动抛出异常，如果@Transactional注解指定了触发回滚的异常类型，那么如果抛出了该种异常，就会自动回滚(rollback)，数据不会插入到数据库中。<br>那么关于spring中的事务管理与深入学习，就留到之后的文章再讨论吧。  </p><h2 id="并发事务所出现的问题"><a href="#并发事务所出现的问题" class="headerlink" title="并发事务所出现的问题"></a>并发事务所出现的问题</h2><p>前面提到在并发事务时，事务是相互隔离的，但是隔离有性能代价的，隔离越彻底，那么性能就越差，所以数据库会提供不同级别的隔离策略，开发者需要考虑事务并发的安全性与性能上的差异，来选择合适的隔离级别。<br>那么事务并发会引发哪些数据上的不安全性呢？  </p><h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p>丢失更新分为两类，一般称为第一类丢失更新和第二类丢失更新。<br>第一类丢失更新是指，在A事务回滚后，把已经提交的B事务的数据给覆盖掉了。例如A事务是扣款100元，而B事务是增加100元，在A事务已经修改余额但是还未提交或回滚时，B事务已经增加了100元。这时候A事务回滚，变为原来的钱，此时B事务增加的100元就消失了。<br>第二类丢失更新，是指在A事务提交后，把已经提交的B事务的数据给覆盖掉了。与第一类丢失更新类似，区别在于第一类是回滚，而第二类是提交。<br>丢失更新本质上和<strong>可重复读</strong>是同一类并发的问题，多个数据查询同一数据，都是基于自己的查询来更新数据，会造成最后一个提交或回滚的事务覆盖掉其他已经提交的事务。  </p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读的定义是读到未提交的数据。<br>这个好理解，假设原来有100元，现在A事务增加100元，余额变成200元，但此时还未提交，这时B事务读取到了事务A修改后的数据，即读取到余额为200元，然后把200元扣款成0元，并提交了数据。但最后A事务却进行了回滚，把余额重新变为100元。这样就相当于无缘无故增加了200块钱。<br>在默认隔离级别下，避免了脏读操作。  </p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读是指读到了已经提交的更新数据，即一个事务中两次相同查询却返回了不同的<strong>更新数据</strong>。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>幻读与不可重复读类似。幻读是指在一个事务中的两次相同查询却查到了另一个事务已提交的<strong>新插入数据</strong>。<br>两者区别是不可重复读是由数据修改产生的，而幻读是数据插入或者删除产生的。  </p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>那么为了解决上述的事务并发问题，Mysql中定义了四种隔离级别，分别是读未提交，读已提交，可重复读，可串行化。  </p><h3 id="读未提交-READ-UNCOMMITTED"><a href="#读未提交-READ-UNCOMMITTED" class="headerlink" title="读未提交(READ UNCOMMITTED)"></a>读未提交(READ UNCOMMITTED)</h3><p>在这种隔离级别下，事务A能读取到事务B修改但是未提交的数据，那么就会导致脏读，不可重复读和幻读问题。  </p><h3 id="读已提交-READ-COMMITTED"><a href="#读已提交-READ-COMMITTED" class="headerlink" title="读已提交(READ COMMITTED)"></a>读已提交(READ COMMITTED)</h3><p>这种隔离级别下，事务A只能在事务B修改并且提交之后才能读取到修改后的数据。<br>它解决了脏读问题，但是会发生不可重复读和幻读问题。  </p><h3 id="可重复读-REPEATABLE-READ"><a href="#可重复读-REPEATABLE-READ" class="headerlink" title="可重复读(REPEATABLE READ)"></a>可重复读(REPEATABLE READ)</h3><p>在这种隔离级别下，当事务B做出修改并提交后，只有事务A<strong>提交之后</strong>才能读到事务B修改的数据。<br>那可重复读解决了脏读和不可重复读问题，但是仍可能会发生幻读问题。<br>Q：Mysql中在update的时候会锁住当前行，但是为什么其他事务还能读到数据呢？<br>A：因为Mysql的innoDB有MVCC机制，可以使用快照读取数据，而不阻塞。那后面我会讲讲这个机制。  </p><h3 id="可串行化-SERIALIZABLE"><a href="#可串行化-SERIALIZABLE" class="headerlink" title="可串行化(SERIALIZABLE)"></a>可串行化(SERIALIZABLE)</h3><p>在这种隔离级别下，如果两个事务都是对数据进行修改，那么事务将以串行化的方式顺序执行，保证数据的安全。以下分四种情况讨论，假设事务A先于事务B：  </p><ul><li>如果事务A与事务B都是读取同一个数据，那这种情况下事务不会阻塞。因为没有读数据进行修改。</li><li>如果事务A先读取数据，这时事务B要修改这行数据，那么事务B会阻塞直到事务A提交。</li><li>如果事务A先修改数据，事务B要读取数据，那么事务B会阻塞直到事务A提交。  </li><li>如果事务A先修改数据，而事务B也要修改这行数据，那么事务B会等到事务A提交过后再进行修改。  </li></ul><p>那么综上所述，可串行化就是根据事务的先后顺序，来决定读取和修改数据的先后。可以简单理解成当前一个事务结束，后一个事务才开始，但是要注意的是，后一个事务其实早就开始了，只是被阻塞而已。<br>可串行化下，读取会获得<strong>表级的共享锁</strong>，因此读写相互就会阻塞。<br>那么在可串行化下，解决了脏读，不可重复读还有幻读问题，避免了并发事务中的读取与修改问题。  </p><h3 id="查看和修改事务隔离级别"><a href="#查看和修改事务隔离级别" class="headerlink" title="查看和修改事务隔离级别"></a>查看和修改事务隔离级别</h3><p>分别为系统隔离级别和会话隔离级别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@global.tx_isolation,@@tx_isolation;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| @@global.tx_isolation | @@tx_isolation  |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| REPEATABLE-READ       | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">1 row in set</span><br><span class="line"></span><br><span class="line">mysql&gt; set global transaction isolation level Repeatable Read;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; set session transaction isolation level Repeatable Read;</span><br><span class="line">Query OK, 0 rows affected</span><br></pre></td></tr></table></figure><h2 id="mysql如何实现隔离级别"><a href="#mysql如何实现隔离级别" class="headerlink" title="mysql如何实现隔离级别"></a>mysql如何实现隔离级别</h2><h3 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h3><p>首先我们要明白数据库遵循的是两段锁协议，即事务分为两个阶段，加锁和解锁。<br>加锁阶段，就是在相应的操作前要申请对应的锁。如在读操作前要申请S锁(share共享锁)，此时其他事务可以继续添加S锁，但不能添加X锁；又如在写操作前要申请X锁(排他锁)，此时其他事务不能添加任何锁。如果加锁不成功那么事务会等待直到加锁成功。<br>解锁阶段，一般在事务的提交时，会同时释放这个事务所申请的所有锁。<br>那么两段锁协议无法避免死锁，但是能保证事务并发调度是串行化的(注意不是隔离级别)，在数据备份与恢复时十分重要。 </p><h3 id="读已提交与可重复读的加锁方式"><a href="#读已提交与可重复读的加锁方式" class="headerlink" title="读已提交与可重复读的加锁方式"></a>读已提交与可重复读的加锁方式</h3><p>前面有提到过，mysql当中有表锁和行锁，表锁锁住的是整张表，例如可串行化下就是使用表锁，而行锁则是锁住有限的数据行。  </p><h4 id="读已提交-RC"><a href="#读已提交-RC" class="headerlink" title="读已提交(RC)"></a>读已提交(RC)</h4><p>在读已提交这个隔离级别中，假设事务A与事务B都要修改同一条数据，但是事务A先于事务B，那么根据前面我们知道，读已提交就是事务B只能读到事务A已经修改的数据。那么当事务A修改数据后，但是并未提交时，根据两段锁协议，事务A会在修改之前申请X锁，在提交之后释放，那么事务A一直不commit，则会导致事务B一直拿不到锁，直到超时。  </p><p>那么这里有一个值得注意的地方。那就是mysql如何确定要获取哪个行的行级锁呢？答案就是索引。假设id为索引，那么<code>update user set name = &quot;123&quot; where id = 1;</code>这条语句会根据id来找到相应的行，并获取这个行的行级锁。如果SQL语句的条件不是根据索引，那么此时mysql会给整个表的行加行级锁。<br>那么更有意思的出现了，mysql锁住所有行之后，会再次进行过滤，发现条件不满足时，会直接将该行的行级锁给释放，这违反了二段锁协议。这样确定了最后只有满足条件的行上加了锁。（详情见《高性能Mysql》）  </p><h4 id="可重复读-RR"><a href="#可重复读-RR" class="headerlink" title="可重复读(RR)"></a>可重复读(RR)</h4><p>这个是Mysql中innodb默认的隔离级别。我们知道这个级别下，同一个事务中的相同查询只会查到相同的数据。假设事务A做了两次查询，但是事务B和事务C同时在两次查询中间修改了数据，但是却返回了相同的数据。<br>如果使用锁来实现，又是如何实现呢？很简单，既然不可重复读的重点是update和delete，那么我在读取数据时直接加X锁，其他事务无法修改这些数据，那么就可以实现可重复读了。但是幻读又是怎么解决的呢？前面也简单提到过，可串行化的隔离级别，本质上就是通过读锁和写锁实现，只不过读写锁互斥，这就解决了幻读问题。<br>上面所讲的，就是使用<strong>悲观锁</strong>来实现隔离级别的，但是mysql出于性能考虑，RR级别下是采用乐观锁为基础的MVCC协议来实现。  </p><h3 id="MVCC协议"><a href="#MVCC协议" class="headerlink" title="MVCC协议"></a>MVCC协议</h3><h4 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h4><p>在谈这个协议之前，我们先来讲讲悲观锁和乐观锁。<br>前面的文章我也提到过，悲观锁是指认为所有数据随时都可能被修改，而乐观锁则是认为数据并不是随时会更新，所以它只会在更新时判断数据是否已经进行了更新。<br>那么乐观锁大多数是基于版本号来实现的。即在数据行中添加一个新的数据段version，通过这个version来判断读取的数据和当前数据库中的数据是否是同一个，也就是是否已经被修改过。  </p><h4 id="innoDB中MVCC的实现"><a href="#innoDB中MVCC的实现" class="headerlink" title="innoDB中MVCC的实现"></a>innoDB中MVCC的实现</h4><p>MVCC，全称为Multi-Version Concurrency Control，即多版本并发控制。MVCC没有固定的规范，所以每个数据库的实现可能会不同，这里讲讲innoDB中的实现。<br>在innoDB当中，每行记录都会由两个隐藏的列，一个是创建版本号，另一个是删除版本号。创建版本号是指创建一个数据行的事务版本号(事务版本号：事务开始时的系统版本号；系统版本号：每开始一个事务，系统版本号就会递增)。(ps.搁着套娃呢)<br>删除版本号则是delete操作时的版本号。<br>在RR级别下，各种操作如下：</p><ul><li>insert操作时，记录当前事务版本号为当前行的创建版本号。</li><li>delete操作时，记录当前事务版本号到删除版本号。</li><li>update操作时，先记录当前事务版本号到删除版本号，再增加一条记录，保存当前事务版本号为创建版本号。  </li><li>select操作时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或者&gt;当前事务版本号。即创建操作早于当前事务，删除操作晚于当前事务。</li></ul><p>那么通过MVCC协议，虽然会增加额外的存储空间，但是可以减少锁的使用，读取数据时不用加锁。<br>那这里又有一个有趣的点，那就是不管从书上还是网上，基本上是说RR级别解决了不可重复读，无法解决幻读。但是在mysql当中却是另一种情况。<br>假设事务A两次读取中间我们使用事务B增加一条数据，理论上来说事务A第二次读会读取到事务B中增加的行。<br>那么实验出结果，先是事务A读取一次数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | abc  |</span><br><span class="line">|  2 | asd  |</span><br><span class="line">|  3 | aaa  |</span><br><span class="line">+----+------+</span><br><span class="line">3 rows in set</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>好，我们读取到三条数据。此时打开另一个命令行添加一条数据进去。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into user values (4,&quot;aaa&quot;);</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | abc  |</span><br><span class="line">|  2 | asd  |</span><br><span class="line">|  3 | aaa  |</span><br><span class="line">|  4 | aaa  |</span><br><span class="line">+----+------+</span><br><span class="line">4 rows in set</span><br></pre></td></tr></table></figure><p>由于是自动提交，我没有开启新事务，这不要紧。接着我们返回事务A再次查询数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | abc  |</span><br><span class="line">|  2 | asd  |</span><br><span class="line">|  3 | aaa  |</span><br><span class="line">+----+------+</span><br><span class="line">3 rows in set</span><br></pre></td></tr></table></figure><p>发现依旧是三条数据。那么就很神奇了，mysql的RR级别似乎真的解决了幻读问题？？<br>那么我们就继续实验，我们知道目前数据库中存在四条数据，但是事务A读取的确实三条，那么此时我在事务A中修改新添加的数据行应该是失败的。那么我们就将事务A中的所有数据行修改下，看看它是否会影响到第四条数据。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update user set name = &quot;zer0e&quot;;</span><br><span class="line">Database changed</span><br><span class="line">Rows matched: 4  Changed: 4  Warnings: 0</span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">+----+-------+</span><br><span class="line">4 rows in set</span><br></pre></td></tr></table></figure>  <p>那么很明显，mysql直接提示有四条数据被修改，之后再读取就变成了四条数据，很显然幻读问题并没有真正解决。  </p><h4 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h4><p>那么到底为什么会出现上述情况？查阅资料后发现在RR级别下，通过MVCC协议，我们读取的数据变为可重复读，但是它可能是一个历史数据，那么我们称它为快照读，而读取到数据库最新数据的方式，我们称它为当前读。<br>select操作默认都是快照读，之后select都会返回这次快照读，因此实现了可重复读。<br>而对数据的更新操作(update,insert,delete)都是当前读，执行这几个操作会读取最新的记录，在事务中执行修改操作后会导致快照读变更。也就是我们所测试的那样。<br>如果我们要让select读取到当前读，我们可以手动进行加锁。<br>事务A先读取数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">+----+-------+</span><br><span class="line">4 rows in set</span><br></pre></td></tr></table></figure> <p>此时事务B新增一条记录(5,”aaa”)，这里我就不写了，我们来看看事务A再次读取的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">+----+-------+</span><br><span class="line">4 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user lock in share mode;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">|  5 | aaa   |</span><br><span class="line">+----+-------+</span><br><span class="line">5 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user for update;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">|  5 | aaa   |</span><br><span class="line">+----+-------+</span><br><span class="line">5 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">+----+-------+</span><br><span class="line">4 rows in set</span><br></pre></td></tr></table></figure>   <p>我们可以发现使用<code>for update</code>或者<code>lock in share mode</code>都可以获取到当前读。<br>所以综上，在RR级别下，幻读并未真正解决，而是因为快照读所以无法读取到最新数据。  </p><h3 id="解决幻读"><a href="#解决幻读" class="headerlink" title="解决幻读"></a>解决幻读</h3><p>那么在RR级别下innodb到底有没有解决幻读问题？通过什么解决？<br>答案是解决了，通过Next-Key锁来实现。</p><h4 id="Next-Key锁"><a href="#Next-Key锁" class="headerlink" title="Next-Key锁"></a>Next-Key锁</h4><p>Next-Key锁是行锁和间隙锁的合并，所谓间隙锁，就是在锁住当前行时，同时锁住当前索引的上下范围。<br>下面进行几项实验：  </p><h5 id="无主键表"><a href="#无主键表" class="headerlink" title="无主键表"></a>无主键表</h5><p>首先隔离级别定为RR，创建表t1，并插入几条间隔数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t1(id int,key id(id))engine=innodb;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1 values(1),(3),(5);</span><br><span class="line">Query OK, 3 rows affected</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  1 |</span><br><span class="line">|  3 |</span><br><span class="line">|  5 |</span><br><span class="line">+----+</span><br><span class="line">3 rows in set</span><br></pre></td></tr></table></figure>   <p>事务A通过for update锁住id=5的数据行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 where id=5 for update;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  5 |</span><br><span class="line">+----+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure>   <p>此时开启事务B，添加一个数据行在id=5前后。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t1 values(2);</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1 values(4);</span><br><span class="line">1049 - Unknown database &#x27;ate user set name = &quot;aaa&quot; where id = 5&#x27;</span><br><span class="line">terminated by user</span><br><span class="line">mysql&gt; use test;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; insert into t1 values(6);</span><br><span class="line"></span><br></pre></td></tr></table></figure> <p>我们会发现事务B会等待，直到事务A提交过后，事务B才插入成功。<br>那么Next-Key锁锁住的到底是多少行？其实它锁住的是它上下的一个范围。例如上述表中，对id=5的行进行加锁，那么innodb会把数据分为几个段，分别为(negative infinity,3]，(3,5]，(5,positive infinity]，都是左闭右开区间，那么对id=5的行添加行锁，同时会对(3,5]，(5,positive infinity]这两个区间添加gap锁(即间隙锁)，导致其他事务无法在这个区间进行更新操作。  </p><h5 id="有主键表"><a href="#有主键表" class="headerlink" title="有主键表"></a>有主键表</h5><p>上面的例子中没有主键，只是有一个普通索引而已。我们再来试一下有主键的例子。<br>创建表并插入几条数据：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t2(id int primary key)engine = innodb;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t2 values(1),(3),(5);</span><br><span class="line">Query OK, 3 rows affected</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure> <p>开启事务A并对id=5的行进行锁定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t2 where id = 5 for update;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  5 |</span><br><span class="line">+----+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure> <p>然后尝试在事务B中插入数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t2 values(4);</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t2 values(6);</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t2 where id = 5 for update;</span><br><span class="line">....</span><br></pre></td></tr></table></figure> <p>我们发现innodb并没有使用gap锁，而是只锁定了当前行。<br>那其实在innodb当中，<strong>行级锁是通过给索引上的索引项加锁来实现的，当查询的索引含有唯一属性时（主键索引，唯一索引），那么innodb会对next-key锁进行优化，使它降级为行级锁，锁住的不再是范围。</strong><br>所以如果把id不设置成主键，而是设置成唯一索引，也能达到相应的效果。  </p><h5 id="使用无索引字段"><a href="#使用无索引字段" class="headerlink" title="使用无索引字段"></a>使用无索引字段</h5><p>最后我们尝试下使用无索引字段来加锁会如何。<br>先创建表，并插入数据。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t3(id int,name varchar(10),key id(id))engine=innodb;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t3 values (1,&quot;a&quot;),(3,&quot;b&quot;),(5,&quot;c&quot;);</span><br><span class="line">Query OK, 3 rows affected</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure> <p>开启事务A对name=”c”的行加锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t3 where name = &quot;c&quot; for update;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  5 | c    |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set</span><br><span class="line"></span><br></pre></td></tr></table></figure> <p>在事务B中尝试加锁其他行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t3 where name = &quot;a&quot; for update;</span><br><span class="line">...</span><br><span class="line">mysql&gt; select * from t3 where name = &quot;b&quot; for update;</span><br><span class="line">...</span><br><span class="line">mysql&gt; insert into t3 values (4,&quot;d&quot;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure> <p>可以发现innodb其实对其他行都添加了锁，无法进行更新操作。那通过之前的结论，我们知道行级锁是通过索引加锁，条件中的列没有索引，因此innodb会给全表加上间隙锁。除非事务A提交，否则其他事务无法进行更新操作。  </p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>那之所以<a href="/2020/11/01/transaction_isolation/#innoDB%E4%B8%ADMVCC%E7%9A%84%E5%AE%9E%E7%8E%B0">前一个实验</a>“没有”解决幻读，原因在于快照读没有通过行级锁锁住当前行，表中也没有索引，条件语句中没有增加索引条件。我们可以通过添加索引并使用索引的当前读，来解决幻读问题。<br>所以在innodb当中，行级锁防止别的事务对当前行进行修改和删除，间隙锁防止其他事务新增数据，行级锁和间隙锁形成的next-key锁共同解决了RR级别下写的幻读问题。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那本篇的大致内容就写到这里了，本来只计划整理下基础知识，没想到越写越多，多整理了一个mysql中隔离级别的实现。这部分知识我之前是不太了解的，通过自己做下实验后，有种柳暗花明的感觉。也许这就是学习技术所带来的乐趣吧。  </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://dev.mysql.com/doc/">mysql参考手册</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对于数据库隔离级别，前前后后可能复习了好多遍，但是很经常就忘记，今天就简单整理下概念和实例，方便以后回顾。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://re0.top/tags/Java/"/>
    
      <category term="Mysql" scheme="https://re0.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>浅谈雪花算法</title>
    <link href="https://re0.top/2020/10/09/snowflake/"/>
    <id>https://re0.top/2020/10/09/snowflake/</id>
    <published>2020-10-09T06:40:00.000Z</published>
    <updated>2020-10-09T07:54:27.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近学习也有点陷入迷茫状态，不知道学些什么，也不知道写点什么。那就想起什么就写点啥，就当是重新学习。<br>今天要来讲的是分布式系统中常用的一种算法，雪花算法。 </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="什么是雪花算法"><a href="#什么是雪花算法" class="headerlink" title="什么是雪花算法"></a>什么是雪花算法</h2><p>雪花算法(snowflake)，它是Twitter公司使用的在分布式系统中生成唯一ID的一个算法，在2014年开源。<br>雪花算法是在高并发环境下生成为ID的算法，它能保证分布式环境下ID不重复，且基本有序递增，并且不依赖与其他的第三方库。  </p><h2 id="雪花算法的原理"><a href="#雪花算法的原理" class="headerlink" title="雪花算法的原理"></a>雪花算法的原理</h2><p>雪花算法的原理十分简单，它生成的ID由64bit组成，其中包括：</p><ul><li>1bit的标志位，由于二进制中最高为1的都是负数，并且生成的id一般都是整数，所以这一位通常为0.</li><li>41bit的时间戳，可以存储69年的时间，一般来说起始时间戳为系统上线的时间戳。</li><li>10bit的机器id，可以部署1024个节点。</li><li>12bit序列号，用来表示同一时间戳下生成的不同id，在同一个时间戳下可以表示4095个序列号。  </li></ul><p>因为刚好是64bit，所以在Java中刚好由long类型来存储。倒不如说是这个算法可能一开始就想好使用long类型来存储。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>当然最重要的还是如何生成ID啦，那生成的算法网上有很多，我就依照可能大家看的最多的代码，来讲讲自己的理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowFlake</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务上线时间 2020-10-09 00:00:00</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> startTimestamp = <span class="number">1602172800L</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 机器id所占位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">10L</span>;</span><br><span class="line">    <span class="comment">// 支持的最大机器id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = ~(-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    <span class="comment">//序列号占用的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line">    <span class="comment">//最大序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = ~(-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 机器ID向左移12位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line">    <span class="comment">// 时间截向左移22位(10+12)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//机器id，通过构造器传入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId;</span><br><span class="line">    <span class="comment">//序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">//上一次生成id的时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnowFlake</span><span class="params">(<span class="keyword">long</span> workerId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先机器id不能小于0或大于2^workerIdBits - 1</span></span><br><span class="line">        <span class="keyword">if</span> (workerId &lt; <span class="number">0</span> || workerId &gt; maxWorkerId)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;机器id不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法必须是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//如果当前时间小于上一次生成id的时间，说明系统时钟被回退过，需要抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;系统时间被回退&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前时间戳与上次生成id的时间戳相等，则增加序列</span></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp)&#123;</span><br><span class="line">            <span class="comment">// 这里是为了避免超出sequenceBits，即超出后会变成0</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="comment">//如果等于0说明溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 重新获取时间戳</span></span><br><span class="line">                timestamp = getNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不等于上次生成id的时间则序列号直接为0</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line">        <span class="comment">//通过位运算将三个部分进行拼接</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - startTimestamp) &lt;&lt; timestampLeftShift)</span><br><span class="line">                | (workerId &lt;&lt; workerIdShift)</span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞到下一个毫秒，直到获取新的时间戳</span></span><br><span class="line">    <span class="comment">// 由于获取下一个时间戳前进行了时钟回滚判断，所以这里不会长时间阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp)&#123;</span><br><span class="line">            timestamp = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>在代码中都有相应的注释。其中需要理解的可能是生成最大值的位运算，比如<code>maxWorkerId = ~(-1L &lt;&lt; workerIdBits);</code>。<br>首先负数在计算机中是使用补码进行表示，补码是负数绝对值的原码，取反码再加一。-1的绝对值是1，1的原码就是最后一位是1，取反码，就是0变1,1变0，再加1，就得到了全是1的二进制。<br>然后左移workerIdBits位，也就是12位，然后再取反，就得到了最大值，即1023。<br>那其实取最大值有两种写法，一种是<code>maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);</code>还有一种就是上面的写法，一种是异或一种是取反，得到的结果都是相同的。我个人也不确定哪种比较好，idea中提示我使用取反操作，那就当取反操作可能更好一些。当然这只是idea的建议，真正要区分的话还得看两种方法的底层速度比较，我对位运算不熟悉，希望有大佬能比较一下。  </p><h1 id="后续一些思考"><a href="#后续一些思考" class="headerlink" title="后续一些思考"></a>后续一些思考</h1><p>那雪花算法并不算难，通常情况下我们可以对雪花算法进行魔改。比如我可能不需要用到1024个节点啊，那么就把workIdBit减少，然后时间戳增加或者序列号增加。<br>又或者我这个系统可能用不到69年，那就可以适当减少时间戳比特位。<br>那还有就是workid的问题，即workid该怎么决定？那我们可以通过JVM传参，即-D选项，那如果是通过容器化部署的话，可能没办法传入不同参数，那可以通过某些规则来计算workid，比如可以通过该台机器的ip地址或者mac地址来计算workid，但是需要保证workid不重复，否则即使在并发不高的情况下，id也可能重复，至于实现，这里便不再展开，感兴趣的可以自己写写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近学习也有点陷入迷茫状态，不知道学些什么，也不知道写点什么。那就想起什么就写点啥，就当是重新学习。&lt;br&gt;今天要来讲的是分
      
    
    </summary>
    
    
      <category term="Java" scheme="https://re0.top/tags/Java/"/>
    
      <category term="算法" scheme="https://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="分布式" scheme="https://re0.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>谈谈设计模式</title>
    <link href="https://re0.top/2020/09/17/design_patterns/"/>
    <id>https://re0.top/2020/09/17/design_patterns/</id>
    <published>2020-09-17T08:40:00.000Z</published>
    <updated>2020-09-17T08:35:45.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设计模式是提高代码可读性的途径之一，面对不同的场景选择不同的设计模式，可以提高代码可读性，提高代码的可重用性还有可扩展性。接下来就讲讲什么是设计模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="何为设计模式"><a href="#何为设计模式" class="headerlink" title="何为设计模式"></a>何为设计模式</h2><p>设计模式是在面向对象语言中，思想都是一致的，而在面向过程语言，函数式编程的语言中讨论设计模式是没有意义的。所谓的设计模式，就是前面提到的，在面向对象编程中的一些”套路”，在面对不同需求场景时，可以选择不同的设计模式，来提高代码的可读性，重用性与扩展性。   </p><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>在GoF设计模式书籍中，共有23种设计模式。<br>而这23种设计模式又可以分为三大类型:  </p><ul><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>这一类设计模式的目的是为了创建对象。其中包括：  </p><ol><li><a href="/2020/08/13/abstract_factory_pattern/">抽象工厂模式</a></li><li><a href="/2020/08/12/factory_pattern/">工厂方法模式</a></li><li><a href="/2020/08/07/singleton/">单例模式</a></li><li><a href="/2020/09/02/prototype_pattern/">原型模式</a></li><li><a href="/2020/09/14/builder_pattern/">构建模式</a></li></ol><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>这一类设计模式是为了优化不同类，对象，接口之间的结构关系。其中包括：  </p><ol><li><a href="/2020/08/10/proxy_pattern/">代理模式</a></li><li><a href="/2020/08/17/decorator_pattern/">装饰器模式</a></li><li><a href="/2020/09/17/composite_pattern/">组合模式</a></li><li><a href="/2020/09/04/bridge_patterns/">桥接模式</a></li><li><a href="/2020/08/22/adapter_pattern">适配器模式</a></li><li><a href="/2020/08/16/facade_pattern/">外观模式</a></li><li><a href="/2020/09/17/flyweight_pattern/">享元模式</a></li></ol><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>这一类设计模式的目的是更好地实现类与类之间的交互还有算法的执行。包括：  </p><ol><li><a href="/2020/08/27/strategy_pattern/">策略模式</a></li><li><a href="/2020/08/17/command_pattern/">命令模式</a></li><li><a href="/2020/09/06/state_pattern/">状态模式</a></li><li><a href="/2020/09/05/chain_of_responsibility_pattern/">责任链模式</a></li><li><a href="/2020/09/05/interpreter_pattern">解释器模式</a></li><li><a href="/2020/08/08/observer/">观察者模式</a></li><li><a href="/2020/09/06/memento_pattern">备忘录模式</a></li><li><a href="/2020/08/27/iterator_pattern/">迭代器模式</a></li><li><a href="/2020/09/08/template_method_pattern/">模板方法模式</a></li><li><a href="/2020/09/08/visitor_pattern/">访问者模式</a></li><li><a href="/2020/08/12/mediator_pattern/">中介者模式</a></li></ol><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>以上就是全部设计的种类。因为随着不断进步，设计模式远不止这一些，但掌握这些设计模式在日常编程中就可以有效保证代码的健康。<br>算是挖了一个新的大坑吧，之后会陆陆续续写写这23种设计模式的理解与实现。<br>2020.08.07 单例模式<br>2020.08.08 观察者模式<br>2020.08.10 代理模式<br>2020.08.12 工厂方法模式,中介者模式<br>2020.08.13 抽象工厂模式<br>2020.08.16 外观模式<br>2020.08.17 命令模式,装饰器模式<br>2020.08.22 适配器模式<br>2020.08.27 策略模式,迭代器模式<br>2020.09.02 原型模式<br>2020.09.04 桥接模式<br>2020.09.05 责任链模式,解释器模式<br>2020.09.06 状态模式,备忘录模式<br>2020.09.08 模板方法模式,访问者模式<br>2020.09.14 构建模式<br>2020.09.17 享元模式,组合模式  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;设计模式是提高代码可读性的途径之一，面对不同的场景选择不同的设计模式，可以提高代码可读性，提高代码的可重用性还有可扩展性。接下来就讲讲什么是
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之组合模式</title>
    <link href="https://re0.top/2020/09/17/composite_pattern/"/>
    <id>https://re0.top/2020/09/17/composite_pattern/</id>
    <published>2020-09-17T08:00:00.000Z</published>
    <updated>2020-09-17T08:34:07.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇是23种设计模式的最后一篇了，不知不觉整理了一个月，其实应该快点整理完，每天一到两篇文章虽然量不多，但是写的时候其实挺累人。言归正传，本文来讲最后一种设计模式，组合模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>组合模式又称部分整体模式，它属于结构型模式，通常适用于有结构的系统，用于表示部分与整体层次。顺带一提，这里的有结构一般是树形结构。<br>那这个模式他模糊了简单元素与复杂元素的概念，可以统一使用同一个对象来进行操作。<br>那常见的场景有，上下级关系的构建，或者是文件系统的构建。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>那我们就来简单实现一个文件系统，我们知道一般文件系统包括普通文件和文件夹，但是学过操作系统后我们知道，文件夹其实是一种特殊的文件，在标志处不一样而已。那我们就来实现这个系统。<br>首先我们创建抽象类File</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>这里的display方法如果是文件夹是显示它所有文件，如果是文件则打印文件名。<br>接着我们创建Folder。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Folder</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;File&gt; fileList;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Folder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        fileList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (File file : fileList)&#123;</span><br><span class="line">            file.display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        fileList.add(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        fileList.remove(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>接着我们创建两种类型的文件，文本文件和图片文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFile</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文本文件，文件名为：&quot;</span> + <span class="keyword">super</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageFile</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;图片文件，文件名为：&quot;</span> + <span class="keyword">super</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>最后我们创建客户端调用试试，我们创建一个这样的文件系统，有一个文件夹all，包含1.txt，1.jpg，还有一个文件夹1；然后文件夹1中还有2.txt和2.jpg。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Folder all = <span class="keyword">new</span> Folder(<span class="string">&quot;all&quot;</span>);</span><br><span class="line">        File txt1 = <span class="keyword">new</span> TextFile(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        File txt2 = <span class="keyword">new</span> TextFile(<span class="string">&quot;2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        File jpg1 = <span class="keyword">new</span> ImageFile(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">        File jpg2 = <span class="keyword">new</span> ImageFile(<span class="string">&quot;2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Folder folder1 = <span class="keyword">new</span> Folder(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        all.add(txt1);</span><br><span class="line">        all.add(jpg1);</span><br><span class="line">        all.add(folder1);</span><br><span class="line"></span><br><span class="line">        folder1.add(txt2);</span><br><span class="line">        folder1.add(jpg2);</span><br><span class="line"></span><br><span class="line">        all.display();</span><br><span class="line">        folder1.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <p>那这里就有个问题，就是总文件夹中打印文件名时，会把子文件夹中的一并打印出来，那么这时候我们可以在抽象类中设置一个type属性，依照参数，比如-r表示是否递归，来判断是否递归打印。通过判断type来实现，这里就不实现了，感兴趣的可以自行实现。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>那组合模式的优点是可以定义一些分层次的对象，添加组件也很简单。其次就是客户端调用简单。最后就是符合开闭原则，添加新的组件不用修改原有代码。<br>那缺点在于整个系统会变得抽象，维护成本增加，其次就是违反依赖导致原则，就像上文的例子一样，客户端要创建文件夹时，需要依赖的是Folder实现类，而不是File抽象类。  </p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>那设计模式这个系列到这里基本上是告一段落了，前前后后整理这个系列花了一个多月的时间，那接下来可能还是会写一些自己感兴趣的话题或者技术，有时间的话博客还是会坚持写下去的。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这篇是23种设计模式的最后一篇了，不知不觉整理了一个月，其实应该快点整理完，每天一到两篇文章虽然量不多，但是写的时候其实挺累人。言归正传，本
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之享元模式</title>
    <link href="https://re0.top/2020/09/17/flyweight_pattern/"/>
    <id>https://re0.top/2020/09/17/flyweight_pattern/</id>
    <published>2020-09-17T07:00:00.000Z</published>
    <updated>2020-09-17T07:42:35.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文谈谈享元模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>享元模式属于结构型模式，它主要是缓存重复的对象，以减少内存的消耗，这些相同的对象往往需要重复的使用，如果不对其进行缓存，可能会导致内存溢出。那享元模式一般配合工厂模式一起使用。<br>常见的应用场景有Java中的String，在创建String时判断缓存池里是否有这个字符串，有的话直接返回，没有才进行创建。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>享元模式中有以下几个角色：</p><ul><li>抽象享元类（Flyweight）：接口或者抽象类，声明公共方法。</li><li>具体享元类（ConcreteFlyweight）：实现抽象享元类，结合单例模式提供唯一的对象。 </li><li>享元工厂类（FlyweightFactory）：用来创建及管理享元对象，可以参考工厂模式。  </li></ul><p>这里我们举个简单例子，一般商店里的物品不止一样，那么我们可以把同一个名称的商品作为共享的。<br>我们创建抽象接口FlyWeight</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyWeight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>接着我们可以创建商品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">implements</span> <span class="title">FlyWeight</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;卖出一件商品: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>创建工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWeightFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Item&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getItem</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        Item item = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(name))&#123;</span><br><span class="line">            item = map.get(name);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            item = <span class="keyword">new</span> Item(name);</span><br><span class="line">            map.put(name,item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>那么客户端调用也很简单，商品从工厂类中获取即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FlyWeightFactory flyWeightFactory = <span class="keyword">new</span> FlyWeightFactory();</span><br><span class="line">        Item milk1 = flyWeightFactory.getItem(<span class="string">&quot;牛奶&quot;</span>);</span><br><span class="line">        Item milk2 = flyWeightFactory.getItem(<span class="string">&quot;牛奶&quot;</span>);</span><br><span class="line">        System.out.println(milk1 == milk2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        milk1.sell();</span><br><span class="line">        milk2.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>那以上例子还可以继续细化，比如Item类作为抽象类，而具体商品则继承它，那具体商品就可以有更多的属性，比如价格，批次等等。那在工厂类添加的时候可能需要根据传入名称来创建类，具体可以使用反射机制，这里就不再展开。<br>总而言之，享元模式中共享的对象是同一个，实现这个模式常常结合工厂模式，单例模式来使用，需要注意的是在多线程中需要使用线程安全的容器来存储对象。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>享元模式优点很明显，可以减少重复对象的创建，减低内存使用率。<br>那缺点可能就是需要区分外部状态与内部状态，内部状态不随环境改变，可共享，外部状态岁环境改变，不能共享。也就是上文例子中name作为外部状态可改变，如果再添加一个无法更改的属性比如价格，那么就是内部状态，无法被更改。<br>所以享元模式一定程度上增加了系统的复杂性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文谈谈享元模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之构建模式</title>
    <link href="https://re0.top/2020/09/14/builder_pattern/"/>
    <id>https://re0.top/2020/09/14/builder_pattern/</id>
    <published>2020-09-14T07:00:00.000Z</published>
    <updated>2020-09-14T08:29:53.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>构建模式又称建造模式，建造者模式等等。<br>本篇来简单谈谈这种设计模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>构建模式(Builder Pattern)，由于存在多种叫法，为了统一名称，统一写作Builder模式。它属于创建型模式，是使用一个个对象构建复杂对象的设计模式。<br>它的意图在于拆分复杂对象，使得可以由子对象生成，子对象相对稳定，通过组合子对象来构造复杂对象。<br>那使用的场景通常是对象的内部结构较为复杂或者内部属性相互依赖。<br>那Java中常见的就是各种Builder，例如StringBuilder。<br>那项目中何时使用这种设计模式呢？通常来说，当类的构造函数非常多时(大于4个)可以改用Builder模式来创建对象。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>先来讲讲Builder模式中的几个角色：</p><ul><li>Builder角色：一个接口，规范产品对象中各个子对象的构建。</li><li>ConcreteBuilder：具体的实现类，提供产品的实例。</li><li>Director：负责调用具体的ConcreteBuilder来创建对象。</li><li>Product：即我们需要构建的复杂对象。  </li></ul><p>我们就用这几个角色来写写基础的Builder模式。<br>首先我们定义我们的Product对象中，有两个string担任它的子对象。那我们可以写出代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>首先这个类并没有构造器，而是采用javabean的方式来设置对象，这有利于我们使用builder来创建这个对象。<br>接着我们写抽象的Builder接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildId</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>这个接口中有两个方法用来创建product对象中的子对象。而第三个方法则是来获取一个创建完成的product对象。<br>接着是ConcreteBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setId(<span class="string">&quot;01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setName(<span class="string">&quot;产品1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>接着是导演类，用来引导ConcreteBuilder创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        builder.buildId();</span><br><span class="line">        builder.buildName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>我们通过把builder传递给导演类，然后调用导演类的construct方法，就可以创建一个product对象到builder对象中，获取就可以得到这个product对象。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        director.construct();</span><br><span class="line">        Product product = builder.getProduct();</span><br><span class="line"></span><br><span class="line">        System.out.println(product.getId());</span><br><span class="line">        System.out.println(product.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>如此我们便简单实现了Builder模式。<br>那实际场景中哪里使用到了Builder模式呢？<br>MyBatis中就大量使用了这个模式。原生的mybatis(不整合spring)在SqlSessionFactory中使用了XMLConfigBuilder，得益于builder模式，mybatis隐藏了解析XML文件的细节，我们只需要少量的基本参数(比如地址，账号密码等)，就可以使用。其他参数根据用户是否提供，如果没有就使用默认参数。因此mybatis使用成本大大降低。</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>所以当我们在编写复杂类，或者是一个大型框架时，可以采用Builder模式，将大量参数通过这个模式来创建对象，而不是使用构造函数来创建。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>那Builder模式的优点在于可以精确控制产品的创建，开发者可以根据需要创建出想要的对象。其次，客户端可以不知道产品内部实现细节，结果与过程解耦。最后添加新的Builder无需修改原有代码，Director是针对Builder进行编程的，所以方便系统扩展，符合开闭原则。<br>那缺点就是产品之间需要有共同点，有所限制。其次就是如果内部复杂，会导致Builder过多，系统臃肿。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;构建模式又称建造模式，建造者模式等等。&lt;br&gt;本篇来简单谈谈这种设计模式。  &lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; 
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList扩容之后内存地址会发生改变吗？</title>
    <link href="https://re0.top/2020/09/13/arraylist_resize/"/>
    <id>https://re0.top/2020/09/13/arraylist_resize/</id>
    <published>2020-09-13T06:20:00.000Z</published>
    <updated>2020-09-13T08:01:20.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>那标题的这个内容，是我在面试时候的一道问题。那这篇文章我们来讲讲ArrayList的扩充机制以及扩容之后会发生什么样的改变。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>首先使用过Java的基本上都用过ArrayList，那它是一个数组队列，其实现了List接口，那ArrayList的底层是一个动态数组。我们来看看默认的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>这里的源码基于JDK1.8，那其他的源码这里就不贴了，我直接进行总结：</p><ul><li>ArrayList内部有一个数组，使用默认的构造函数时，默认容量为0。而在1.6以前，默认容量为10.</li><li>当第一次插入元素时，容量分配10，之后会以1.5倍的增长。</li></ul><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>还是简单写写ArrayList的扩容机制。首先默认的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>我们可以知道默认的容量是0。那扩容机制一定会发生在add操作中，我们查看add方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>ensureCapacityInternal是确保内部容量，也就是确保数组容量应该是现有数据数量加上1。接着跟进</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>那这里就很明朗，calculateCapacity通过传入的需要容量与当前数组容量，计算出需要的最小容量，其中如果数组为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，那么就返回DEFAULT_CAPACITY与需要容量的最大值，DEFAULT_CAPACITY为10。<br>因此当第一次扩容时，容量被设置为10，其余情况最小容量都为传入的所需容量。<br>接着是ensureExplicitCapacity方法，当最小容量大于当前数组长度时，进行扩容操作，即grow方法，我们接着跟进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>首先新容量的计算方式为oldCapacity + (oldCapacity &gt;&gt; 1)，那么相当于oldCapacity + 0.5 * oldCapacity，即1.5倍的原容量，而采用位运算则更快。其次这里判断了元素的最大个数，源码里的注释解释道，原因是因为jvm允许数组的最大大小为Integer.MAX_VALUE - 8，超过这个值会OutOfMemory，因此MAX_ARRAY_SIZE设置为Integer.MAX_VALUE - 8避免溢出。<br>最后是调用Arrays.copyOf方法来获得一个新的数组，而copyOf方法是调用System.arraycopy方法，这个方法是个native方法，就不是我们所关心的内容了。<br>至此，扩容的机制就是如果是默认构造器初始化，则设置当前容量为10，当所需容量大于10时，会进行1.5倍的扩容，以此类推。</p><h2 id="ArrayList对象分配在哪"><a href="#ArrayList对象分配在哪" class="headerlink" title="ArrayList对象分配在哪?"></a>ArrayList对象分配在哪?</h2><p>首先ArrayList是new出来的，那么毫无疑问，它存放在堆中，而变量存放在栈中，指向堆中的对象。就比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure> <p>其中list变量在栈中，指向堆中的某个ArrayList实例对象。<br>那数组也不例外，因为数组也是个对象，所以内部的elementData也存放在堆当中。  </p><h2 id="那扩容之后的地址改变吗"><a href="#那扩容之后的地址改变吗" class="headerlink" title="那扩容之后的地址改变吗?"></a>那扩容之后的地址改变吗?</h2><p>这就是标题所提到的问题，先说结论，肯定是不变的。我们先来做个试验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>通过对add下断点，我们可以发现list的id是不变的，因此内存当中的地址是不改变的。通过步入调试，可以发现elementData的id发生了改变，因为我们可以得出结论，ArrayList扩容之后地址不会发生改变，发生改变的是内部数组的内存地址。<br>那为什么不变呢？根本原因在于list变量所指向的对象是同一个，很好理解，尽管实例内部的elementData一直在改变，但实例中只是某个变量的指向不断在改变而已，并没有重新分配内存，只有当内部方法重新new本类时，list所指向的内存地址才会发生改变。<br>因此，<strong>大部分通过内部变量引用机制进行扩容的容器并不会改变自身的内存地址</strong>。<br>但一些基础容器，例如数组，通过Arrays.copyOf方法进行扩容时，因为数组内存是有序的，所以需要重新分配内存，导致地址发生改变。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇谈了谈ArrayList的扩容机制以及扩容之后地址的改变情况。那相似的问题，比如hashmap扩容等等我们都知道了，因为其内部有引用，所以只是内部变量的地址发生改变，其本身的内存地址不发生改变，对象还是同一个。<br>那以上就是这篇文章的内容，如有问题，望指出。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;那标题的这个内容，是我在面试时候的一道问题。那这篇文章我们来讲讲ArrayList的扩充机制以及扩容之后会发生什么样的改变。&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://re0.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java内存模型</title>
    <link href="https://re0.top/2020/09/13/jmm/"/>
    <id>https://re0.top/2020/09/13/jmm/</id>
    <published>2020-09-13T05:00:00.000Z</published>
    <updated>2020-09-13T06:25:32.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想写一篇文章，由于涉及到Java内存的知识，就先来写写前置知识。那本篇就来说说JVM的基础，Java内存区域与Java内存模式（JMM）。<br>ps. 本篇基本上想到哪里说到哪里，并无什么先后顺序。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p>那我相信学习过JVM的同学基本上都知道JVM将运行时内存划分为几个区域。总体上可以分为两类：线程共享区域与线程私有区域。<br>其中线程共享区域分为方法区和堆。线程私有区域有虚拟机栈，本地方法栈还有程序计数器。</p><h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>方法区中主要用于存储已经被虚拟机加载的类信息，常量还有一些静态变量。注意，方法区中有一个运行时常量池，用于存储编译器生成的各种字面量与符号引用，加载过后存放在此。</p><h3 id="堆（Java-Heap）"><a href="#堆（Java-Heap）" class="headerlink" title="堆（Java Heap）"></a>堆（Java Heap）</h3><p>这个区域是我们常见的区域，主要是存放对象实例，几乎所有的对象实例都在这里分配内存，也是GC的主要区域。</p><h3 id="虚拟机栈（JVM-Stacks）"><a href="#虚拟机栈（JVM-Stacks）" class="headerlink" title="虚拟机栈（JVM Stacks）"></a>虚拟机栈（JVM Stacks）</h3><p>是线程私有的区域，与线程同时创建，每一个方法执行的时候都会创建一个叫做栈帧的东西来存储方法的变量表，动态链接方法，返回值等等信息，并存放在栈中，调用方法就是入栈，而调用结束就是出栈操作。 </p><h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><p>在操作系统中我们也学习过这个概念。主要是代表当前线程所执行的字节码行号的指示器。运行代码时，通过改变计数器的值来选取下一条需要执行的字节码指令。</p><h3 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h3><p>主要是用到的Native方法相关的信息，一般来说无需关心。</p><h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p>那由于JVM运行程序是以线程为单位，所以每个线程创建的时候JVM会为其创建一个工作内存，用于存储变量私有的数据，而JMM规定所有变量都存储在主内存，主内存是共享的，所有线程都能访问，因此对变量的操作是这样的，首先从主内存中拷贝变量到工作内存中，修改变量完成后再写回主内存中。所以线程共享的变量必须通过主内存来完成。  </p><h2 id="Java内存区域与JMM"><a href="#Java内存区域与JMM" class="headerlink" title="Java内存区域与JMM"></a>Java内存区域与JMM</h2><p>这两个是不同的概念，JMM是一组规则，控制程序中各个变量在共享区域与私有区域的访问方式。他们的相似点在于都存在共享区域与私有区域，JMM中主内存属于共享区域，从内存模型来讲应该包括了方法区与堆，私有区域同理。</p><h2 id="JMM如何保证原子性，可见性，有序性"><a href="#JMM如何保证原子性，可见性，有序性" class="headerlink" title="JMM如何保证原子性，可见性，有序性"></a>JMM如何保证原子性，可见性，有序性</h2><p>那在Java当中我们要保证原子性可以使用锁来实现，工作内存与主内存的可见性可以使用synchronized关键字或者volatile关键字，而因为指令重排导致的有序性问题可以使用volatile关键字。<br>那仅靠synchronized和volatile关键字会使得代码变得十分繁琐。因此JMM还提供一个叫做happens-before的原则来保证三性。规则的内容如下：</p><ul><li>程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</li><li>锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。</li><li>volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</li><li>线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见</li><li>传递性 A先于B ，B先于C 那么A必然先于C</li><li>线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</li><li>线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</li><li>对象终结规则 对象的构造函数执行，结束先于finalize()方法</li></ul><p>以上八条原则使得某些情况下需要任何同步就可达到预期效果。</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>被volatile所修饰的变量对所有线程都是可见的，即对该变量的写操作都能立即反应到其他工作内存中。但这个关键字并不保证操作的原子性。因为对变量的修改往往需要两个步骤，读与更新，如果不能保证这个两个操作是同时进行，那么线程就是不安全的。<br>那volatile关键字的工作原理又是什么？其实就是线程在写一个volatile变量时，会把线程所对应的工作内存设置为无效的，那该线程只能从主内存中重新读取变量。其次就是禁止指令重排，之前在写单例模式的时候也提到过，对实例的赋值其实并不是我们预想的那样，例如<code>instance = new A();</code>，我们期待是先分配内存，然后初始化对象，最后进行赋值，那JVM可能会将该代码指令进行重排序，即先分配空间，然后赋值，最后再初始化对象。<br>那在单线程中是完全ok的，没什么影响，那在多线程中就可能出现一致性问题，也就是出现了线程安全问题。那禁止指令的重排，我们就可以使用volatile关键字来解决。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇主要是简单讲讲Java的内存区域与内存模型(JMM)，其中我们需要知道JMM其实就是一组规则，意图是解决并发编程中出现的线程安全问题，它提供了happen-before原则，并且我们还可以使用synchronized或volatile，来帮助我们实现多线程环境下的原子性，可见性，有序性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;想写一篇文章，由于涉及到Java内存的知识，就先来写写前置知识。那本篇就来说说JVM的基础，Java内存区域与Java内存模式（JMM）。&lt;
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://re0.top/tags/Java/"/>
    
  </entry>
  
</feed>
