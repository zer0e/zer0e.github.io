<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zer0&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://re0.top/"/>
  <updated>2020-09-17T08:35:45.057Z</updated>
  <id>http://re0.top/</id>
  
  <author>
    <name>Zer0</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谈谈设计模式</title>
    <link href="http://re0.top/2020/09/17/design_patterns/"/>
    <id>http://re0.top/2020/09/17/design_patterns/</id>
    <published>2020-09-17T08:40:00.000Z</published>
    <updated>2020-09-17T08:35:45.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设计模式是提高代码可读性的途径之一，面对不同的场景选择不同的设计模式，可以提高代码可读性，提高代码的可重用性还有可扩展性。接下来就讲讲什么是设计模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="何为设计模式"><a href="#何为设计模式" class="headerlink" title="何为设计模式"></a>何为设计模式</h2><p>设计模式是在面向对象语言中，思想都是一致的，而在面向过程语言，函数式编程的语言中讨论设计模式是没有意义的。所谓的设计模式，就是前面提到的，在面向对象编程中的一些”套路”，在面对不同需求场景时，可以选择不同的设计模式，来提高代码的可读性，重用性与扩展性。   </p><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>在GoF设计模式书籍中，共有23种设计模式。<br>而这23种设计模式又可以分为三大类型:  </p><ul><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>这一类设计模式的目的是为了创建对象。其中包括：  </p><ol><li><a href="/2020/08/13/abstract_factory_pattern/">抽象工厂模式</a></li><li><a href="/2020/08/12/factory_pattern/">工厂方法模式</a></li><li><a href="/2020/08/07/singleton/">单例模式</a></li><li><a href="/2020/09/02/prototype_pattern/">原型模式</a></li><li><a href="/2020/09/14/builder_pattern/">构建模式</a></li></ol><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>这一类设计模式是为了优化不同类，对象，接口之间的结构关系。其中包括：  </p><ol><li><a href="/2020/08/10/proxy_pattern/">代理模式</a></li><li><a href="/2020/08/17/decorator_pattern/">装饰器模式</a></li><li><a href="/2020/09/17/composite_pattern/">组合模式</a></li><li><a href="/2020/09/04/bridge_patterns/">桥接模式</a></li><li><a href="/2020/08/22/adapter_pattern">适配器模式</a></li><li><a href="/2020/08/16/facade_pattern/">外观模式</a></li><li><a href="/2020/09/17/flyweight_pattern/">享元模式</a></li></ol><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>这一类设计模式的目的是更好地实现类与类之间的交互还有算法的执行。包括：  </p><ol><li><a href="/2020/08/27/strategy_pattern/">策略模式</a></li><li><a href="/2020/08/17/command_pattern/">命令模式</a></li><li><a href="/2020/09/06/state_pattern/">状态模式</a></li><li><a href="/2020/09/05/chain_of_responsibility_pattern/">责任链模式</a></li><li><a href="/2020/09/05/interpreter_pattern">解释器模式</a></li><li><a href="/2020/08/08/observer/">观察者模式</a></li><li><a href="/2020/09/06/memento_pattern">备忘录模式</a></li><li><a href="/2020/08/27/iterator_pattern/">迭代器模式</a></li><li><a href="/2020/09/08/template_method_pattern/">模板方法模式</a></li><li><a href="/2020/09/08/visitor_pattern/">访问者模式</a></li><li><a href="/2020/08/12/mediator_pattern/">中介者模式</a></li></ol><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>以上就是全部设计的种类。因为随着不断进步，设计模式远不止这一些，但掌握这些设计模式在日常编程中就可以有效保证代码的健康。<br>算是挖了一个新的大坑吧，之后会陆陆续续写写这23种设计模式的理解与实现。<br>2020.08.07 单例模式<br>2020.08.08 观察者模式<br>2020.08.10 代理模式<br>2020.08.12 工厂方法模式,中介者模式<br>2020.08.13 抽象工厂模式<br>2020.08.16 外观模式<br>2020.08.17 命令模式,装饰器模式<br>2020.08.22 适配器模式<br>2020.08.27 策略模式,迭代器模式<br>2020.09.02 原型模式<br>2020.09.04 桥接模式<br>2020.09.05 责任链模式,解释器模式<br>2020.09.06 状态模式,备忘录模式<br>2020.09.08 模板方法模式,访问者模式<br>2020.09.14 构建模式<br>2020.09.17 享元模式,组合模式  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;设计模式是提高代码可读性的途径之一，面对不同的场景选择不同的设计模式，可以提高代码可读性，提高代码的可重用性还有可扩展性。接下来就讲讲什么是
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之组合模式</title>
    <link href="http://re0.top/2020/09/17/composite_pattern/"/>
    <id>http://re0.top/2020/09/17/composite_pattern/</id>
    <published>2020-09-17T08:00:00.000Z</published>
    <updated>2020-09-17T08:34:07.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇是23种设计模式的最后一篇了，不知不觉整理了一个月，其实应该快点整理完，每天一到两篇文章虽然量不多，但是写的时候其实挺累人。言归正传，本文来讲最后一种设计模式，组合模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>组合模式又称部分整体模式，它属于结构型模式，通常适用于有结构的系统，用于表示部分与整体层次。顺带一提，这里的有结构一般是树形结构。<br>那这个模式他模糊了简单元素与复杂元素的概念，可以统一使用同一个对象来进行操作。<br>那常见的场景有，上下级关系的构建，或者是文件系统的构建。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>那我们就来简单实现一个文件系统，我们知道一般文件系统包括普通文件和文件夹，但是学过操作系统后我们知道，文件夹其实是一种特殊的文件，在标志处不一样而已。那我们就来实现这个系统。<br>首先我们创建抽象类File<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>这里的display方法如果是文件夹是显示它所有文件，如果是文件则打印文件名。<br>接着我们创建Folder。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Folder</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;File&gt; fileList;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Folder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        fileList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (File file : fileList)&#123;</span><br><span class="line">            file.display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        fileList.add(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        fileList.remove(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>接着我们创建两种类型的文件，文本文件和图片文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFile</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"文本文件，文件名为："</span> + <span class="keyword">super</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageFile</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"图片文件，文件名为："</span> + <span class="keyword">super</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>最后我们创建客户端调用试试，我们创建一个这样的文件系统，有一个文件夹all，包含1.txt，1.jpg，还有一个文件夹1；然后文件夹1中还有2.txt和2.jpg。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Folder all = <span class="keyword">new</span> Folder(<span class="string">"all"</span>);</span><br><span class="line">        File txt1 = <span class="keyword">new</span> TextFile(<span class="string">"1.txt"</span>);</span><br><span class="line">        File txt2 = <span class="keyword">new</span> TextFile(<span class="string">"2.txt"</span>);</span><br><span class="line"></span><br><span class="line">        File jpg1 = <span class="keyword">new</span> ImageFile(<span class="string">"1.jpg"</span>);</span><br><span class="line">        File jpg2 = <span class="keyword">new</span> ImageFile(<span class="string">"2.jpg"</span>);</span><br><span class="line"></span><br><span class="line">        Folder folder1 = <span class="keyword">new</span> Folder(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        all.add(txt1);</span><br><span class="line">        all.add(jpg1);</span><br><span class="line">        all.add(folder1);</span><br><span class="line"></span><br><span class="line">        folder1.add(txt2);</span><br><span class="line">        folder1.add(jpg2);</span><br><span class="line"></span><br><span class="line">        all.display();</span><br><span class="line">        folder1.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  </p><p>那这里就有个问题，就是总文件夹中打印文件名时，会把子文件夹中的一并打印出来，那么这时候我们可以在抽象类中设置一个type属性，依照参数，比如-r表示是否递归，来判断是否递归打印。通过判断type来实现，这里就不实现了，感兴趣的可以自行实现。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>那组合模式的优点是可以定义一些分层次的对象，添加组件也很简单。其次就是客户端调用简单。最后就是符合开闭原则，添加新的组件不用修改原有代码。<br>那缺点在于整个系统会变得抽象，维护成本增加，其次就是违反依赖导致原则，就像上文的例子一样，客户端要创建文件夹时，需要依赖的是Folder实现类，而不是File抽象类。  </p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>那设计模式这个系列到这里基本上是告一段落了，前前后后整理这个系列花了一个多月的时间，那接下来可能还是会写一些自己感兴趣的话题或者技术，有时间的话博客还是会坚持写下去的。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这篇是23种设计模式的最后一篇了，不知不觉整理了一个月，其实应该快点整理完，每天一到两篇文章虽然量不多，但是写的时候其实挺累人。言归正传，本
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之享元模式</title>
    <link href="http://re0.top/2020/09/17/flyweight_pattern/"/>
    <id>http://re0.top/2020/09/17/flyweight_pattern/</id>
    <published>2020-09-17T07:00:00.000Z</published>
    <updated>2020-09-17T07:42:35.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文谈谈享元模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>享元模式属于结构型模式，它主要是缓存重复的对象，以减少内存的消耗，这些相同的对象往往需要重复的使用，如果不对其进行缓存，可能会导致内存溢出。那享元模式一般配合工厂模式一起使用。<br>常见的应用场景有Java中的String，在创建String时判断缓存池里是否有这个字符串，有的话直接返回，没有才进行创建。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>享元模式中有以下几个角色：</p><ul><li>抽象享元类（Flyweight）：接口或者抽象类，声明公共方法。</li><li>具体享元类（ConcreteFlyweight）：实现抽象享元类，结合单例模式提供唯一的对象。 </li><li>享元工厂类（FlyweightFactory）：用来创建及管理享元对象，可以参考工厂模式。  </li></ul><p>这里我们举个简单例子，一般商店里的物品不止一样，那么我们可以把同一个名称的商品作为共享的。<br>我们创建抽象接口FlyWeight<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyWeight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>接着我们可以创建商品类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">implements</span> <span class="title">FlyWeight</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"卖出一件商品: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>创建工厂类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWeightFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Item&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getItem</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        Item item = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(name))&#123;</span><br><span class="line">            item = map.get(name);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            item = <span class="keyword">new</span> Item(name);</span><br><span class="line">            map.put(name,item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>那么客户端调用也很简单，商品从工厂类中获取即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FlyWeightFactory flyWeightFactory = <span class="keyword">new</span> FlyWeightFactory();</span><br><span class="line">        Item milk1 = flyWeightFactory.getItem(<span class="string">"牛奶"</span>);</span><br><span class="line">        Item milk2 = flyWeightFactory.getItem(<span class="string">"牛奶"</span>);</span><br><span class="line">        System.out.println(milk1 == milk2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        milk1.sell();</span><br><span class="line">        milk2.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>那以上例子还可以继续细化，比如Item类作为抽象类，而具体商品则继承它，那具体商品就可以有更多的属性，比如价格，批次等等。那在工厂类添加的时候可能需要根据传入名称来创建类，具体可以使用反射机制，这里就不再展开。<br>总而言之，享元模式中共享的对象是同一个，实现这个模式常常结合工厂模式，单例模式来使用，需要注意的是在多线程中需要使用线程安全的容器来存储对象。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>享元模式优点很明显，可以减少重复对象的创建，减低内存使用率。<br>那缺点可能就是需要区分外部状态与内部状态，内部状态不随环境改变，可共享，外部状态岁环境改变，不能共享。也就是上文例子中name作为外部状态可改变，如果再添加一个无法更改的属性比如价格，那么就是内部状态，无法被更改。<br>所以享元模式一定程度上增加了系统的复杂性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文谈谈享元模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之构建模式</title>
    <link href="http://re0.top/2020/09/14/builder_pattern/"/>
    <id>http://re0.top/2020/09/14/builder_pattern/</id>
    <published>2020-09-14T07:00:00.000Z</published>
    <updated>2020-09-14T08:29:53.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>构建模式又称建造模式，建造者模式等等。<br>本篇来简单谈谈这种设计模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>构建模式(Builder Pattern)，由于存在多种叫法，为了统一名称，统一写作Builder模式。它属于创建型模式，是使用一个个对象构建复杂对象的设计模式。<br>它的意图在于拆分复杂对象，使得可以由子对象生成，子对象相对稳定，通过组合子对象来构造复杂对象。<br>那使用的场景通常是对象的内部结构较为复杂或者内部属性相互依赖。<br>那Java中常见的就是各种Builder，例如StringBuilder。<br>那项目中何时使用这种设计模式呢？通常来说，当类的构造函数非常多时(大于4个)可以改用Builder模式来创建对象。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>先来讲讲Builder模式中的几个角色：</p><ul><li>Builder角色：一个接口，规范产品对象中各个子对象的构建。</li><li>ConcreteBuilder：具体的实现类，提供产品的实例。</li><li>Director：负责调用具体的ConcreteBuilder来创建对象。</li><li>Product：即我们需要构建的复杂对象。  </li></ul><p>我们就用这几个角色来写写基础的Builder模式。<br>首先我们定义我们的Product对象中，有两个string担任它的子对象。那我们可以写出代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>首先这个类并没有构造器，而是采用javabean的方式来设置对象，这有利于我们使用builder来创建这个对象。<br>接着我们写抽象的Builder接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildId</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>这个接口中有两个方法用来创建product对象中的子对象。而第三个方法则是来获取一个创建完成的product对象。<br>接着是ConcreteBuilder<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setId(<span class="string">"01"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setName(<span class="string">"产品1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着是导演类，用来引导ConcreteBuilder创建对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        builder.buildId();</span><br><span class="line">        builder.buildName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>我们通过把builder传递给导演类，然后调用导演类的construct方法，就可以创建一个product对象到builder对象中，获取就可以得到这个product对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        director.construct();</span><br><span class="line">        Product product = builder.getProduct();</span><br><span class="line"></span><br><span class="line">        System.out.println(product.getId());</span><br><span class="line">        System.out.println(product.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>如此我们便简单实现了Builder模式。<br>那实际场景中哪里使用到了Builder模式呢？<br>MyBatis中就大量使用了这个模式。原生的mybatis(不整合spring)在SqlSessionFactory中使用了XMLConfigBuilder，得益于builder模式，mybatis隐藏了解析XML文件的细节，我们只需要少量的基本参数(比如地址，账号密码等)，就可以使用。其他参数根据用户是否提供，如果没有就使用默认参数。因此mybatis使用成本大大降低。</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>所以当我们在编写复杂类，或者是一个大型框架时，可以采用Builder模式，将大量参数通过这个模式来创建对象，而不是使用构造函数来创建。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>那Builder模式的优点在于可以精确控制产品的创建，开发者可以根据需要创建出想要的对象。其次，客户端可以不知道产品内部实现细节，结果与过程解耦。最后添加新的Builder无需修改原有代码，Director是针对Builder进行编程的，所以方便系统扩展，符合开闭原则。<br>那缺点就是产品之间需要有共同点，有所限制。其次就是如果内部复杂，会导致Builder过多，系统臃肿。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;构建模式又称建造模式，建造者模式等等。&lt;br&gt;本篇来简单谈谈这种设计模式。  &lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; 
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList扩容之后内存地址会发生改变吗？</title>
    <link href="http://re0.top/2020/09/13/arraylist_resize/"/>
    <id>http://re0.top/2020/09/13/arraylist_resize/</id>
    <published>2020-09-13T06:20:00.000Z</published>
    <updated>2020-09-13T08:01:20.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>那标题的这个内容，是我在面试时候的一道问题。那这篇文章我们来讲讲ArrayList的扩充机制以及扩容之后会发生什么样的改变。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>首先使用过Java的基本上都用过ArrayList，那它是一个数组队列，其实现了List接口，那ArrayList的底层是一个动态数组。我们来看看默认的构造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><p>这里的源码基于JDK1.8，那其他的源码这里就不贴了，我直接进行总结：</p><ul><li>ArrayList内部有一个数组，使用默认的构造函数时，默认容量为0。而在1.6以前，默认容量为10.</li><li>当第一次插入元素时，容量分配10，之后会以1.5倍的增长。</li></ul><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>还是简单写写ArrayList的扩容机制。首先默认的构造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><p>我们可以知道默认的容量是0。那扩容机制一定会发生在add操作中，我们查看add方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><p>ensureCapacityInternal是确保内部容量，也就是确保数组容量应该是现有数据数量加上1。接着跟进<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><p>那这里就很明朗，calculateCapacity通过传入的需要容量与当前数组容量，计算出需要的最小容量，其中如果数组为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，那么就返回DEFAULT_CAPACITY与需要容量的最大值，DEFAULT_CAPACITY为10。<br>因此当第一次扩容时，容量被设置为10，其余情况最小容量都为传入的所需容量。<br>接着是ensureExplicitCapacity方法，当最小容量大于当前数组长度时，进行扩容操作，即grow方法，我们接着跟进：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><p>首先新容量的计算方式为oldCapacity + (oldCapacity &gt;&gt; 1)，那么相当于oldCapacity + 0.5 * oldCapacity，即1.5倍的原容量，而采用位运算则更快。其次这里判断了元素的最大个数，源码里的注释解释道，原因是因为jvm允许数组的最大大小为Integer.MAX_VALUE - 8，超过这个值会OutOfMemory，因此MAX_ARRAY_SIZE设置为Integer.MAX_VALUE - 8避免溢出。<br>最后是调用Arrays.copyOf方法来获得一个新的数组，而copyOf方法是调用System.arraycopy方法，这个方法是个native方法，就不是我们所关心的内容了。<br>至此，扩容的机制就是如果是默认构造器初始化，则设置当前容量为10，当所需容量大于10时，会进行1.5倍的扩容，以此类推。</p><h2 id="ArrayList对象分配在哪"><a href="#ArrayList对象分配在哪" class="headerlink" title="ArrayList对象分配在哪?"></a>ArrayList对象分配在哪?</h2><p>首先ArrayList是new出来的，那么毫无疑问，它存放在堆中，而变量存放在栈中，指向堆中的对象。就比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure> </p><p>其中list变量在栈中，指向堆中的某个ArrayList实例对象。<br>那数组也不例外，因为数组也是个对象，所以内部的elementData也存放在堆当中。  </p><h2 id="那扩容之后的地址改变吗"><a href="#那扩容之后的地址改变吗" class="headerlink" title="那扩容之后的地址改变吗?"></a>那扩容之后的地址改变吗?</h2><p>这就是标题所提到的问题，先说结论，肯定是不变的。我们先来做个试验：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>通过对add下断点，我们可以发现list的id是不变的，因此内存当中的地址是不改变的。通过步入调试，可以发现elementData的id发生了改变，因为我们可以得出结论，ArrayList扩容之后地址不会发生改变，发生改变的是内部数组的内存地址。<br>那为什么不变呢？根本原因在于list变量所指向的对象是同一个，很好理解，尽管实例内部的elementData一直在改变，但实例中只是某个变量的指向不断在改变而已，并没有重新分配内存，只有当内部方法重新new本类时，list所指向的内存地址才会发生改变。<br>因此，<strong>大部分通过内部变量引用机制进行扩容的容器并不会改变自身的内存地址</strong>。<br>但一些基础容器，例如数组，通过Arrays.copyOf方法进行扩容时，因为数组内存是有序的，所以需要重新分配内存，导致地址发生改变。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇谈了谈ArrayList的扩容机制以及扩容之后地址的改变情况。那相似的问题，比如hashmap扩容等等我们都知道了，因为其内部有引用，所以只是内部变量的地址发生改变，其本身的内存地址不发生改变，对象还是同一个。<br>那以上就是这篇文章的内容，如有问题，望指出。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;那标题的这个内容，是我在面试时候的一道问题。那这篇文章我们来讲讲ArrayList的扩充机制以及扩容之后会发生什么样的改变。&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://re0.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java内存模型</title>
    <link href="http://re0.top/2020/09/13/jmm/"/>
    <id>http://re0.top/2020/09/13/jmm/</id>
    <published>2020-09-13T05:00:00.000Z</published>
    <updated>2020-09-13T06:25:32.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想写一篇文章，由于涉及到Java内存的知识，就先来写写前置知识。那本篇就来说说JVM的基础，Java内存区域与Java内存模式（JMM）。<br>ps. 本篇基本上想到哪里说到哪里，并无什么先后顺序。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p>那我相信学习过JVM的同学基本上都知道JVM将运行时内存划分为几个区域。总体上可以分为两类：线程共享区域与线程私有区域。<br>其中线程共享区域分为方法区和堆。线程私有区域有虚拟机栈，本地方法栈还有程序计数器。</p><h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>方法区中主要用于存储已经被虚拟机加载的类信息，常量还有一些静态变量。注意，方法区中有一个运行时常量池，用于存储编译器生成的各种字面量与符号引用，加载过后存放在此。</p><h3 id="堆（Java-Heap）"><a href="#堆（Java-Heap）" class="headerlink" title="堆（Java Heap）"></a>堆（Java Heap）</h3><p>这个区域是我们常见的区域，主要是存放对象实例，几乎所有的对象实例都在这里分配内存，也是GC的主要区域。</p><h3 id="虚拟机栈（JVM-Stacks）"><a href="#虚拟机栈（JVM-Stacks）" class="headerlink" title="虚拟机栈（JVM Stacks）"></a>虚拟机栈（JVM Stacks）</h3><p>是线程私有的区域，与线程同时创建，每一个方法执行的时候都会创建一个叫做栈帧的东西来存储方法的变量表，动态链接方法，返回值等等信息，并存放在栈中，调用方法就是入栈，而调用结束就是出栈操作。 </p><h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><p>在操作系统中我们也学习过这个概念。主要是代表当前线程所执行的字节码行号的指示器。运行代码时，通过改变计数器的值来选取下一条需要执行的字节码指令。</p><h3 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h3><p>主要是用到的Native方法相关的信息，一般来说无需关心。</p><h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p>那由于JVM运行程序是以线程为单位，所以每个线程创建的时候JVM会为其创建一个工作内存，用于存储变量私有的数据，而JMM规定所有变量都存储在主内存，主内存是共享的，所有线程都能访问，因此对变量的操作是这样的，首先从主内存中拷贝变量到工作内存中，修改变量完成后再写回主内存中。所以线程共享的变量必须通过主内存来完成。  </p><h2 id="Java内存区域与JMM"><a href="#Java内存区域与JMM" class="headerlink" title="Java内存区域与JMM"></a>Java内存区域与JMM</h2><p>这两个是不同的概念，JMM是一组规则，控制程序中各个变量在共享区域与私有区域的访问方式。他们的相似点在于都存在共享区域与私有区域，JMM中主内存属于共享区域，从内存模型来讲应该包括了方法区与堆，私有区域同理。</p><h2 id="JMM如何保证原子性，可见性，有序性"><a href="#JMM如何保证原子性，可见性，有序性" class="headerlink" title="JMM如何保证原子性，可见性，有序性"></a>JMM如何保证原子性，可见性，有序性</h2><p>那在Java当中我们要保证原子性可以使用锁来实现，工作内存与主内存的可见性可以使用synchronized关键字或者volatile关键字，而因为指令重排导致的有序性问题可以使用volatile关键字。<br>那仅靠synchronized和volatile关键字会使得代码变得十分繁琐。因此JMM还提供一个叫做happens-before的原则来保证三性。规则的内容如下：</p><ul><li>程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</li><li>锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。</li><li>volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</li><li>线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见</li><li>传递性 A先于B ，B先于C 那么A必然先于C</li><li>线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</li><li>线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</li><li>对象终结规则 对象的构造函数执行，结束先于finalize()方法</li></ul><p>以上八条原则使得某些情况下需要任何同步就可达到预期效果。</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>被volatile所修饰的变量对所有线程都是可见的，即对该变量的写操作都能立即反应到其他工作内存中。但这个关键字并不保证操作的原子性。因为对变量的修改往往需要两个步骤，读与更新，如果不能保证这个两个操作是同时进行，那么线程就是不安全的。<br>那volatile关键字的工作原理又是什么？其实就是线程在写一个volatile变量时，会把线程所对应的工作内存设置为无效的，那该线程只能从主内存中重新读取变量。其次就是禁止指令重排，之前在写单例模式的时候也提到过，对实例的赋值其实并不是我们预想的那样，例如<code>instance = new A();</code>，我们期待是先分配内存，然后初始化对象，最后进行赋值，那JVM可能会将该代码指令进行重排序，即先分配空间，然后赋值，最后再初始化对象。<br>那在单线程中是完全ok的，没什么影响，那在多线程中就可能出现一致性问题，也就是出现了线程安全问题。那禁止指令的重排，我们就可以使用volatile关键字来解决。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇主要是简单讲讲Java的内存区域与内存模型(JMM)，其中我们需要知道JMM其实就是一组规则，意图是解决并发编程中出现的线程安全问题，它提供了happen-before原则，并且我们还可以使用synchronized或volatile，来帮助我们实现多线程环境下的原子性，可见性，有序性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;想写一篇文章，由于涉及到Java内存的知识，就先来写写前置知识。那本篇就来说说JVM的基础，Java内存区域与Java内存模式（JMM）。&lt;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://re0.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之访问者模式</title>
    <link href="http://re0.top/2020/09/08/visitor_pattern/"/>
    <id>http://re0.top/2020/09/08/visitor_pattern/</id>
    <published>2020-09-08T07:00:00.000Z</published>
    <updated>2020-09-08T08:02:10.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇来讲讲行为型模式的最后一篇，访问者模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>访问者模式，我们使用一个访问者类来访问数据对象，通常是为了不污染数据对象类，而实现的关键是在数据对象类中提供一个接待访问者的接口。<br>那这种设计模式了除了不污染原类，很大一部分原因是为了将数据结构与操作相分离。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>由于这种设计模式在开发中很少用，一般是在框架或者源码中才会使用到。所以这里我就简单实现一下概念。<br>首先访问者模式中有几个角色：</p><ul><li>Visitor（抽象访问者）：抽象类或接口，对每一种具体元素类ConcreteElement声明一个操作方法，由具体访问者去实现。  </li><li>ConcreteVisitor（具体访问者）：实现抽象访问者的方法。</li><li>Element（抽象元素）：一般会定义一个Accept方法，接受一个visitor对象作为参数。</li><li>ConcreteElement（具体元素）：具体实现抽象元素。</li><li>ObjectStructure（对象结构）：可以是任意一种数据结构，能枚举它包含的元素，并提供一个接口，允许visitor进行访问。  </li></ul><p>下面我将简单写写代码实现。<br>首先我们先定义抽象访问者吧。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>然后是具体访问者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorA</span> <span class="keyword">implements</span> <span class="title">Visitor</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问 ElementA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问 ElementB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着定义抽象元素，有一个accept方法接收一个visitor对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>然后是具体元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>我们定义一个对象结构来存放所有的元素，并且定义accept方法来逐个访问元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Element element: elements)&#123;</span><br><span class="line">            element.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(Element element)</span></span>&#123;</span><br><span class="line">        elements.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(Element element)</span></span>&#123;</span><br><span class="line">        elements.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>我们编写客户端调用试试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义元素及访问者</span></span><br><span class="line">        Element elementA = <span class="keyword">new</span> ConcreteElementA();</span><br><span class="line">        Element elementB = <span class="keyword">new</span> ConcreteElementB();</span><br><span class="line">        Visitor visitor = <span class="keyword">new</span> ConcreteVisitorA();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单个元素访问</span></span><br><span class="line">        elementA.accept(visitor);</span><br><span class="line">        elementB.accept(visitor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多个元素访问</span></span><br><span class="line">        ObjectStructure objectStructure = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line">        objectStructure.addElement(elementA);</span><br><span class="line">        objectStructure.addElement(elementB);</span><br><span class="line">        objectStructure.accept(visitor);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>那所以是否定义ObjectStructure取决于你是否需要同时访问多个元素。<br>书写代码之后，我第一感觉就是耦合较高，访问者与元素之间相互依赖极高。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>访问者模式的优点在于添加新的访问操作较为方便，无需修改元素类，修改抽象访问者及其具体访问者即可，并且类的职责更加清晰，元素类负责数据，而访问者负责访问，符合单一职责原则。<br>而缺点就是添加元素类就十分麻烦，添加一个元素类后，需要修改每个访问者的代码，违背了开闭原则。并且在依赖上，具体访问者依赖于具体元素类，没有依赖抽象对象。最后，为了供访问者访问，有时候元素类不得不暴露己类的某些细节，封装性被破坏。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇来讲讲行为型模式的最后一篇，访问者模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之模板方法模式</title>
    <link href="http://re0.top/2020/09/08/template_method_pattern/"/>
    <id>http://re0.top/2020/09/08/template_method_pattern/</id>
    <published>2020-09-08T06:00:00.000Z</published>
    <updated>2020-09-08T08:03:08.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇聊聊模板方法模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>模板方法模式属于行为型模式，它定义一个模板结构，然后让其子类去实现。其主要作用是提高代码的复用性，并且在不改变模板的情况下子类能重写方法。<br>那这种设计模式就十分常见了，在父类中定义执行顺序，子类再去具体的去实现，这就是模板方法模式。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>举个例子，比如我们平常去超市买东西，基本上分为几个步骤，拿购物车或篮子，挑选商品，结算。那就用这个例子来写写代码。  </p><h2 id="未使用模板方法模式"><a href="#未使用模板方法模式" class="headerlink" title="未使用模板方法模式"></a>未使用模板方法模式</h2><p>首先我们一般来说我们是先定义一个父类，然后子类再去实现父类方法。也就是<strong>没使用模板方法模式</strong>时，我们可能会这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿购物车</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getShoppingCart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挑选商品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">selectGoods</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全流程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>那在子类当中，我们可能这么写<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingByOnlinePay</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getShoppingCart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取购物车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectGoods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"挑选商品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用网上支付"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getShoppingCart();</span><br><span class="line">        selectGoods();</span><br><span class="line">        pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>那这样写就是在抽象类中不写任何逻辑，所有的实现都在子类中实现，如果后续有问题也较好发现，但我们可以发现，其实shopping方法是固定的，也就是流程固定，那么我们这些代码是不是可以移动到抽象类中呢？是的，可以，这就是模板方法模式。</p><h2 id="使用模板方法"><a href="#使用模板方法" class="headerlink" title="使用模板方法"></a>使用模板方法</h2><p>我们重写下抽象类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿购物车</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getShoppingCart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挑选商品</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">selectGoods</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结算</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全流程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getShoppingCart();</span><br><span class="line">        <span class="keyword">this</span>.selectGoods();</span><br><span class="line">        <span class="keyword">this</span>.pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>我们将子类需要重写的方法定义为protected，因为这些方法不需要暴露给其他类，只需要子类自己实现即可，然后我们把购物流程在抽象类中以final修饰，因为流程固定不需要修改。<br>我们接着写现金付款和网上支付两种结算方式的类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingByOnlinePay</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">getShoppingCart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取购物车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">selectGoods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"挑选商品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用网上支付"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingByCash</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">getShoppingCart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取购物车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">selectGoods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"挑选商品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用现金结算"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>那这里调用就很简单，我就不写了，直接调用shopping方法即可。<br>如此，我们就使用模板方法模式实现了这个简单的例子。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>模板方法模式具有良好的封装性，即把一成不变的代码封装在父类当中，而子类去实现基本方法的逻辑，并且扩展性良好，符合开闭原则和单一职责原则。那最重要的还是复用了重复代码。<br>那缺点嘛，可能就是实现类都需要单独的子类去实现，可能会增加类的数量，但我个人认为这个其实严格来说不能说是缺点，除非是实现的种类存在几十种上百种。当然，仁者见仁智者见智，算不算缺点只有在用到的时候才能知道。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇聊聊模板方法模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之备忘录模式</title>
    <link href="http://re0.top/2020/09/06/memento_pattern/"/>
    <id>http://re0.top/2020/09/06/memento_pattern/</id>
    <published>2020-09-06T07:00:00.000Z</published>
    <updated>2020-09-06T07:58:33.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇来谈谈备忘录模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>备忘录模式保存对象的某个状态，以便当需要时恢复这个状态，它属于行为型模式。<br>它又称快照模式或token模式。它的意图是在不破坏封装的条件下，将对象的状态保存下来，并存储，并且可以在未来的某个时刻恢复。<br>这个模式涉及三个角色：</p><ul><li>备忘录(Memento)：将发起人对象的内部状态存储起来，并且可以保护不被发起人以外的对象所读取。</li><li>发起人(Originator)：创建一个含有内部状态的备忘录对象，并存储自己的内部状态。</li><li>负责人(Caretaker)：负责保存备忘录对象，不检查备忘录对象的内容。 </li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们先创建备忘录(Memento)，这里对象的内部状态我们使用string来表示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>创建发起人(Originator)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">savaStateToMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>创建负责人(Caretaker)，负责保存备忘录对象，这里用list存储一系列状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">retrieveMemento</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveMemento</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        mementoList.add(memento);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>创建客户端，并设置一下状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">        Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line"></span><br><span class="line">        originator.setState(<span class="string">"state 1"</span>);</span><br><span class="line">        caretaker.saveMemento(originator.savaStateToMemento());</span><br><span class="line"></span><br><span class="line">        originator.setState(<span class="string">"state 2"</span>);</span><br><span class="line">        caretaker.saveMemento(originator.savaStateToMemento());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        originator.getStateFromMemento(caretaker.retrieveMemento(<span class="number">0</span>));</span><br><span class="line">        System.out.println(originator.getState());</span><br><span class="line"></span><br><span class="line">        originator.getStateFromMemento(caretaker.retrieveMemento(<span class="number">1</span>));</span><br><span class="line">        System.out.println(originator.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>这里我们设置两个状态，并拍摄快照，最后依次恢复快照查看状态。  </p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>上文也提过，这个模式适合拍摄快照，例如游戏存档，可以将玩家的某个状态存储，并适时的时候恢复。还有就是提供可回滚的操作，等等。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>那备忘录模式的优点是给用户提供了一种可恢复的机制，可以较为方便地回到某个时间点。其次就是调用者无需关心如何保存状态。<br>那缺点也很明显，就是占用内存或空间，如果类的状态和变量过多，则会消耗一定的资源。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇来谈谈备忘录模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之状态模式</title>
    <link href="http://re0.top/2020/09/06/state_pattern/"/>
    <id>http://re0.top/2020/09/06/state_pattern/</id>
    <published>2020-09-06T07:00:00.000Z</published>
    <updated>2020-09-06T07:32:06.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇来谈谈状态模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>状态模式属于行为型模式，在这个模式中类的行为是根据类的状态发生改变的。在类中维护一个状态变量，当其改变时类的行为就发生改变，看上去就跟改变了类本身一样。<br>那状态模式涉及的角色有：  </p><ul><li>环境(context)：上下文，通常定义客户端可用的接口，内部维护一个状态实例，根据这个状态做出不一样的行为。</li><li>抽象状态(state)：一个接口，用于封装环境(context)对象的状态</li><li>具体状态(concreteState)：实现抽象状态。</li></ul><p>那这个模式常见的场景就是可以替代条件语句，if，switch等等，避免语句过长。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这个模式还是比较简单的，我们就写写上面提到的几个角色<br>我们先定义state接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>然后是具体的state<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateA</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对应StateA的操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateB</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对应StateB的操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>然后定义环境，用于客户端的调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用户需要的接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state.handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>最后编写客户端调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        State stateA = <span class="keyword">new</span> ConcreteStateA();</span><br><span class="line">        State stateB = <span class="keyword">new</span> ConcreteStateB();</span><br><span class="line"></span><br><span class="line">        context.setState(stateA);</span><br><span class="line">        context.request();</span><br><span class="line"></span><br><span class="line">        context.setState(stateB);</span><br><span class="line">        context.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>可以发现，通过设置context的状态可以实现不同的操作。看上去就像context对象本身发生改变一样。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>最后来讲讲优缺点。<br>状态模式的优点有，把实现的细节隐藏，客户端只需要设置状态，无需关心内部的实现，并且可以去除大量的逻辑判断语句，可读性更高。<br>而缺点在于当状态增多时，类的数量会增加，并且当增加新的状态类时，context可能会做出修改，不符合开闭原则。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇来谈谈状态模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之解释器模式</title>
    <link href="http://re0.top/2020/09/05/interpreter_pattern/"/>
    <id>http://re0.top/2020/09/05/interpreter_pattern/</id>
    <published>2020-09-05T08:00:00.000Z</published>
    <updated>2020-09-05T08:49:42.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接下来讲讲解释器模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>解释器模式属于行为型模式。它实现了一个表达式的接口，用于解释上下文。比如正则表达式解析，SQL解析等等。<br>这种模式应用上较少，那在框架上用的还是比较多的，比如上文提到了正则表达式，还有XML解析，SQL解析等等都有着应用。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>那我们就用一个简单的例子来实现这个模式。<br>先来讲讲解释器模式中的几个角色：  </p><ul><li>抽象表达式(AbstractExpression)：是所有终结符表达式和非终结符表达式的公共父类。</li><li>终结符表达式(TerminalExpression)：指的是与终结符相关的表达式。</li><li>非终结符表达式(NonterminalExpression)：即没有终结符的表达式，通常一个解释器模式中，由少数几个终结符表达式与非终结符表达式构成。</li><li>Context：上下文，一般是存储需要解释的语句。  </li></ul><p>比如我要实现一个简易的计算器。<br>那我们先定义抽象表达式接口Interpreter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interpreter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>然后定义非终结符表达式，这里就是解析数字<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberInterpreter</span> <span class="keyword">implements</span> <span class="title">Interpreter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberInterpreter</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberInterpreter</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = Integer.parseInt(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>然后是终结符表达式，这里就是运算符<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddInterpreter</span> <span class="keyword">implements</span> <span class="title">Interpreter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Interpreter first,second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddInterpreter</span><span class="params">(Interpreter first, Interpreter second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"+"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first.interpret() + second.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>我们直接写一个客户端调用一下试试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String express = <span class="string">"2 + 3"</span>;</span><br><span class="line">        String[] keyWords = express.split(<span class="string">" "</span>);</span><br><span class="line">        String operator = <span class="string">"+"</span>;</span><br><span class="line">        Interpreter[] nums = <span class="keyword">new</span> Interpreter[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String keyword : keyWords)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = Integer.parseInt(keyword);</span><br><span class="line">                nums[index++] = <span class="keyword">new</span> NumberInterpreter(tmp);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                operator = keyword;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (operator.equals(<span class="string">"+"</span>))&#123;</span><br><span class="line">            Interpreter add = <span class="keyword">new</span> AddInterpreter(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">            System.out.println(add.interpret());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>我们就简单实现了加法运算，那值得注意的有以下几点：</p><ul><li>在main方法中的解析应该转移到工具类当中，客户端应该直接调用工具类。</li><li>既然符号是终结符表达式，那么以上的express应该改为后缀表达式”2 3 +”，然后通过栈来求整个表达式的值。</li></ul><p>那么以上几点就是我的修改建议，感兴趣的朋友可以接着写下去，实现其他运算，加上工具类的封装。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>解释器模式的优点在于可扩展性良好，并且十分灵活，当我们新增一个表达式时，原有代码无需修改。<br>那缺点在于如果语法过于复杂，解析起来会十分麻烦，类的数量会急剧增加，导致难以维护。其次由于解释器模式使用了大量的循环和递归，当面对较复杂语句时执行速度会受到影响。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解释器模式为语言的设计和实现提供了一种解决方案，通过定义表达式来解析语言中的语句，在项目中的使用频率不是很高，但如要实现一门语言或者解析语句，那这个模式就应用的很广泛。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;接下来讲讲解释器模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之责任链模式</title>
    <link href="http://re0.top/2020/09/05/chain_of_responsibility_pattern/"/>
    <id>http://re0.top/2020/09/05/chain_of_responsibility_pattern/</id>
    <published>2020-09-05T07:00:00.000Z</published>
    <updated>2020-09-05T07:41:39.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文来谈谈责任链模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>责任链模式属于行为型模式。正如名字所说一样，对象是一个链式的结构，当请求到达对象时，如果第一个对象不能处理这个请求，则将请求传递给下一个对象，以此类推。<br>责任链可以是直线型，也可以是环形，又或者是树形。那这种设计模式简化了请求传递的复杂度，请求只要传递给责任链上，并且无需关心如何处理请求，所以责任链模式将请求者与接受者解耦了。<br>那我们常见的场景有：</p><ul><li>js中的事件冒泡，事件会依次向上传递。</li><li>jvm中的类加载机制也是责任链模式，但会一直指派到最顶级的类加载。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>责任链模式中有两个角色：</p><ul><li>抽象处理者(Handler)：抽象对象或者接口。定义一个处理请求的接口。</li><li>具体处理者(ConcreteHandler)：具体的请求处理者，接收请求后选择是否处理请求，如不处理，则传递给下一位。  </li></ul><p>我们先用简单的例子：<br>首先创建handler：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下一个处理者</span></span><br><span class="line">    <span class="keyword">protected</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getNextHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextHandler</span><span class="params">(Handler nextHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handlerRequest</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>随后我们创建具体的处理者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandlerA</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRequest</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"A"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"handler A 处理请求"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getNextHandler() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"handler A 无法处理请求，转交给下一个handler"</span>);</span><br><span class="line">            getNextHandler().handlerRequest(name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"所有handler都无法处理请求"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandlerB</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRequest</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"B"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"handler B 处理请求"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getNextHandler() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"handler B 无法处理请求，转交给下一个handler"</span>);</span><br><span class="line">            getNextHandler().handlerRequest(name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"所有handler都无法处理请求"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>这里我们重写handlerRequest方法，当这个具体处理者可以处理请求时，直接处理请求，不能处理时，我们传给责任链中下一个处理者，如果没有下一个处理者就退出。<br>最后是客户端，其中客户端中我们需要显式地构建责任链。我们编写客户端试试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Handler handlerA = <span class="keyword">new</span> ConcreteHandlerA();</span><br><span class="line">        Handler handlerB = <span class="keyword">new</span> ConcreteHandlerB();</span><br><span class="line"></span><br><span class="line">        handlerA.setNextHandler(handlerB);</span><br><span class="line"></span><br><span class="line">        handlerA.handlerRequest(<span class="string">"C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>这里我们将handlerA 的下一个责任链对象设置为handlerB，这样所有的handler形成了一个链表，我们只需将所有请求发送给handlerA，就无需关心请求是如何进行处理是谁处理的。  </p><h2 id="常见需求场景"><a href="#常见需求场景" class="headerlink" title="常见需求场景"></a>常见需求场景</h2><p>所以责任链模式适用于一级一级传递的需求当中。比如日志管理，那我们常见的日志级别就是一级一级的，有debug，info，warning，error等等的级别，当日志级别设为较低一级时，它以上的日志都会打印。<br>又比如权限的管理，比如操作的级别有很多级，对服务器越危险的操作就必须有更高权限的人来确认操作，那根据操作的级别，把请求传递给责任链，权限不足就交给上一级，直到这个操作进行确认。<br>这里感兴趣的同学可以动手写写简单的实现代码。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>那责任链模式能一定程序上降低请求的发送者与处理者之间的耦合，不用关心请求发送给哪个处理者。其次对于指派处理者较为灵活，可以改变链中的顺序和成员，动态增加和删除。<br>那缺点在于不能保证请求一定被接收，其次就是环的解决，如果处理不当，有可能导致循环调用。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文来谈谈责任链模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之桥接模式</title>
    <link href="http://re0.top/2020/09/04/bridge_patterns/"/>
    <id>http://re0.top/2020/09/04/bridge_patterns/</id>
    <published>2020-09-04T07:00:00.000Z</published>
    <updated>2020-09-04T09:00:20.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>桥接模式其实是很少在项目中使用的设计模式，难度可以说是很大的。但是理解桥接模式能更深入的理解面向对象编程。<br>那这篇就来讲讲这个模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们先来看看维基百科上的定义：  </p><blockquote><p>桥接模式是软件设计模式中最复杂的模式之一，它把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。  </p></blockquote><p>听起来就很复杂，而且竟然说是最复杂的设计模式。<br>桥的作用就是连接河的两岸，那么桥接是不是也有关系呢？是的，桥接就是为了连接两个独立结构，而这两个独立结构可以独立的发生变化。<br>那这个设计模式的目的就是为了将抽象部分与实现部分分离，使他们可以独立的变化，这个抽象与实现部分就是我们上面所说的两个独立结构。<br>总结一下，这个设计模式解决的有以下几点： </p><ul><li>如果系统需要在抽象化和具体化之间更加灵活的转换，避免了两个层次之间建立静态的继承关系，此时通过桥接模式能是他们建立联系。</li><li>当使用多层次继承时，会导致系统类的增多导致类爆炸，那使用桥接模式是不错的选择。</li><li>当一个类可能有多个变化的方向时，并且这几个变化方向都各自独自，那桥接模式就排上用场了。  </li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>由于图床实在是不方便，所以我没有放UML图，我这里还是简单实现个小例子吧。<br>首先桥接模式涉及到的角色有以下几个：  </p><ul><li>Abstraction：抽象接口</li><li>RefinedAbstraction：拓展Abstraction</li><li>Implementor：具体的实现接口，它和RefinedAbstraction中的接口不一定相同</li><li>ConcreteImplementor：实现Implementor接口 </li></ul><p>一个简单小例子，比如乘坐交通工具出门旅游，可能有多个目的地的变化，比如杭州，上海等，然后出门的交通工具也可以不同，比如小轿车自驾，或者做飞机。<br>那以上代码如何去实现桥接呢？<br>首先我们定义Implementor，那对应到这个例子就是交通工具。为啥先定义具体接口呢？原因是因为在Abstraction会将Implementor作为对象注入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ride</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接下来是具体的交通工具(ConcreteImplementor)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ride</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"乘坐小轿车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirPlane</span> <span class="keyword">implements</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ride</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"乘坐飞机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>那接下来就是抽象对象接口(Abstraction)，这例子中就是我们的目的地。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Vehicle vehicle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">City</span><span class="params">(Vehicle vehicle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vehicle = vehicle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>具体的目的地<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HangZhou</span> <span class="keyword">extends</span> <span class="title">City</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HangZhou</span><span class="params">(Vehicle vehicle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(vehicle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.vehicle.ride();</span><br><span class="line">        System.out.println(<span class="string">"到杭州旅游"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShangHai</span> <span class="keyword">extends</span> <span class="title">City</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShangHai</span><span class="params">(Vehicle vehicle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(vehicle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.vehicle.ride();</span><br><span class="line">        System.out.println(<span class="string">"到上海旅游"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  </p><p>我们写个测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        City city = <span class="keyword">new</span> ShangHai(<span class="keyword">new</span> AirPlane());</span><br><span class="line">        city.visit();</span><br><span class="line"></span><br><span class="line">        City city1 = <span class="keyword">new</span> HangZhou(<span class="keyword">new</span> Car());</span><br><span class="line">        city1.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>如此我们便将抽象部分与实现部分相分离，比如当类发生改变时，两者互不影响。比如交通工具增多，那对于City是没什么影响的，反过来，City增多也不影响交通工具。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点很明显，就是抽象与实现的分离，并且扩展性强，而且具体的实现对调用者是透明的。<br>而缺点就是这个模式理解起来有难度，对于维护可能会加重，并且由于建立在抽象编程上，开发者需要深入面向对象编程才能理解。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那简单总结一下</p><ul><li>如果抽象和实现部分不想耦合性那么强，那么可以采用桥接模式，将两个部分分开来。</li><li>如果两个部分都需要单独的扩展，可以使用桥接模式，两部分都可以独立的变化，并且互不影响。</li><li>当修改实现类时，不希望对调用方产生影响，那可以采用桥接模式，因为调用方是面向接口的，如果具体的实现类修改时，调用方不受影响，可以说是对调用方是透明的。</li><li>当我们采用继承时，可能会有很多子类，比如C继承B，B继承A，多级继承时，那采用桥接模式可以减少子类的数目。</li></ul><p>那以上就是这篇文章的内容，全文写下来觉得这个模式虽然很晦涩，但只要多写写代码就能理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;桥接模式其实是很少在项目中使用的设计模式，难度可以说是很大的。但是理解桥接模式能更深入的理解面向对象编程。&lt;br&gt;那这篇就来讲讲这个模式。 
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之原型模式</title>
    <link href="http://re0.top/2020/09/02/prototype_pattern/"/>
    <id>http://re0.top/2020/09/02/prototype_pattern/</id>
    <published>2020-09-02T07:00:00.000Z</published>
    <updated>2020-09-02T07:33:21.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇来讲讲原型模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>原型模式属于创建型模式，通常被用来创建重复的对象，通过原型来克隆对象，来获取相同的对象。<br>一般来说是创建对象的代价比较大时，比如对象的属性，设置较多，不方便重新创建，而是从原有对象进行拷贝。<br>这个模式实现的关键就是clone方法。<br>原型模式在实际项目中很少单独出现，通常是与工厂模式一起出现，由clone方法创建对象然后由工厂提供给调用者。 </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们依然用简单例子来讲讲这个模式。<br>首先创建的是抽象接口或者类。这里我采用是抽象类加实现Cloneable接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object clone = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clone = <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (CloneNotSupportedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>然后是具体的原型类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype1</span> <span class="keyword">extends</span> <span class="title">Prototype</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototype1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        id = <span class="string">"1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"id: "</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype2</span> <span class="keyword">extends</span> <span class="title">Prototype</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototype2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        id = <span class="string">"2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"id: "</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着我们创建一个管理类，帮助我们获取原型的克隆，相当于工厂模式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String,Prototype&gt; map = <span class="keyword">new</span></span><br><span class="line">            HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Prototype <span class="title">getPrototype</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        Prototype prototype = map.get(id);</span><br><span class="line">        <span class="keyword">return</span> (Prototype) prototype.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ConcretePrototype1 concretePrototype1 = <span class="keyword">new</span> ConcretePrototype1();</span><br><span class="line">        map.put(concretePrototype1.getId(),concretePrototype1);</span><br><span class="line"></span><br><span class="line">        ConcretePrototype2 concretePrototype2 = <span class="keyword">new</span> ConcretePrototype2();</span><br><span class="line">        map.put(concretePrototype2.getId(), concretePrototype2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>最后我们实现一个客户端调用看看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrototypeManager.init();</span><br><span class="line"></span><br><span class="line">        Prototype clonePrototype1 = PrototypeManager.getPrototype(<span class="string">"1"</span>);</span><br><span class="line">        clonePrototype1.test();</span><br><span class="line"></span><br><span class="line">        Prototype clonePrototype1_ = PrototypeManager.getPrototype(<span class="string">"1"</span>);</span><br><span class="line">        clonePrototype1_.test();</span><br><span class="line"></span><br><span class="line">        System.out.println(clonePrototype1.hashCode() + <span class="string">"   "</span>  + clonePrototype1_.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>那最后一行输出是为了看两个对象是否相同，如果是同一个对象那么hashcode应该是相同的，那结果很明显是不同的，所以两个对象只是属性相同，而在内存中的引用不同。<br>如此我们就结合了原型模式和工厂模式。当然，对于原型管理器也就是PrototypeManager应该实现动态的添加和删除原型，即应该实例化这个对象，并且加上锁来实现并发，这里就不再实现了。   </p><h2 id="Java中的克隆"><a href="#Java中的克隆" class="headerlink" title="Java中的克隆"></a>Java中的克隆</h2><p>这里有一点要说的是，Cloneable接口只起一个作用，并没有实际的方法，它的目的只是告诉JVM可以在这个类上安全的使用clone方法，如果没有实现这个接口，则会抛出CloneNotSupportedException异常。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>最后我们依旧来讲讲这个模式的优缺点。<br>优点呢，在于性能高效，并且如果构造函数十分复杂的话还可以不用理会，因为可以直接克隆。<br>那缺点也十分明显，需要实现cloneable接口，其次就是每个类都必须有一个克隆方法，因为不是所有的类都可以直接使用父类clone方法来进行克隆，复杂的类也许需要手动重新clone方法。然后还有就是在进行拷贝的时候，有可能会出现循环引用的场景，导致栈溢出也是有可能的，因此clone方法并不一定好用。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于原型模式的内容。感觉容量不大，但是需要手动写写代码才能更好的理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这篇来讲讲原型模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>由lambda表达式引发的思考</title>
    <link href="http://re0.top/2020/08/29/lambda/"/>
    <id>http://re0.top/2020/08/29/lambda/</id>
    <published>2020-08-29T07:00:00.000Z</published>
    <updated>2020-08-29T08:04:15.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>lambda表达式不能说常用吧，但偶尔还是需要用到的。关于lambda表达式，是我学python的时候接触到的概念，仔细想想也有两年了。前段时间的面试有提到java中的lambda表达式，当时自己的回答还是比较笼统的，比如作为类似语法糖的存在，通常在比较器里面写，可以免写匿名类等等。我个人感觉回答的不是很好，那这篇文章就来讲讲我们一直在用的lambda表达式吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>lambda表达式在很多语言中都有，那我个人比较熟悉的python与java中的lambda。那lambda表达式究竟是啥呢？根据百度百科的定义：  </p><blockquote><p>lambda表达式是一个<strong>匿名函数</strong>，基于数学中的λ演算得名，可以表示闭包。</p></blockquote><p>这么说谁听得懂哦？没错，没有实践的概念都是天书。<br>那我们先来讲讲啥是匿名函数。  </p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>所谓匿名函数，正如字面所讲，就是没有名字的函数，正常我们在定义函数时，会定义它的名称，其他地方调用时直接用它的名称进行调用即可。<br>那如果我们只需要使用一次这个函数，并且不想给他取名，那这时我们就要用到匿名函数了。<br><strong>所谓的lambda表达式就是匿名函数的一种表示方式。</strong></p><h2 id="python中的lambda表达式"><a href="#python中的lambda表达式" class="headerlink" title="python中的lambda表达式"></a>python中的lambda表达式</h2><p>正常我们在定义函数时会这么定义：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + x</span><br></pre></td></tr></table></figure> </p><p>以上我们定义了一个有名称的函数，而如果使用lambda表达式的话<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = <span class="keyword">lambda</span> x : x + x</span><br></pre></td></tr></table></figure> </p><p>那这两种定义函数的方式的功能都是一样的，那通常情况下我们不会把lambda表达式赋值给任何变量，这相当于可以使用这个变量调用匿名函数，就已经不符合匿名函数的定义。<br>那在python中使用到lambda表达式的场景有哪些呢？  </p><ul><li>最常见的当然就是一些python中的内置函数，比如作为比较器的时候，如sorted函数，<code>sorted([1,2,3],key=lambda x : -x)</code>，又比如map函数，<code>map(lambda x: x+1, [1,2,3])</code>。</li><li>那还有就是函数的返回可以是一个匿名函数，例如<code>return lambda x,y : x*y</code>，这个我比较少用。</li><li>还有就是可以通过lambda表达式将某个函数屏蔽，例如前端可以通过<code>console.log = ()=&gt;{}</code>来屏蔽log输出，原因是把log函数给替换成了没有功能的函数，那python中也可以，比如<code>time.sleep = lambda x : None</code>，就可以屏蔽sleep函数。  </li></ul><h2 id="Java中的lambda表达式"><a href="#Java中的lambda表达式" class="headerlink" title="Java中的lambda表达式"></a>Java中的lambda表达式</h2><p>Java 8中支持了lambda表达式，那么带来的结果就是代码更加简洁。它的亮点就是可以替代匿名内部类。<br>java中的lambda表达式的语法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure>  </p><p>在java 8之前假设要新建一个线程，在之前的<a href="/2020/07/24/java_thread_pool/">文章</a>我有写过，通常我们需要这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>   </p><p>那在java 8之后我们可以通过lambda表达式省去这个匿名runnable对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">    () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>   </p><p>当然，我们最常见的还是传入比较器的时候，例如在java 8之前，我们需要匿名内部类来重写比较器的compare方法。例如使用优先级队列需要建立堆时，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>   </p><p>那这边ieda就会提示我是否转换为lambda表达式，我们转换一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br></pre></td></tr></table></figure>   </p><p>我们代码更加直观了。当然这得益于jvm自动帮助我们判断参数类型。<br>那为什么可以简写呢？其实我们可以直接跟进源码看看，首先是new Thread，我们可以发现Thread有个构造函数可以传入Runnable对象，而Runnable是一个接口；接着我们看PriorityQueue，也可以发现有个构造函数可以传入Comparator对象，而Comparator也是个接口。<br>所以不难猜测，其实能使用lambda表达式是因为有相应的构造函数与接口的存在。那书写后编译时，自动帮我们匹配进相应的构造函数，自动判断类型，等等。这就是lambda表达式所帮我们做的。  </p><h2 id="Java-lambda表达式深入"><a href="#Java-lambda表达式深入" class="headerlink" title="Java lambda表达式深入"></a>Java lambda表达式深入</h2><p>那通过以上我们可以知道，lambda表达式其实作为的是一种类似语法糖的存在，可以更直观的书写代码。lambda表达式似乎与匿名内部类可以相互替换。但事实并非如此。<br>当我们书写一个匿名内部类时，在编译阶段我们可以发现发现多出了一个class文件，但我们使用lambda表达式后，只有一个class文件。<br>继续查看使用lambda表达式后编译的class文件，我们可以发现lambda表达式其实是被封装成主类的一个私有静态方法。<br>还有一点是this的使用，在匿名内部类中，this指向的是自己，而lambda表达式中，this指向的是外部类。</p><h2 id="Java-lambda表达式的性能问题"><a href="#Java-lambda表达式的性能问题" class="headerlink" title="Java lambda表达式的性能问题"></a>Java lambda表达式的性能问题</h2><p>这个问题其实困扰了我很久，在网上找了许多文章，有说性能有损失，有说没差多少。那在我测试后发现，lambda表达式确确实实有一点性能上的损失，但是并不大。那在我做LeetCode的其中一道题目中使用到的优先级队列，那使用匿名内部类与使用lambda表达式的时间分别是40-60ms与600-700ms(大概)，所以也就是说在某些用例上面，lambda确实是慢于匿名内部类的。<br>那关于这个问题，如果之后还有遇到会单独写写文章还有测试方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章讲了什么是lambda表达式以及在python和java中的常用方法。那在python中，由于这门语言本身就追求简洁与方便，所以在大部分函数中传入lambda表达式本身就是十分省事的存在，并且不会把函数定义写入整个文件中，从而污染环境。<br>在java中，其实我个人倾向于把lambda表达式看做是一种语法糖，减少书写量，因为它能做到大部分匿名内部类的所能做的事，从代码简洁性来看肯定是更好的。<br>那函数式编程越加火热的今天，lambda表达式作为函数式编程的一份子，肯定是会有越来越多语言支持，甚至当成主要书写方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;lambda表达式不能说常用吧，但偶尔还是需要用到的。关于lambda表达式，是我学python的时候接触到的概念，仔细想想也有两年了。前段
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://re0.top/tags/Java/"/>
    
      <category term="Python" scheme="http://re0.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之迭代器模式</title>
    <link href="http://re0.top/2020/08/27/iterator_pattern/"/>
    <id>http://re0.top/2020/08/27/iterator_pattern/</id>
    <published>2020-08-27T08:00:00.000Z</published>
    <updated>2020-08-27T09:32:01.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇来讲讲迭代器模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>迭代器模式属于行为型模式，这种模式用于顺序访问集合对象中的元素，但是没有暴露内部的表示。例如java中的iterator。<br>一般来讲迭代器模式中有以下几个角色：</p><ul><li>迭代器(Iterator)：抽象接口，一般来说有几个方法，next()取得下一个元素，hasNext()判断是否有下一个元素，remove()移除元素。</li><li>具体迭代器，即实现迭代器接口的具体类</li><li>容器角色(Aggregate/Container)：也是个接口，一般有一个iterator()提供迭代器，java中有Collection，list，set等接口。</li><li>具体容器角色：即容器角色的实现类，如java中实现list的ArrayList等。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们来实现一个简单的迭代器。<br>先定义简单迭代器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>之后定义容器接口，里面有一个getIterator获取迭代器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>之后实现具体容器，使用内部类定义具体迭代器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">keyRepository</span> <span class="keyword">implements</span> <span class="title">Container</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] keys = &#123;<span class="string">"101"</span>,<span class="string">"102"</span>,<span class="string">"103"</span>&#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &lt; keys.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasNext())&#123;</span><br><span class="line">                <span class="keyword">return</span> keys[index++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>最后测试一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        keyRepository keyRepository = <span class="keyword">new</span> keyRepository();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Iterator iterator = keyRepository.getIterator(); iterator.hasNext();)&#123;</span><br><span class="line">            System.out.println(<span class="string">"key is "</span> + iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>   </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>迭代器模式的优点在于简化了遍历的方式，对于数组或者列表我们还可以通过下标来获取对象，而如果对于一些无法通过下标获取对象的存储类型，我们就需要迭代器来顺序获取对象。其次我们可以实现多种遍历方式，如正序或者逆序。再者我们增加新的迭代器时无修修改原有的代码。<br>而缺点在于由于迭代器模式存储与遍历数据的方法是分开的，因此需要增加新的容器时就需要添加对应的迭代器类，增加复杂性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>迭代器模式与容器是相互作用的，一般来说实现一个容器就要实现这个容器的迭代器，在java中的collection，list，set，map等都有它自己的迭代器。我们可以使用增强型for循环再配合迭代器进行遍历，十分方便。所以迭代器模式就是当我们需要实现一个新的容器时，就需要引入这个模式，来给这个容器提供一个迭代器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇来讲讲迭代器模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之策略模式</title>
    <link href="http://re0.top/2020/08/27/strategy_pattern/"/>
    <id>http://re0.top/2020/08/27/strategy_pattern/</id>
    <published>2020-08-27T07:00:00.000Z</published>
    <updated>2020-08-27T07:18:13.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>几天没写文章，今天来讲讲策略模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>策略模式，属于行为型模式。它是把算法封装到类中，让这些算法可以相互替换，并且不影响到客户端，简单来说，就是把算法进行封装，客户端可以通过条件不同来选择不同的策略。<br>常见的实例有：</p><ul><li>客户端需要选择几种算法中的一种，例如某些工具类的封装</li><li>选择不同实现的方式，例如实现出行可以步行可以公交等等。</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>那策略模式的实现关键在于所有的策略需要实现同一个接口。<br>我们举个例子，例如出门的选择上，假设有三种选择，步行，公交，驾车。我们用这个例子实现策略模式。<br>首先定义Strategy接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着实现几种策略<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"选择步行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"选择公交"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyC</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"选择驾车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着我们创建context对象，这个类是为了让客户端选择合适策略，即连接客户端与策略的中间者。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setStrategy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> r = random.nextInt(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>)&#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> StrategyA();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">1</span>)&#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> StrategyB();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> StrategyC();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        strategy.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>这里我们使用随机法选择策略，那实现的方式有很多，比如客户端直接传入策略的对象，又比如客户端传入关键字让context选择策略等等。   </p><p>最后我们创建客户端调用看看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context test_context = <span class="keyword">new</span> Context();</span><br><span class="line">        test_context.selectFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>如此我们便实现了一个简单的策略模式。这里有一点，常见的策略模式是由客户端决定使用什么策略，所以严格来说上文并不是一个严谨的策略模式。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>策略模式的优点在于策略可以灵活的切换，因为他们实现了同一个接口。其次就是便于拓展，在增加新的策略时，只需要添加一个具体类并加入Context类中就可以，符合”开闭原则”。<br>那缺点在于客户端必须知道所有的策略，需要自行决定使用策略，即需要暴露所有策略类。其次就是策略类会随着系统扩展而变多，而不利于维护。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文对策略模式进行了大概介绍。如果系统中需要选择其中一种算法时或者类的区别在于不同的行为时，又或者一个对象有多个行为，当这些情况时，可以使用策略模式对策略进行封装到context中，并使用context进行调用。就是这么简单~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;几天没写文章，今天来讲讲策略模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之适配器模式</title>
    <link href="http://re0.top/2020/08/22/adapter_pattern/"/>
    <id>http://re0.top/2020/08/22/adapter_pattern/</id>
    <published>2020-08-22T07:00:00.000Z</published>
    <updated>2020-08-22T08:55:22.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久没写这个系列，趁着休息时间今天来讲讲适配器模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>适配器模式属于结构型模式，这种设计模式解决的问题是原本由于接口不兼容而不能工作的类可以在一起工作。适配器模式与装饰模式很像，是定义一个包装类，来包装我们所需要适配的类，改变它的接口。但和装饰模式不同的是，包装类不改变原有类的功能，只是改变它的接口。<br>那运用的场景有：  </p><ul><li>电压问题，国外与国内的家用电电压不同，导致进口电器需要适配器转换电压。</li><li>在linux上运行windows程序，需要一个适配平台来实现。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>就用上面的第一个例子我们来讲讲这个模式。<br>首先我们创建原有的类，即国内都是220v的插座。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerSocket220V</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output_220v</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"输出220v"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着我们创建适配器继承于这个类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerAdapter220V</span> <span class="keyword">extends</span> <span class="title">PowerSocket220V</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert_110V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取220V的输入</span></span><br><span class="line">        <span class="keyword">this</span>.output_220v();</span><br><span class="line">        <span class="comment">//进行转换</span></span><br><span class="line">        System.out.println(<span class="string">"输出110V"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>以上就是一个简单例子，即我没有改变原有类的功能，只是改变原有类的接口，使得可以正常工作。<br>那具体来说适配模式需要以下几个类：<br>1.一个已存在并且要适配的类，即原类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adapteeRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"原类中的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>2.需要的目标接口，可以通过实现这个接口来增加接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>3.适配器类，继承于原类，并且实现了目标接口中的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        <span class="keyword">super</span>.adapteeRequest();</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>   </p><p>或者我们可以在适配器中实例化原类，不继承原类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        adaptee.adapteeRequest();</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>那适配器模式的优点呢，是原类与适配类解耦，无需改变原类的结构。并且增加了类的复用与透明度，怎么说呢，由于适配类中的封装对客户端是可见的，所以是透明的。至于类的复用，原类可能实现十分复杂无法直接修改，类似于祖传代码，但是使用复杂，有了适配器模式就可以对原有类进行适配，所以就提高了它的复用性。<br>那缺点在于如果一个大型系统使用了很多适配器，那会十分杂乱，例如明明调用的是A接口但是内部却是调用B接口来实现。其次是像Java这种语言，不支持多继承，所以一次只能适配一个适配者类。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上所述，这个模式的场景是需要使用的原有的类，但这些类的接口不太符合系统需求，或者说是调用条件过于繁琐。但当系统逐渐扩大，过多的适配器会导致维护成本增加，所以如果不是十分必要，可以直接进行重构，而不是使用适配器。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;好久没写这个系列，趁着休息时间今天来讲讲适配器模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>谈一道数据库更新的并发问题</title>
    <link href="http://re0.top/2020/08/19/sql_concurrent/"/>
    <id>http://re0.top/2020/08/19/sql_concurrent/</id>
    <published>2020-08-19T08:00:00.000Z</published>
    <updated>2020-08-19T09:19:47.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天进行了第一次面试，还是比较紧张的，面试官比较严肃，感觉面试官就是抓着一个点不断的问，问到你不会，这次面试算是很失败了，不仅前面的问题很多都不清楚，而且最后的coding题都没写完成，明明知道怎么写，缺敲不动键盘，但是也知道了自己的不足，主要是数据库方面，然后还有代码方面需要加强一下。再努力吧。<br>那文章还是得继续写，今天聊聊面试中提到的一个关于数据库修改数据的问题。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><blockquote><p>有这么一个场景，假设user表的结构为id,user_data，其中这个user_data是个json数据，存放着用户的年龄，名字等等的数据，如果一个用户并发修改这个字段中的user_age与user_name会出现什么样的情况？<br>首先这个问题，先考虑单个字段修改的情况，即我修改其中的某一个数据该怎么改？<br>我在面试中的回答是先取出这个json数据存为对象，然后对这个对象进行修改。但其实mysql5.7.8开始，就提供了对json字段进行操作的函数，有JSON_SET(), JSON_INSERT()还有JSON_REPLACE()，其中JSON_REPLACE()是用来修改json数据的某个字段。那我个人是不太清楚这个，上网查找才知道如果需要对json字段进行update，那可以使用以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set user_data = json_replace(user_data,&apos;$.user_name&apos;,&apos;abc&apos;,&apos;$.user_age&apos;,18) where id = 1;</span><br></pre></td></tr></table></figure>  </p></blockquote><p>其实就是这么简单。<br>但我当时回答的是，先取出数据，再去修改。那问题来了，如果在读过后，被其他线程修改过了数据该怎么办？<br>例如原始数据为<code>1 {&#39;user_name&#39;:&#39;abc&#39;,&#39;user_age&#39;:10}</code>。<br>那么同时过来两个请求a,b：<br>其中a请求是把user_name改为aaa，而b请求是把user_age改为20。<br>那这时候如果请求时间十分接近，在a读取原始数据过后，还没来得及修改，b请求就已经将age改为20了，但此时a读取的数据就是旧的了，如果a继续写入，那age的值就会变为未修改前的。最终导致只有一个字段修改成功。  </p><p>这个问题就是数据库并发时会出现的问题，其实就是不可重复读的问题，即一个事务在一段时间内读取的数据不一致，那解决办法我个人认为使用事务加锁进行解决。</p><h2 id="排它锁与共享锁"><a href="#排它锁与共享锁" class="headerlink" title="排它锁与共享锁"></a>排它锁与共享锁</h2><p>mysql的innodb当中，有一种共享锁的存在，在读取数据前添加共享锁，其他事务只能添加共享锁。那排它锁就是在获取排它锁之后，其他事务不能添加任何锁。  </p><p>那问题在于添加了读的共享锁之后，再添加排它锁会导致死锁，两个事务都没法获得锁，没法更新。所以我们可以在读取的时候就添加排它锁，事务结束后再释放就可以了。<br>那还有一种解决方案就是直接把数据库的隔离级别设为可串行化，事务排队执行，但可能导致请求的阻塞。  </p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>以上就是这个问题的后续思考。<br>在写这篇文章时，没想到就收到了下一面的预约电话，感觉不可思议，明明表现不怎样。但学习永远都是停不下脚步的，就这样共勉吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天进行了第一次面试，还是比较紧张的，面试官比较严肃，感觉面试官就是抓着一个点不断的问，问到你不会，这次面试算是很失败了，不仅前面的问题很多
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数据库" scheme="http://re0.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之装饰器模式</title>
    <link href="http://re0.top/2020/08/17/decorator_pattern/"/>
    <id>http://re0.top/2020/08/17/decorator_pattern/</id>
    <published>2020-08-17T09:00:00.000Z</published>
    <updated>2020-08-17T09:25:54.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>继续讲讲装饰器模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>装饰器模式就是向一个现有对象添加新的功能，又不改变原对象的结构。它属于结构型模式，因为是对现有类进行包装，所以称作装饰器模式。<br>这么一说，装饰器模式与代理模式有点类似？都可以拓展一个类的功能，又不改变原对象。他们之间的差别之后会说。<br>那这个模式具体的使用场景就是扩展类的功能，并且可以动态修改。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们来实现一个简单的装饰器模式。<br>这里我们先创建接口Component，规范具体实现类与装饰类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着是具体实现类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>创建抽象装饰类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.doAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>然后是具体装饰类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doAction();</span><br><span class="line">        <span class="comment">// 这里写其他功能，如记录</span></span><br><span class="line">        System.out.println(<span class="string">"执行额外功能"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>我们编写客户端调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component component = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        Decorator decorator = <span class="keyword">new</span> ConcreteDecorator(component);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通类执行</span></span><br><span class="line">        component.doAction();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 使用装饰类执行</span></span><br><span class="line">        decorator.doAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">执行操作</span></span><br><span class="line"><span class="comment">执行额外功能</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>装饰器模式中的抽象装饰器与具体被装饰的类都要实现同一个接口，客户端的请求通过装饰类，装饰类通过具体类来实现，层层传递。在装饰类中能扩展具体类的功能。  </p><h2 id="与代理模式的异同"><a href="#与代理模式的异同" class="headerlink" title="与代理模式的异同"></a>与代理模式的异同</h2><p>装饰器模式也是添加中间层，来实现扩展，但是与代理模式不同的是，代理模式可以隐藏具体类的实现，具体类对于客户端来说是不可见的。而装饰器模式中具体类是可以在客户端中生成的，并且装饰类必须传入具体类才能实现装饰。<br>这是两者的异同点。  </p><h2 id="半透明的装饰模式"><a href="#半透明的装饰模式" class="headerlink" title="半透明的装饰模式"></a>半透明的装饰模式</h2><p>在上面的装饰模式中，具体类，装饰类的接口与抽象接口类Component的接口完全一致。这种称作透明的装饰模式。而如果装饰类的接口与抽象接口类的接口不一致，那装饰器就会变成适配器模式。但这种装饰模式是可以接受的，称作半透明的装饰器模式。<br>即全透明的装饰器模式增强功能不改变接口，半透明的装饰器模式增强功能，改变接口，而适配器模式则是不改变功能，改变接口。<br>将在下一篇讲讲适配器模式。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>最后来讲讲优缺点，装饰器模式优点很明显，就是扩展类的功能，它是继承的一个替代方式，而缺点在于如果存在多层装饰就会十分繁琐，对问题的查找较为麻烦。  </p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>这篇文章讲了装饰器模式的概念与实现，下一篇大概会讲讲适配器模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;继续讲讲装饰器模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
