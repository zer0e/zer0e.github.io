<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zer0&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://re0.top/"/>
  <updated>2020-08-12T14:20:12.660Z</updated>
  <id>http://re0.top/</id>
  
  <author>
    <name>Zer0</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之中介者模式</title>
    <link href="http://re0.top/2020/08/12/mediator_pattern/"/>
    <id>http://re0.top/2020/08/12/mediator_pattern/</id>
    <published>2020-08-12T12:00:00.000Z</published>
    <updated>2020-08-12T14:20:12.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍中介者模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>中介者模式属于行为型模式，是用在多个对象之间的通信，这种模式提供一个中介类，这个类处理不同类之间的通信，使代码松耦合易维护。<br>这个模式解决的问题是类与类之间关联性较大，系统呈网状结构，而这个模式就是将网状结构分离成星型结构，来减少类之间的依赖程度。<br>常用实例有：  </p><ul><li>网络通信，例如QQ群的通信。 </li><li>MVC框架中C(Controller)就是M(Model)和V(View)之间的中介者。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>就拿网络聊天来说，聊天室可以同时有多个人聊天，而这些聊天的人不必关心其他人是否能收到消息，而是只要将消息发往聊天室，而在线的人就可以从聊天室中看到其他人的消息。<br>我们就拿这个例子来看。<br>先创建一个聊天室类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRoom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showMsg</span><span class="params">(User user,String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(System.currentTimeMillis()) +</span><br><span class="line">                <span class="string">" \""</span> + user.getName() + <span class="string">"\" : "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>这里我们设为静态方法，接收一个User对象，以及消息msg，为了方便，我直接打印在控制台中。不然应该是发送到其他对象中。   </p><p>其次我们创建User类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        ChatRoom.showMsg(<span class="keyword">this</span>,msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>我们直接在本地调用试试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User alice = <span class="keyword">new</span> User(<span class="string">"alice"</span>);</span><br><span class="line">        User bob = <span class="keyword">new</span> User(<span class="string">"bob"</span>);</span><br><span class="line">        alice.sendMsg(<span class="string">"hello, bob"</span>);</span><br><span class="line">        bob.sendMsg(<span class="string">"hi, alice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2020-08-12 21:51:33 "alice" : hello, bob</span></span><br><span class="line"><span class="comment">2020-08-12 21:51:33 "bob" : hi, alice</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>   </p><p>如此我们实现了一个简单的中介者模式。</p><h2 id="后续思考"><a href="#后续思考" class="headerlink" title="后续思考"></a>后续思考</h2><p>那其实真正的聊天室并不是这样，这里我谈谈自己的见解吧，不一定对，只是我个人的思考。  </p><p>在服务端，我们需要初始化聊天室类，其中内部维护一个列表，列表中存放着在此聊天室的人员。<br>之后初始化用户后，加入这个聊天室，例如ChatRoom.join(user，roomId)，让这个用户加入这个聊天室。join方法可以是static的，因为需要网络通信，不可能在本地生成聊天室实例。之后返回是否成功加入，以及房间的具体信息。<br>加入之后调用user.sendMsg(msg,roomId)，然后通过ChatRoom类中的方法将消息发送到服务端，服务端接收到之后，将该条消息转发给除该用户以外的所有用户。<br>至于服务端实现，则可以设计一个总服务端，并维护一个map，map中存放所有存活的聊天室，然后不设计小服务端，而是收到消息后转发给聊天室实例，这种设计对服务端要求较高。<br>而另外一种服务端设计则是在加入房间时与总服务端通信，之后服务端返回聊天室的地址，转而向聊天室服务端进行通信，这种设计减少了中控的压力。<br>以上就是一个聊天室的流程，由于涉及网络io，这里就不写代码了，大概原理了解一下。<br>但不管如何，这个模型依旧是一个中介者模式的模型。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>中介者模式降低类与类之间的耦合程度，并且由一对多关系转换成一对一关系。<br>而缺点在于中介者会很庞大，不利于维护，当中介者失效后，所有类则无法工作。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了中介者模式，以及实现了一个简单例子，中介者模式与代理模式还有外观模式有点相似，其相同点与不同点就留到外观模式之后再讲吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文介绍中介者模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之工厂模式</title>
    <link href="http://re0.top/2020/08/12/factory_pattern/"/>
    <id>http://re0.top/2020/08/12/factory_pattern/</id>
    <published>2020-08-12T06:00:00.000Z</published>
    <updated>2020-08-12T07:30:06.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文讲讲工厂模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>工厂模式是Java中常用的一种设计模式，它属于创建型模式的一种，又称为工厂方法模式，这种模式提供了创建对象的一种方法，对客户端隐藏生成对象的逻辑，使用一个接口来指向新的对象。<br>常见的实例有：  </p><ul><li>工厂提供多种产品，你可以直接购买，无需关心如何制作。</li><li>日志管理，可以使用多种方式记录，并且可以记录到本地，远程等等。</li><li>数据库访问，不知道系统最后使用哪种数据库时，封装可用的数据库。</li></ul><p>当对象较为复杂时，使用工厂模式较为适合，如果对象十分简单，那直接使用new生成就可以了。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>下面我们用一个例子来实现工厂模式。<br>例如游戏公司要制作几个新的游戏。<br>我们将创建一个游戏Game接口，以及实现它的实体类，然后创建工厂去制作游戏。<br>我们先定义Game接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>接着定义几个游戏A,B,C<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameA</span> <span class="keyword">implements</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is Game A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameB</span> <span class="keyword">implements</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is Game B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameC</span> <span class="keyword">implements</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is Game C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>接着创建工厂，根据名称生成实体类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Game <span class="title">getGame</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">"GameA"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GameA();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">"GameB"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GameB();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">"GameC"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GameC();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着编写客户端进行调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GameFactory gameFactory = <span class="keyword">new</span> GameFactory();</span><br><span class="line"></span><br><span class="line">        Game game1 = gameFactory.getGame(<span class="string">"GameA"</span>);</span><br><span class="line">        game1.test();</span><br><span class="line"></span><br><span class="line">        Game game2 = gameFactory.getGame(<span class="string">"GameB"</span>);</span><br><span class="line">        game2.test();</span><br><span class="line"></span><br><span class="line">        Game game3 = gameFactory.getGame(<span class="string">"GameC"</span>);</span><br><span class="line">        game3.test();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">this is Game A</span></span><br><span class="line"><span class="comment">this is Game B</span></span><br><span class="line"><span class="comment">this is Game C</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>   </p><h2 id="后续思考"><a href="#后续思考" class="headerlink" title="后续思考"></a>后续思考</h2><p>以上我们就实现了一个简单的工程模式示例，当然从上述工厂的代码来看，肯定是不够优雅的，毕竟我们需要写很多的if else，或者case语句。<br>那我自己想到的点是，通过一个枚举类或者常量，提供所有可以创建对象的关键字，然后通过关键字所对应的值，来进行反射创建操作。<br>例如创建一个GameType类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String GameA = GameA.class.getName();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String GameB = GameB.class.getName();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String GameC = GameC.class.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>修改GameFactory<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Game <span class="title">getGame2</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Game) Class.forName(type).newInstance();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>对应client<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">Game game = gameFactory.getGame2(GameType.GameA);</span><br><span class="line">game.test();</span><br></pre></td></tr></table></figure>  </p><p>算是少些了一下冗余吧，当然也可以使用枚举类，这里就不再多写了。优化一下就少了许多if else。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>工厂模式的优点在于客户端只需知道名称就可以创建一个对象，并且拓展性较好，而且屏蔽了类的具体实现。<br>而缺点就是在增加一个产品之后，就需要添加具体类与修改工厂，增加系统的复杂性。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文总结了简单工厂模式，当然，从本文的例子看并不需要工厂模式去创建对象，但是当对象较为复杂时，例如对象依赖于其他对象，那在客户端中就没必要自己实现对象，而是交给工厂实现。而当客户端不知道需要创建对象的类时，也可以使用工厂模式来设计系统。<br>之后会讲讲工厂模式的进阶，抽象工厂模式，算是一个比较难的模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文讲讲工厂模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Spring AOP</title>
    <link href="http://re0.top/2020/08/10/spring_aop/"/>
    <id>http://re0.top/2020/08/10/spring_aop/</id>
    <published>2020-08-10T13:10:00.000Z</published>
    <updated>2020-08-11T08:05:47.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇提到Spring AOP中使用了代理模式。其实spring aop很早我就想写文章，因为它和ioc属于spring中最重要的两个概念之一。那这篇就好好讲讲spring aop。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><p>AOP(Aspect Oriented Programming)，中文翻译为面向切面编程，那啥是面向切面编程？我只听过面向对象编程啊？<br>其实AOP是OOP的延续，并不能完全替代OOP，他们的理念不一样，OOP是对对象进行封装，而AOP则是对某个业务进行切面提取，侧重点并不一样。<br>我们在编程时，如果有代码的重复，我们一般会将代码封装成对象或者方法，再去调用，这种抽取被称为纵向抽取，但当某个部分的逻辑分散在各个业务中时，我们往往无法进行纵向抽取，而AOP的目的就是将各个业务中相同的代码通过切割的方式抽取到一个独立逻辑中。然后将切割出来的代码再融入到其他业务中，完成与之前相同的功能。   </p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>按上面所讲，我们需要切割逻辑，并且完成与之前一样的功能，那我们就可以使用到之前提到的代理模式，通过增强对象，来实现对访问对象的改造或者增强，即在中间层加入相应逻辑。<br>要说aop原理，就不得不提代理，代理分为静态代理与动态代理，静态代理就是自己编写代理层，自己拦截需要拦截的方法并增强，可以见上一篇文章。<br>而spring aop的底层是动态代理。<br>那啥是动态代理？我们先看以下例子：<br>如果我们要实现一个接口，那一般情况下我们会编写实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">areYouOk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">areYouOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Are you ok?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>然后将HelloImpl实例化，调用。<br>那有没有可能我们不编写实现类，就直接在运行时创建接口的实例呢？答案是有，并且在Java标准库中提供了一种动态代理的机制，只需要预先知道接口，就可以在运行时动态生成实现类。而实现的方法就是reflect包中的Proxy.newProxyInstance()方法。<br>reflect包，诶？不就是反射操作的包吗？没错，动态代理也属于反射的一种。我们来看看怎么动态生成实现类。<br>首先newProxyInstance方法需要三个参数，第一个参数是类加载器ClassLoader，官方解释是loader the class loader to define the proxy class，其实就是定义由哪个classloader对生成的代理类进行加载。第二个参数是一个interface对象数组，也就是要我们需要实现哪些接口。第三个参数，一个InvocationHandler对象，代理的核心参数，当执行代理生成实现类时，会调用这个对象的invoke方法。可以在这个方法中处理逻辑。写一下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"areYouOk"</span>))&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Are you ok?"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Hello hello = (Hello) Proxy.newProxyInstance(Hello.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;Hello.class&#125;,</span><br><span class="line">                handler);</span><br><span class="line">        hello.areYouOk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>其中要简单说明下，invoke方法三个参数，第一参数是代理对象，第二个是调用方法，第三个是传入的参数。要注意在invoke中不能调用proxy参数，否则会导致永久递归，栈溢出。<br>动态代理本质上就是JDK在运行时动态创建class字节码并加载，这和之前谈过的反射一致。它只是帮我们编写了一个实现类，仅此而已。  </p><h3 id="JDK-Proxy-与-CGLib-Proxy"><a href="#JDK-Proxy-与-CGLib-Proxy" class="headerlink" title="JDK Proxy 与 CGLib Proxy"></a>JDK Proxy 与 CGLib Proxy</h3><p>在Java中，动态代理有两种，一种是JDK动态代理，另一种是CGlib动态代理。<br>JDK动态代理就是上文所讲的，需要实现一个类所使用的代理。而如果类没有实现接口，那就会使用CGLib代理。JDK动态代理本质上就是反射，但必须需要实现的接口。而CGLib动态代理是基于ASM机制，通过生成子类来作为代理类。<br>JDK动态代理的缺点就是只能基于接口。<br>CGLib是采用十分底层的字节码技术，原理是创建子类，拦截父类中的方法来实现代理，优点就是没有接口的类也能实现动态代理，而缺点则是实现相对较难。  </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>动态代理相对于静态代理，是通过动态生成代理类来实现代理技术，拦截并增强方法，将原本相同逻辑的代码抽取出来，并注入到目标对象，实现与原来一致的功能。动态代理分为JDK动态代理与CGLib动态代理，Spring AOP中默认使用JDK动态代理，当类没有接口时，才使用CGLib代理。    </p><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="部分概念"><a href="#部分概念" class="headerlink" title="部分概念"></a>部分概念</h3><p>上文简单讲了动态代理的概念，那既然知道Spring AOP是使用动态代理了，那啥是Spring AOP呢？<br>首先我们需要了解几个AOP中常见的名词。  </p><ul><li>连接点(Join Point): 即需要拦截的地方。</li><li>切点(Poincut): 即具体定位的连接点。  </li><li>增强/通知(Advice): 表示需要添加到切点的逻辑，Spring AOP中有多种类型。  </li><li>切面(Aspect): 切面由切点和增强/通知组成，包括横切逻辑与连接点的定义。</li></ul><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>了解了上述的概念之后，我们继续讲怎么实现AOP。如今实现AOP已经不再使用手动实现接口的方法，而是使用更加简洁方便的@Aspect注解方式。<br>我们来简单实现一个记录日志的功能。来看看如何使用AOP。<br>我们需要先知道Spring中Advice的注解有哪些：  </p><hr><table><thead><tr><th style="text-align:center">注解</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">@Before</td><td style="text-align:center">前置通知，在连接点方法前调用</td></tr><tr><td style="text-align:center">@Around</td><td style="text-align:center">环绕通知，它将覆盖原有方法，但是允许你通过反射调用原有方法</td></tr><tr><td style="text-align:center">@After</td><td style="text-align:center">后置通知，在连接点方法后调用</td></tr><tr><td style="text-align:center">@AfterReturning</td><td style="text-align:center">返回通知，在连接点方法执行并正常返回后调用，要求连接点方法在执行过程中没有发生异常</td></tr><tr><td style="text-align:center">@AfterThrowing</td><td style="text-align:center">异常通知，当连接点方法异常时调用</td></tr></tbody></table><hr><p>这里Before和AfterThrowing很好理解，一个是方法调用之前，另一个是异常之后。而After和AfterReturning的区别在于After是无论是否发生异常都会触发，而AfterReturning只在正常返回后才会触发。至于Around，可以理解成Before和After结合，可以决定在目标的什么时候执行。或者直接阻止运行，功能十分强大。<br>接下来我们来看看具体实现<br>新建一个springboot项目，并写下一个controller：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">helloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>接下来我们先定义切点，spring中使用execution中的正则表达式来判断具体要拦截的类和方法，可以在上面这些注解里直接定义拦截的方法，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(public * com.example.aop_test.helloController.*(..))"</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>  </p><p>首先*表示任意返回值，接着跟类的全限定名，之后*(..)表示返回值为任意的全部方法，等价于*(*)。<br>但是这么写的话需要每个advice注解中都需要这么长的定义，我们可以通过对一个方法定义@Pointcut注解来避免书写多次execution。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebLogAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = Logger.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.example.aop_test.helloController.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webLog</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        logger.info(joinPoint.toString());</span><br><span class="line">        logger.info(<span class="string">"before"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(returning = <span class="string">"ret"</span>,pointcut = <span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(Object ret)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        logger.info(<span class="string">"RESPONSE : "</span> + ret);</span><br><span class="line">        logger.info(<span class="string">"after returning"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span>  Throwable</span>&#123;</span><br><span class="line">        logger.info(<span class="string">"after "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>@AfterReturning注解中可以定义returning参数，来获取切点的返回值。这里没什么问题，但如果我在controller中加入一段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"123"</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"ex"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>  </p><p>那这时候只有before和after生效，因为没有正常返回，所以afterreturning没有执行。<br>再来看看环绕通知@Around，这是spring aop中最强大的通知，这个方法传入一个ProceedingJoinPoint对象，在执行joinPoint.proceed()之前就是before通知，出现异常就是afterThrowing，之后就是after通知：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"webLog()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    Object res = <span class="keyword">null</span>;</span><br><span class="line">    logger.info(<span class="string">"before"</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        res = joinPoint.proceed();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable throwable)&#123;</span><br><span class="line">        logger.info(<span class="string">"ex"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">"after"</span>);</span><br><span class="line">    <span class="keyword">return</span> (res != <span class="keyword">null</span>)?res : <span class="string">"other"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>   </p><p>当然，如果不执行proceed方法就那就相当于阻止了当前方法。所以我们可以通过这个点来做权限管理。<br>我们先设置切点只在hello方法执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.example.aop_test.helloController.hello(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webLog</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>hello方法不变，创建一个新的方法来设置cookie<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam String name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/set"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">setCookie</span><span class="params">(HttpServletResponse response, @RequestParam String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>)&#123;</span><br><span class="line">        name = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"name"</span>,name);</span><br><span class="line">    response.addCookie(cookie);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>接着是@Around方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"webLog()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    Object res = <span class="keyword">null</span>;</span><br><span class="line">    ServletRequestAttributes attributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();</span><br><span class="line">    HttpServletRequest request = attributes.getRequest();</span><br><span class="line">    Cookie[] cookies =  request.getCookies();</span><br><span class="line">    Map&lt;String,Cookie&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cookies.length;i++)&#123;</span><br><span class="line">        map.put(cookies[i].getName(),cookies[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(<span class="string">"name"</span>))&#123;</span><br><span class="line">        String cookieName = map.get(<span class="string">"name"</span>).getValue();</span><br><span class="line">        <span class="keyword">if</span> (cookieName.equals(<span class="string">"admin"</span>))&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                res = joinPoint.proceed();</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Throwable throwable)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"not admin"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>这里通过RequestContextHolder来获取request，并获取所有cookie存放在map中，通过对比cookie值是否为admin来判断是否执行controller方法，做到权限管理。当然，项目中的比较需要去redis对比token值是否失效，然后对比权限才能真正做到登录与权限管理。这里只是写个思路而已。   </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>讲到这里，差不多把spring aop基础讲完了，从代理模式一直讲到aop，再到如何使用，一路下来我也复习了好多知识，包括动态代理与spring aop，这里有一点，spring aop只是帮我们实现代理模式而已，自动添加中间层来对访问对象的控制，开发中是十分好用的。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上篇提到Spring AOP中使用了代理模式。其实spring aop很早我就想写文章，因为它和ioc属于spring中最重要的两个概念之一
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="java" scheme="http://re0.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之代理模式</title>
    <link href="http://re0.top/2020/08/10/proxy_pattern/"/>
    <id>http://re0.top/2020/08/10/proxy_pattern/</id>
    <published>2020-08-10T08:00:00.000Z</published>
    <updated>2020-08-10T09:39:21.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天来讲讲结构型模式的一种——代理模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念与介绍"><a href="#概念与介绍" class="headerlink" title="概念与介绍"></a>概念与介绍</h2><p>代理模式其实在日常生活中的例子很多，比如买东西的时候，代售点就是代理模式的一种，再比如代理上网，这个对许多人并不陌生，这里就不再多说(小声)。<br>那代理模式的主要意图就是由于访问目标有种种困难或问题，或者说无法访问，只有通过另一个对象才能访问这个对象，那这种模式就称作代理模式。<br>代理模式常用的场景有：  </p><ul><li>无法直接访问对象</li><li>访问对象有困难</li><li>不想直接访问对象，想在中间做控制</li></ul><p>通常在这些需求下，通过代理模式，来间接访问对象。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们用实际例子来实现代理模式。<br><code>由于新发售的游戏只在日本本土上架，要购买这款游戏必须通过代购入手。</code><br>即<code>代购(代理对象)代替我(真实对象)去买游戏(间接访问的操作)</code>。<br>首先，我们创建对象接口(Subject)，不管是真实对象，还是代理对象都会实现这个接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyGameFromJapan</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>其次我们创建真实对象，即”我”:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyGameFromJapan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"买了一部游戏"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>创建代理对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyGameFromJapan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RealSubject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        realSubject.buyGameFromJapan();</span><br><span class="line">        <span class="keyword">this</span>.doOtherThing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOtherThing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 记录购买的时间</span></span><br><span class="line">        System.out.println(<span class="string">"购买时间为："</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(System.currentTimeMillis()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>最后客户端调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.buyGameFromJapan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">买了一部游戏</span></span><br><span class="line"><span class="comment">购买时间为：2020-08-10 16:13:31</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>   </p><p>以上我们通过一个例子实现了代理模式，代理模式与之前的观察者模式类似，对象在初始化时，可以选择隐式初始化，即我们在Proxy中初始化了一个RealSubject，又可以在客户端中初始化realSubject，传进Proxy。两种方式都可以。<br>那有些同学就好奇，这么做有啥意义，我直接在自己realSubject中自己写一个方法调用不就好了吗？其实不然，如果有许多的委托类，每个类的方法都不一样，那么就需要我去内部查看调用方法，而代理模式就是为了让客户端无需关心对象内部的具体实现内容，而是交给代理类去实现，从而屏蔽不同委托类之间的差异。<br>其实简单来说，就是让客户端只关心调用，而不关心怎么实现。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>代理模式的优点前面也提到过，即协调了调用者和被调用者，有效地降低系统耦合度。其次，代理位于客户端与目标对象中间，可以保护对象，并增加具体操作。<br>缺点则是由于增加了一层代理，访问速度可能受到影响。其次是去实现代理模式可能会较为复杂。  </p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>代理模式应用场景很多，主要有：</p><ul><li>保护原始对象，根据用户不同提供不同权限。</li><li>降低对象大小，使用小对象代理大对象，减少系统开销。</li><li>访问远程对象，由于远程对象实现逻辑不同，需要代理来协商。</li><li>需要额外操作，在操作对象时，需要额外操作，例如记录日志等。  </li></ul><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>本文从一个例子讲解了代理模式的实现，以及代理模式常用场景，顺带一提，Spring AOP中也使用了代理模式，如果有时间的话，后续会继续谈谈Spring AOP中的代理。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天来讲讲结构型模式的一种——代理模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之观察者模式</title>
    <link href="http://re0.top/2020/08/08/observer/"/>
    <id>http://re0.top/2020/08/08/observer/</id>
    <published>2020-08-08T06:00:00.000Z</published>
    <updated>2020-08-08T09:09:06.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇谈谈观察者模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们在开发的时候，常常会有这样的需求场景：一个对象的某个状态更新了，与这个对象相关的所有对象都要跟着更新。但这些相关对象又不能直接写在类中，这时候我们就需要一个观察者帮助我们在一个对象更新后，通知其他对象跟着更新。<br>常见的场景有：发布订阅模型，例如公众号的发布就属于被观察者，而用户属于观察者。再比如游戏开发中，当角色触发某个机制时，对应通知相关的增益或者负增益，这些都可以使用观察者模式来解决。  </p><h2 id="初步"><a href="#初步" class="headerlink" title="初步"></a>初步</h2><p>最近在写的一个游戏脚本中，有这么一个场景：当角色进行攻击之后，附近如果有增益道具就会回复血量。<br>最简单的设计方法是设计一个事件循环，每隔一段时间判断角色是否攻击完成，并且是否判断道具是否在角色附近，但这个会形成空转，容易造成资源的浪费，并且无法进行实时的检测。<br>其次我还想到一种方法，那就是让把道具当作成员写进角色类，然后当角色攻击后，通知道具进行检测。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    Buff buff;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"角色攻击"</span>);</span><br><span class="line">        buff.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>那这个代码的问题在于Buff类本身就不属于Role，并且如果后续需要添加更多增益效果，那就必须修改Role类，导致类与类过于耦合。<br>这时候我们就需要观察者模式，减少代码之间的耦合。     </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在观察者模式中，有两个角色，观察者(Observer)与被观察者(Subject)，其中被观察者中有一个List，存放着所有注册的观察者们，当被观察者更新时，通知其他观察者相应进行更新。就按照上面这个例子，我来写写代码：<br>我们先创建抽象类Subject，即被观察者以及创建Observer接口，即观察者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">        observerList.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delObserver</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">        observerList.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observerList)&#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着我们创建增益类，实现观察者接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Buff</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inNear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断角色是否在附近，这里逻辑就不写了</span></span><br><span class="line">        <span class="comment">// 一般是判断半径几米</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inNear())&#123;</span><br><span class="line">            System.out.println(<span class="string">"角色获得Buff"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><p>然后创建角色类，继承抽象类被观察者Subject，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> <span class="keyword">extends</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"角色攻击"</span>);</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着我们需要Client类实现一个客户端，注册所有观察者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Role role = <span class="keyword">new</span> Role();</span><br><span class="line">        Buff buff = <span class="keyword">new</span> Buff();</span><br><span class="line">        <span class="comment">// 注册观察者</span></span><br><span class="line">        role.addObserver(buff);</span><br><span class="line">        role.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><p>我们运行查看输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">角色攻击</span><br><span class="line">角色获得Buff</span><br></pre></td></tr></table></figure>  </p><p>这里有一点，在被观察者注册事件中，我们既可以像上文一样显式进行注册，又可以在被观察者的构造函数中就进行注册，我们只需要把观察者对象传入被观察者中，然后进行注册就可以了，算是两种不同的写法吧，上文的写法更加清楚，并且依赖关系并没有那么强。<br>其次我们还可以实现更多的观察者，在client中进行注册，使得多个事件可以同时进行更新。例如我们可以添加掉落物品，附近怪物会被吸引等等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">monster</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isNear())&#123;</span><br><span class="line">            System.out.println(<span class="string">"附近怪物被吸引"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Treasure</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isNear())&#123;</span><br><span class="line">            System.out.println(<span class="string">"获得宝箱"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Role role = <span class="keyword">new</span> Role();</span><br><span class="line">        Buff buff = <span class="keyword">new</span> Buff();</span><br><span class="line">        Treasure treasure = <span class="keyword">new</span> Treasure();</span><br><span class="line">        Monster monster = <span class="keyword">new</span> Monster();</span><br><span class="line">        <span class="comment">// 注册观察者</span></span><br><span class="line">        role.addObserver(buff);</span><br><span class="line">        role.addObserver(treasure);</span><br><span class="line">        role.addObserver(monster);</span><br><span class="line">        role.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">System out：</span></span><br><span class="line"><span class="comment">角色攻击</span></span><br><span class="line"><span class="comment">角色获得Buff</span></span><br><span class="line"><span class="comment">获得宝箱</span></span><br><span class="line"><span class="comment">附近怪物被吸引</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure> </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>使用观察者模式的优点就是解耦，使对象之间的关系弱化，并且可以统一触发机制。<br>而缺点则是被观察者如果有许多观察者的话，通知所有的观察者可能需要花费很多时间。并且由于一个类既可以是观察者也可以是被观察者，如果有循环依赖的话，会导致不断调用。其次观察者模式只能知道目标发生了改变，但却无法知道怎么发生变化的。   </p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>本文总结了观察者模式，写这个模式是因为最近在写的一个脚本中出现了类似的需求，就先把这个模式整理重新学习了一遍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇谈谈观察者模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="http://re0.top/2020/08/07/singleton/"/>
    <id>http://re0.top/2020/08/07/singleton/</id>
    <published>2020-08-07T06:00:00.000Z</published>
    <updated>2020-08-07T09:22:58.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天就来谈谈常见的设计模式——单例模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单例模式属于创建型模式，这个设计模式涉及到一个单一的类，这个类负责创建自己的对象，又确保只有单个对象被创建，提供了一个全局唯一的实例化对象。它的目的是为了控制实例的数目，又或者是实例是单一的情况下，例如一个设备同时只能有一个对象进行操作。<br>而实现单例模式的关键代码就是将构造函数设为私有，不允许外部创建实例。  </p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>实现的方法很简单，我直接给出代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleDemo instance = <span class="keyword">new</span> SingleDemo();</span><br><span class="line">    <span class="comment">// 构造函数设为私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleDemo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>这里需要注意的是，我们初始化instance是就直接new SingleDemo()，则此时在getInstance就无需判空处理，这种写法被称为饿汉模式。由于装载类时就已经初始化了instance对象，所以这种方法是线程安全的。    </p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉式则是初始将对象设置为null，等有需要时在进行new操作。饿汉式和懒汉式十分形象，饿汉主动找食物，而懒汉等着别人给。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleDemo instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleDemo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><h2 id="懒汉式线程安全"><a href="#懒汉式线程安全" class="headerlink" title="懒汉式线程安全"></a>懒汉式线程安全</h2><p>以上的懒汉式并不能保证线程安全，当两个线程同时判断instance == null时，同时通过了判断，导致new出了不同的对象。我们可以通过synchronized关键字锁住getInstance方法保证单例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleDemo instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleDemo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingleDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>但这种方法会较为影响效率，由于在静态方法上使用synchronized关键字，所以同时只有一个线程能够进入方法内部，导致效率问题。  </p><h2 id="双重校验锁-DCL"><a href="#双重校验锁-DCL" class="headerlink" title="双重校验锁(DCL)"></a>双重校验锁(DCL)</h2><p>先上代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleDemo instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleDemo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleDemo.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingleDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>   </p><p>这个方法就是为了解决上面的效率问题。之所以使用双重检测，是因为多线程情况下，由于方法并不是synchronized修饰的，会导致多个线程同时进入方法进行第一次判空，如果此时instance还未初始化，才会进入临界区域，锁住临界区后，再次进行判空，因为此时前一个线程有可能已经完成了对象创建，而后一个线程才刚刚好进入临界区，所以需要二次判空。<br>之所以效率比上一个方法高，是因为只有初始化对象时才会进行对象的创建，创建对象的时候才会出现同步的问题，其他情况下直接获取instance就可以了，所以不锁住方法的效率更高一些。  </p><h2 id="DCL改进"><a href="#DCL改进" class="headerlink" title="DCL改进"></a>DCL改进</h2><p>上面的DCL并不是完整的线程安全，原因是JVM在编译时有可能进行指令地重排。举个例子：<br>例如instance = new SingleDemo()，这一行代码在JVM中可能被分为三个步骤：  </p><ol><li>分配对象的内存</li><li>初始化对象</li><li>令instance指向刚才分配的内存</li></ol><p>但这个步骤并不是一成不变的，JVM或者CPU会通过优化，改变成以下顺序：  </p><ol><li>分配内存</li><li>令instance指向刚才分配的内存</li><li>初始化对象</li></ol><p>所以当A线程做完如上1,2步时，instance已经指向了刚才分配的内存了，但并没有初始化，而如果此时B线程才刚开始进行第一次判空时，由于instance已经不是null了，所以B线程直接返回了一个还未初始化的对象。<br>基于以上原因，我们需要使用volatile修饰instance对象，阻止指令重排，保证instance不会出现中间态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingleDemo instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleDemo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleDemo.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingleDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>由于从外部无法访问静态内部类，所以只有在getInstance方法才能获得instance对象。<br>而静态内部类的加载并不是在外部类被加载时被加载，而是当需要使用时才进行加载，来保证懒加载的机制，由于使用的classloader的机制，所以是线程安全的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleDemo INSTANCE = <span class="keyword">new</span> SingleDemo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleDemo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>以上的方法虽然是私有的构造方法，但是依旧可以使用反射的方法来创建多个实例，关于反射，详见<a href="/2020/03/22/java-reflection/">这篇文章</a>。<br>而有没有什么方法来限制反射呢？答案就是枚举，代码很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当我们使用反射时获取对象时，会抛出NoSuchMethodException，阻止了反射。<br>而这种方法可以防止被多次实例化，是线程安全的，并且支持序列化机制，保证反序列化后返回的都是同一个对象，唯一缺点就是并非懒加载。<br>这种方法实际中使用较少。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天整理了几种单例模式，对单例模式重新复习了一下，在项目中，最常用的应该就是饿汉模式，其他模式用的较少，需要反序列化则可以使用枚举，或者实现readResolve()方法。<br>以上，愿好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天就来谈谈常见的设计模式——单例模式。  &lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>谈谈设计模式</title>
    <link href="http://re0.top/2020/08/06/design_patterns/"/>
    <id>http://re0.top/2020/08/06/design_patterns/</id>
    <published>2020-08-06T13:10:00.000Z</published>
    <updated>2020-08-12T07:28:15.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设计模式是提高代码可读性的途径之一，面对不同的场景选择不同的设计模式，可以提高代码可读性，提高代码的可重用性还有可扩展性。接下来就讲讲什么是设计模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="何为设计模式"><a href="#何为设计模式" class="headerlink" title="何为设计模式"></a>何为设计模式</h2><p>设计模式是在面向对象语言中，思想都是一致的，而在面向过程语言，函数式编程的语言中讨论设计模式是没有意义的。所谓的设计模式，就是前面提到的，在面向对象编程中的一些”套路”，在面对不同需求场景时，可以选择不同的设计模式，来提高代码的可读性，重用性与扩展性。   </p><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>在GoF设计模式书籍中，共有23种设计模式。<br>而这23种设计模式又可以分为三大类型:  </p><ul><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>这一类设计模式的目的是为了创建对象。其中包括：  </p><ol><li>抽象工厂模式</li><li><a href="/2020/08/12/factory_pattern/">工厂方法模式</a></li><li><a href="/2020/08/07/singleton/">单例模式</a></li><li>原型模式</li><li>构建模式</li></ol><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>这一类设计模式是为了优化不同类，对象，接口之间的结构关系。其中包括：  </p><ol><li><a href="/2020/08/10/proxy_pattern/">代理模式</a></li><li>装饰者模式</li><li>组合模式</li><li>桥接模式</li><li>适配器模式</li><li>外观模式</li><li>享元模式</li></ol><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>这一类设计模式的目的是更好地实现类与类之间的交互还有算法的执行。包括：  </p><ol><li>策略模式</li><li>命令模式</li><li>状态模式</li><li>责任链模式</li><li>解释器模式</li><li><a href="/2020/08/08/observer/">观察者模式</a></li><li>备忘录模式</li><li>迭代器模式</li><li>模板方法模式</li><li>访问者模式</li><li>中介者模式</li></ol><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>以上就是全部设计的种类。因为随着不断进步，设计模式远不止这一些，但掌握这些设计模式在日常编程中就可以有效保证代码的健康。<br>算是挖了一个新的大坑吧，之后会陆陆续续写写这23种设计模式的理解与实现。<br>2020.08.07 添加单例模式<br>2020.08.08 添加观察者模式<br>2020.08.10 添加代理模式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;设计模式是提高代码可读性的途径之一，面对不同的场景选择不同的设计模式，可以提高代码可读性，提高代码的可重用性还有可扩展性。接下来就讲讲什么是
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>谈谈Spring IoC</title>
    <link href="http://re0.top/2020/08/06/spring_ioc/"/>
    <id>http://re0.top/2020/08/06/spring_ioc/</id>
    <published>2020-08-06T05:10:00.000Z</published>
    <updated>2020-08-06T07:13:51.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>IoC本身来说并不是一种技术，而是一种思想。在spring开发中我们常常使用，但有时候想起来这个概念时，却不知道从何说起。本文就来谈谈spring中的核心概念——IoC。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="IoC概念"><a href="#IoC概念" class="headerlink" title="IoC概念"></a>IoC概念</h2><p>IoC(Inversion of Control)中文名“控制反转”，它是一种设计的思想。Ioc代表着你将对象交给容器来控制，而不是自己控制对象本身。为什么是反转呢？举个例子：<br>我们在传统的开发中，通常是通过new关键字在对象内部使用另一个对象，是我们主动去创建依赖的对象。而Ioc则是有一个专门的容器来创建这些对象。我们通过自己主动控制生成对象的方式也叫做正转，而使用容器控制创建对象并注入的方式，就称作反转。</p><h2 id="IoC的作用"><a href="#IoC的作用" class="headerlink" title="IoC的作用"></a>IoC的作用</h2><p>IoC常常被用在大型框架上，由IoC容器去创建去查找依赖的对象，由容器去注入对象，使得对象之间是松耦合的，方便测试与功能的复用，也利于维护，让整体架构更加灵活。  </p><h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><p>前面提到了注入，也就是DI(Dependency Injection)，即“依赖注入”，是指组件之间的依赖关系由容器在运行期决定，即容器动态地将某个依赖关系注入到组件中。通过依赖注入，我们只需完成业务逻辑，无需关心资源的来源于由谁决定，一切都由容器帮忙注入依赖。</p><h2 id="IoC的技术实现"><a href="#IoC的技术实现" class="headerlink" title="IoC的技术实现"></a>IoC的技术实现</h2><p>既然已经清楚IoC的概念，那IoC容器又是怎么完成依赖注入呢？常见的方式有两种，构造器方法注入与setter注入。<br>构造器注入是指在对象创建时，所依赖的对象便以参数形式传入该对象中。假设在A类中需要B类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而setter方法注入则是在需要的时候才执行注入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而无论是哪种方法，IoC容器都帮你执行了，你无需关心注入的过程。  </p><h2 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h2><p>这里就简单介绍下IoC容器。<br>Spring 提供了两种IoC容器，BeanFactory和ApplicationContext，而ApplicationContext是BeanFactory的子类。BeanFactory 和 ApplicationContext 的区别有：<br>BeanFactory：是Spring中最底层的接口，只提供了最简单的IoC功能,负责配置，创建和管理bean。<br>在应用中，一般不使用 BeanFactory，而推荐使用ApplicationContext（应用上下文），原因如下。<br>ApplicationContext：</p><ol><li>继承了 BeanFactory，拥有了基本的 IoC 功能；</li><li>除此之外，ApplicationContext 还提供了以下功能：</li></ol><ul><li>支持国际化；</li><li>支持消息机制；</li><li>支持统一的资源加载；</li><li>支持AOP功能；</li></ul><h2 id="IoC容器初始化与依赖注入"><a href="#IoC容器初始化与依赖注入" class="headerlink" title="IoC容器初始化与依赖注入"></a>IoC容器初始化与依赖注入</h2><p>我们知道，IoC容器负责管理对象，而spring中最基本的一个对象就是Bean。<br>Bean的定义与初始化是两大步骤，Bean在定义后，IoC容器才将其初始化并注入到其他对象中。<br>Bean的定义有3步：  </p><ol><li>Resource 定位<br>Spring IoC 容器先根据开发者的配置，进行资源的定位，在 Spring 的开发中，通过 XML 或者注解方式查找资源。  </li><li>BeanDefinition 的载入<br>这个时候只是将 Resource 定位到的信息，保存到 Bean 定义（BeanDefinition）中，此时并不会创建 Bean 的实例</li><li>BeanDefinition 的注册<br>这个过程就是将 BeanDefinition 的信息发布到 Spring IoC 容器中。   </li></ol><p>但此时Bean并没有被初始化，只是在容器中被定义了。在Spring Bean的配置中，有个配置选项lazy-init，指定是否初始化Bean，默认值为false，即自动初始化，而设置为true则只有当使用getBean方法获取Bean时，才会进行Bean的初始化，完成依赖注入。  </p><h2 id="如何实现IoC容器？"><a href="#如何实现IoC容器？" class="headerlink" title="如何实现IoC容器？"></a>如何实现IoC容器？</h2><p>实现一个IoC容器有以下几个步骤。  </p><ol><li>通过注解或者配置文件，查看A类的依赖对象是哪个类，获取类名。  </li><li>使用反射API，将类名实例化成对象实例。  </li><li>将实例化对象通过构造函数或者setter方法，传递给A类。  </li></ol><p>其实Spring就是基于以上几个步骤实现IoC，IoC就是工厂模式的升级版。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文基本上都是基础知识，重点讲了IoC的概念，并顺便谈了IoC的实现原理，之后有需要的话可能会深入spring源码了解更多IoC的细节，比如BeanFactory和ApplicationContext。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;IoC本身来说并不是一种技术，而是一种思想。在spring开发中我们常常使用，但有时候想起来这个概念时，却不知道从何说起。本文就来谈谈spr
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="java" scheme="http://re0.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java线程池</title>
    <link href="http://re0.top/2020/07/24/java_thread_pool/"/>
    <id>http://re0.top/2020/07/24/java_thread_pool/</id>
    <published>2020-07-24T05:10:00.000Z</published>
    <updated>2020-07-24T10:05:42.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇来讲讲Java中线程池的使用与分析。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>阿里巴巴Java开发手册中强调，线程资源必须通过线程池来提供，不允许显式创建线程。<br>首先我们讲讲普通的线程创建方式。  </p><h2 id="Java线程创建方式"><a href="#Java线程创建方式" class="headerlink" title="Java线程创建方式"></a>Java线程创建方式</h2><p>在Java语言中，我们通过两种方式创建一个新线程，分别是继承Thread类或者实现Runnable接口。</p><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>Thread类本质上是实现了Runnable接口的一个实例，启动线程的方法是通过Thread类的start方法，这个方法是native方法，它将启动线程，并在获得时间片后执行run方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThread run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><p>如果该类已经继承其他类，由于java是单继承，所以只能实现runnable接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThread run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>这里值得一提的是，start方法是启动一个线程，线程处于就绪状态，而run方法则是直接执行，线程进入了运行状态。start方法之后会直接执行完毕，等待后续cpu的调度来执行这个线程，如果是run方法则直接在当前线程运行了方法，影响接下来的代码。因此只有start方法才能是多线程执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).run();</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 输出两个main 如果是start方法，输出不同线程。</span></span><br></pre></td></tr></table></figure></p><p>通常情况下如果需要一个异步操作，那直接在类里new Thread实例并传入Runnable实例，重写run方法就可以简单实现一个多线程操作，但这种方法并不提倡。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></p><h2 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h2><p>前面说了创建线程的方式，那为什么阿里不让程序员这样创建线程呢？原因在于以下几点：</p><ul><li>每次new Thread实例性能会逐渐变差。</li><li>线程没法统一管理，容易出现线程无限制创建，严重会有线程间相互竞争导致死锁，再严重些会导致占用过多资源而导致OOM。   </li></ul><p>而相比于new Thread，Java中提供的四种线程池有几点好处：</p><ul><li>在创建和销毁线程时所消耗时间与系统资源的开销大幅度减小。  </li><li>可以提供定时执行，并发控制等高级功能。 </li></ul><h2 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h2><p>Java中通过Executors提供四种线程池，分别为：  </p><ul><li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</li><li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。  </li></ul><p>Executors源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">            (parallelism,</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">            (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, threadFactory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>我们查看源码可以知道，Executors类使用了ThreadPoolExecutor类创建了一个简单线程池。我们接着跟进ThreadPoolExecutor类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们得知，ThreadPoolExecutor提供了四种构造器，但前三种构造器其实是调用了第四种构造方法而已。接下来看看几个参数的作用：  </p><ul><li>corePoolSize： 线程池核心线程数最大值</li><li>maximumPoolSize： 线程池最大线程数大小</li><li>keepAliveTime： 线程池中非核心线程空闲的存活时间大小</li><li>unit： 线程空闲存活时间单位</li><li>workQueue： 存放任务的阻塞队列</li><li>threadFactory： 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。</li><li>handler：  线城池的饱和策略事件，主要有四种类型。  </li></ul><p>我们可以看看源码中线程池的执行流程，即execute方法，源码中的注释已经十分清楚。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>翻译一下： </p><ul><li>提交一个任务，如果线程池中存活的核心线程小于线程数corePoolSize，线程池会创建一个核心线程去处理提交的任务。</li><li>如果核心线程池已满，一个新的任务会放到任务队列workQueue中排队等待执行。</li><li>当corePoolSize已满，并且workQueue也满，判断线程数是否达到maximumPoolSize，如果没达到，就创建一个非核心线程来执行任务。</li><li>如果线程数达到maximumPoolSize，直接采取拒绝策略。</li></ul><p>顺带一提四种拒绝策略： </p><ul><li>AbortPolicy(抛出一个异常，默认的)</li><li>DiscardPolicy(直接丢弃任务)</li><li>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</li><li>CallerRunsPolicy（交给线程池调用所在的线程进行处理) </li></ul><p>至此，线程池的工作原理基本上讲完了。但在阿里巴巴Java开发手册中有这么一条：  </p><blockquote><p>【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors返回的线程池对象的弊端如下： 1） FixedThreadPool和SingleThreadPool： 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。 2） CachedThreadPool： 允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。  </p></blockquote><p>仔细看源码，确实Executors在创建线程池时，workQueue并没有指定最大大小，可能会导致堆积大量的请求，即没有实行拒绝策略。 </p><h2 id="线程池的工作队列"><a href="#线程池的工作队列" class="headerlink" title="线程池的工作队列"></a>线程池的工作队列</h2><ul><li>ArrayBlockingQueue：有界队列，使用数组实现，FIFO。</li><li>LinkedBlockingQueue：基于链表的可设置容量的阻塞队列，默认最大长度为Integer.MAX_VALUE。</li><li>DelayQueue：延迟队列，是一个任务定时周期的延迟执行的队列。根据指定的时间从小到大排列，否则否则根据插入到队列的时间先后排序。</li><li>PriorityBlockingQueue：优先级队列。</li><li>SynchronousQueue：同步队列，不存储元素，每个插入操作必须等到另一个线程进行移除操作，否则一直阻塞。</li></ul><h2 id="几种常见线程池"><a href="#几种常见线程池" class="headerlink" title="几种常见线程池"></a>几种常见线程池</h2><p>前面只是稍微提到几种线程池，这边详细说说每种线程池。</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>源码在上头，这里我就不贴了。可以知道，这个线程池特点是核心线程数与最大线程数相同，并且没有非空闲时间，即keepAliveTime为0，再有就是阻塞队列使用的是LinkedBlockingQueue。<br>在Executors中newFixedThreadPool的阻塞队列是无界的，也就是如果核心线程执行的时间过长，会导致大量的任务插入到队列中，最终导致OOM。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; Integer.MAX_VALUE;i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded</span></span><br></pre></td></tr></table></figure></p><p>因此fixedThreadPool适用于cpu密集的任务，cpu长期被使用的情况下，尽可能少分配线程，适合执行长期的任务。  </p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>这个线程池的核心线程数为0，最大线程数为Integer.MAX_VALUE，阻塞队列为SynchronousQueue，非核心线程的空闲存活时间为60秒。<br>因为没有核心线程，所以添加任务后直接添加进阻塞队列，判断是够有空闲进程，如果有，取出去执行任务，如果没有，就创建一个线程执行，执行完任务的线程有60秒的存活时间，如果再次接到任务，则可以活下去，否则被销毁。<br>这种线程池适合并发执行短期的小任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"   "</span> + System.currentTimeMillis() + <span class="string">"   running now"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如果提交任务速度小于处理任务的速度，则只会使用一个线程重复使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"   "</span> + System.currentTimeMillis() + <span class="string">"   running now"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>特点为核心线程数为1，最大线程数也为1，阻塞队列是LinkedBlockingQueue，keepAliveTime为0。<br>这个线程池的特点就是只有一个线程在工作，如果有任务到来，线程空闲就执行任务，线程繁忙就把任务加到阻塞队列中，直到线程从队列中取出任务执行。<br>适合串行执行任务的场景。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"   "</span> + System.currentTimeMillis() + <span class="string">"   running now"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>特点是最大线程数为Integer.MAX_VALUE，阻塞队列是DelayedWorkQueue，keepAliveTime为0。<br>工作机制为：添加一个任务到阻塞队列中，线程池中的线程从阻塞队列中取任务，取time大于当前时间的任务，执行完将任务的time修改为下次执行的时间，并将这个任务放到阻塞队列中。<br>这种线程池适合周期执行定时任务的场景。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        executorService.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"   "</span> + System.currentTimeMillis() + <span class="string">"   running now"</span>);</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h1><p>本文讲了Java中四种常见的线程池，并学习相应的工作原理与应用常见，尽管阿里开发手册中不允许直接使用Executors中的线程池，但理解这几种线程池十分重要，如果需要创建线程池的话，可以通过ThreadPoolExecutor自定义所有参数来创建，让代码阅读者明白为什么要这样创建。通过这次的学习，对java线程池的理解确实有学到不少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇来讲讲Java中线程池的使用与分析。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="java" scheme="http://re0.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈动态规划Ⅲ</title>
    <link href="http://re0.top/2020/07/20/dp3/"/>
    <id>http://re0.top/2020/07/20/dp3/</id>
    <published>2020-07-20T08:10:00.000Z</published>
    <updated>2020-07-23T15:21:11.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近准备秋招感觉自己还是蛮菜的，啥都不会。但学习还是得继续，偶尔趁着休息时间来写写文章。这篇大概是最后一篇整理动态规划题目，感觉整理多了也没用，只有自己去理解才真正有用。话不多说，开始正文。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="地下城游戏"><a href="#地下城游戏" class="headerlink" title="地下城游戏"></a>地下城游戏</h2><blockquote><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。为了尽快到达公主，骑士决定每次只向右或向下移动一步。   </p></blockquote><p>来自<a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener">leetcode 174题</a><br>这道题目很像我在<a href="/2020/04/05/dp1/">浅谈动态规划Ⅰ</a>中所讲的入门题目，即最小路径权重问题。但如果我们从左上角开始进行动态规划，我们只能知道起点到终点的所需要最小血量，但是<strong>并不能保证当到达每个点时的血量不低于1</strong>。所以我们采用反向dp，即从右下角往起点进行动态规划。<br>我们令dp[i][j]为坐标(i,j)到终点所需要的最小血量。那么我们的最终答案就是dp[0][0]。<br>接下来是动态转移方程。我们先考虑dp[m-1][n-1]，也就是终点到终点需要的血量，很容易想到，应该是<code>max(1,1-dungeon[m-1][n-1])</code>，因为血量不能低于1，如果有怪物的话需要怪物血量加上1，两者取大值。<br>那其他点呢，很简单，我们需要的最少血量，而且每次只能从右或者从下走一格，因为我们是反向dp，(i,j)坐标获取的状态应该是(i+1,j)和(i,j+1)，所以对应的应该是dp[i+1][j]和dp[i][j+1]的较小值，再减去当前坐标的值，与1对比取大值，即<code>dp[i][j] = max(1,min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j])</code>。<br>在dp数组空间的选择上，有两个选择，一种是m*n，另一种是 (m+1)*(n+1)，这两个选择其实是对边界的处理有差别。<br>如果采用m*n的数组空间，那么我就必须对dp[m-1][n-1]，即终点位置进行独立地初始化，并且需要对dp[i][n-1]与dp[m-1][j]这一行一列进行独立赋值，避免数组越界。<br>而采用(m+1)*(n+1)的空间，只需要把外围空间赋值为无穷大，并对终点的下方和右方赋值为1，便可实现使用一个状态转移方程完成全部计算。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//m*n</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dungeon == <span class="keyword">null</span> || dungeon.length == <span class="number">0</span> || dungeon[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = dungeon.length;</span><br><span class="line">        <span class="keyword">int</span> n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        dp[m-<span class="number">1</span>][n-<span class="number">1</span>] = Math.max(<span class="number">1</span>,<span class="number">1</span>-dungeon[m-<span class="number">1</span>][n-<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m-<span class="number">2</span>;i &gt; -<span class="number">1</span>;i--)&#123;</span><br><span class="line">            dp[i][n-<span class="number">1</span>] = Math.max(<span class="number">1</span>,dp[i+<span class="number">1</span>][n-<span class="number">1</span>] - dungeon[i][n-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">2</span>;i &gt;-<span class="number">1</span>;i--)&#123;</span><br><span class="line">            dp[m-<span class="number">1</span>][i] = Math.max(<span class="number">1</span>,dp[m-<span class="number">1</span>][i+<span class="number">1</span>] - dungeon[m-<span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m-<span class="number">1</span>;i &gt; -<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n-<span class="number">1</span>;j &gt; -<span class="number">1</span> ; j--)&#123;</span><br><span class="line">                dp[i][j] = Math.max(<span class="number">1</span>,Math.min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]) - dungeon[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(m+1)*(n+1)空间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dungeon == <span class="keyword">null</span> || dungeon.length == <span class="number">0</span> || dungeon[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = dungeon.length;</span><br><span class="line">        <span class="keyword">int</span> n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[n][m - <span class="number">1</span>] = dp[n - <span class="number">1</span>][m] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m-<span class="number">1</span>;i &gt; -<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n-<span class="number">1</span>;j &gt; -<span class="number">1</span> ; j--)&#123;</span><br><span class="line">                dp[i][j] = Math.max(<span class="number">1</span>,Math.min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]) - dungeon[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但其实只是因为第二种方法更简单些，并且不用额外初始化，时间复杂度是一样的。如果要更进一步，因为dp[i][j]状态只与dp[i+1][j]与dp[i][j+1]有关，所以我们可以使用滚动数组方法来降低空间复杂度，这里就不再展开。  </p><h2 id="最低票价"><a href="#最低票价" class="headerlink" title="最低票价"></a>最低票价</h2><blockquote><p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。火车票有三种不同的销售方式：<br>一张为期一天的通行证售价为 costs[0] 美元；<br>一张为期七天的通行证售价为 costs[1] 美元；<br>一张为期三十天的通行证售价为 costs[2] 美元。<br>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。<br>返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。  </p></blockquote><p>来自<a href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/" target="_blank" rel="noopener">leetcode 983题</a><br>思路还是比较简单的，先定义状态，很显然，这是个一维dp问题，所有我们定义dp[i]为第i天所需要花费的费用。</p><ul><li>如果当天没有旅游，那么dp[i] = dp[i-1]</li><li>如果当前是旅游的，那么我们应该从三种方案中选择最小花费，也就是dp[i] = min(dp[i-1]+costs[0],dp[i-7]+cost[1],dp[i-30]+costs[2]).这里需要注意数组越界问题。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="keyword">int</span>[] days, <span class="keyword">int</span>[] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = days.length;</span><br><span class="line">        <span class="keyword">int</span> m = days[n-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">int</span> day_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i != days[day_index])&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                day_index++;</span><br><span class="line">                dp[i] = min(dp[Math.max(<span class="number">0</span>,i-<span class="number">1</span>)]+costs[<span class="number">0</span>],dp[Math.max(<span class="number">0</span>,i-<span class="number">7</span>)]+costs[<span class="number">1</span>],dp[Math.max(<span class="number">0</span>,i-<span class="number">30</span>)] + costs[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(Math.min(a,b),c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </li></ul><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><blockquote><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。<br>注意：你不能在买入股票前卖出股票。</p></blockquote><p>来自<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">leetcode 121题</a><br>这道题目其实只要一次遍历过程中维护一个最小值就可以解决。如果用动态规划的解法呢？<br>买卖股票，无非就是两种状态，一种买入，一种卖出，两种状态我们定义二维数组dp，先定义买入收益为dp[0](注意这里收益是负的)，卖出的收益为dp[1]，买入的成本应该是<code>dp[0][i] = max(dp[0][i-1],-prices[i])</code>，因为是负数，所以用max。而卖出的收益应该为第i-1天卖出的收益与i-1天时买入收益加上当天股价，取两者较大者，即<code>dp[1][i] = max(dp[1][i-1],dp[0][i-1]+prices[0])</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][n];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][i] = Math.max(dp[<span class="number">1</span>][i-<span class="number">1</span>],dp[<span class="number">0</span>][i-<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[<span class="number">0</span>][i] = Math.max(dp[<span class="number">0</span>][i-<span class="number">1</span>],-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n-<span class="number">1</span>]; <span class="comment">// 最大收益只在卖出状态中产生。</span></span><br><span class="line">        <span class="comment">// return Math.max(dp[0][n-1],dp[1][n-1]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>上面代码中第一维是状态，第二维是时间。<br>我们可以更换一下以更好理解下一道题目。dp[i]代表第i天，dp[i][0]代表第i天卖出的收益(即不持股)，而dp[i][1]代表第i天买入的收益(即持股)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><h2 id="买卖股票的最佳时机Ⅱ"><a href="#买卖股票的最佳时机Ⅱ" class="headerlink" title="买卖股票的最佳时机Ⅱ"></a>买卖股票的最佳时机Ⅱ</h2><p>来自<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">leetcode 122题</a><br>这道题相比上一道，多了一个可以多次买卖的条件。因此买入的状态可以由卖出的状态来进行转移，即持股的状态可以由不持股的状态转移而来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><h2 id="买卖股票的最佳时机含冻结期"><a href="#买卖股票的最佳时机含冻结期" class="headerlink" title="买卖股票的最佳时机含冻结期"></a>买卖股票的最佳时机含冻结期</h2><p>这道题比上面那道多了一个冻结期，即卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)，并且不限制买卖次数。<br>来自<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">leetcode 309题</a><br>这道题由于多了冻结期的概念，所以应该比上一道题多一种状态，dp[i]依旧表示第i天的收益，而第二维有三个状态，分别为不持股，持股，冻结期。然后分析状态转移方程，首先不持股是由昨天不持股和昨天持股今天买股两种状态转移而来，而持股的状态则是由昨天持股与昨天冻结，今天买股两个状态转移而来。<br>翻译成代码就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是本次整理的几道题目，我个人感觉股票问题是十分经典的，并且层层递进，还有几道股票题目没有整理出来，如果有闲下来的时间，下次再整理吧。整理题目也算是一种复习吧，感觉对动态规划的理解又加深不少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近准备秋招感觉自己还是蛮菜的，啥都不会。但学习还是得继续，偶尔趁着休息时间来写写文章。这篇大概是最后一篇整理动态规划题目，感觉整理多了也没
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>浅谈数据库主从复制</title>
    <link href="http://re0.top/2020/07/04/database_master_slave/"/>
    <id>http://re0.top/2020/07/04/database_master_slave/</id>
    <published>2020-07-04T05:10:00.000Z</published>
    <updated>2020-07-04T09:27:17.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前陆陆续续写了几篇高并发架构的文章，本篇文章是浅谈高并发架构系列的最后一篇。<br>前面说过，单点故障是影响整个高并发系统的重要原因，在单点的服务出现故障时有可能影响整个系统的运行。而数据库作为数据存放的服务，是最底层的服务，使用的频率也是非常高的。因此有必要将单点数据库系统进行多节点复制，以至于在一个节点出现故障时，另一个节点能够提供正常的数据库服务，这种方式也被称为容灾。<br>今天这篇文章讲的是将数据库进行多节点复制，也就是数据库的主从复制，从而达到多个数据库服务同时存在和正常运行的目的。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h2><p>前面说过，主从复制的一个优点就是做数据的备份，当主数据库故障后，可以马上切换数据库，防止数据的丢失。其次，可以加快数据库的存储与写入，例如不同的数据库负责不同的事物，例如读写分离，提升单机的性能。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们这里就使用mysql作为数据库。<br>mysql服务中，有一个文件叫做二进制日志文件(binary log file)，通常这个文件需要手动开启，这个文件记录着所有执行的操作，如果一台服务器启用这个文件后，那另一台服务器就可以通过读取这个文件，将master的所有操作都复制到自己身上，从而达到数据库的主从复制。<br>通常情况下，可以分为以下几个步骤执行：  </p><ol><li>主库启用bin log，所有事件都会写入到日志当中。</li><li>从库启用slave服务，连接到主库。</li><li>从库创建一个I/O线程，从主库读取到bin log内容并写入relay log中。</li><li>从库创建一个SQL线程，从relay log中读取内容，并将更新内容写入到从库。 </li></ol><p>值得一提的是，老版本的mysql其实读取与执行操作是由一个线程完成的，导致复制bin log与执行操作是一个串行的过程，性能受到限制。后来为了提高性能，便将这个两个操作交由两个线程完成。  </p><h2 id="深入了解"><a href="#深入了解" class="headerlink" title="深入了解"></a>深入了解</h2><p>从上面我们可以知道主从复制的基本原理与操作，接下来我们讲讲常见的主从配置。  </p><h3 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h3><p>这个配置是最常见的，也是最简单的架构，slave之前并不通信，而是只与master进行通信。这种架构广泛应用在读压力较大的场景中。  </p><h3 id="主主复制"><a href="#主主复制" class="headerlink" title="主主复制"></a>主主复制</h3><p>这个情况下，两个数据库即是master，又是相互的slave。这样任何一方有变更，便会同步到另一方的数据库中。这个架构其实可以变为主动-被动mm架构与带从服务器的mm架构。</p><ul><li>主动-被动模式的Master-Master(Master-Master in Active-Passive Mode)<br>这种模式是一种具有容错与高可用的架构，即一个节点故障之后马上会有另一个节点接替服务，也就是我们上文所提到的可实现高可用的架构。 </li><li>带从服务器的Master-Master(Master-Master with Slaves)<br>这种模式提供了冗余，即在保证高可用架构的同时，将读请求放在slave上，提高数据库的整体性能。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文重点讲述了mysql主从复制的原理与几种主从架构，但是对如何配置并没有详细讲解，之后在项目中遇到会稍微写写。<br>那这个浅谈高并发架构就告一段落了，如果有更深入的理解，我也会第一时间写出来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前陆陆续续写了几篇高并发架构的文章，本篇文章是浅谈高并发架构系列的最后一篇。&lt;br&gt;前面说过，单点故障是影响整个高并发系统的重要原因，在单
      
    
    </summary>
    
    
      <category term="架构" scheme="http://re0.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="数据库" scheme="http://re0.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>常见的负载均衡算法</title>
    <link href="http://re0.top/2020/06/24/load_balancing_algorithm/"/>
    <id>http://re0.top/2020/06/24/load_balancing_algorithm/</id>
    <published>2020-06-24T09:10:00.000Z</published>
    <updated>2020-06-25T07:36:44.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章讲了负载均衡的几种实现方式，这期就重点讲讲当请求到达负载均衡服务器时，服务器可以根据哪些算法来进行分配请求。 </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="轮询法"><a href="#轮询法" class="headerlink" title="轮询法"></a>轮询法</h2><p>这种方法很简单，就是按照顺序轮流将请求分配到各个服务器上，对服务器的状态和负载情况并不关注。<br>由于需要对pos变量进行操作，如果是高并发场景必须加写锁，并且会导致并发吞吐量的明显下降。<br>以下代码实现了一个简单的轮询。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BalanceServer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.servers = [<span class="string">"192.168.1.1"</span>,<span class="string">"192.168.1.2"</span>,<span class="string">"192.168.1.3"</span>,<span class="string">"192.168.1.4"</span>]</span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_server</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.pos == len(self.servers):</span><br><span class="line">            self.pos = <span class="number">0</span></span><br><span class="line">            <span class="comment"># self.pos %= len(self.server)</span></span><br><span class="line">        </span><br><span class="line">        server = self.servers[self.pos]</span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> server</span><br></pre></td></tr></table></figure></p><h2 id="随机法"><a href="#随机法" class="headerlink" title="随机法"></a>随机法</h2><p>这种方法与轮询差不多，将请求进行随机分配，当分配量足够大时，相当于将请求平均分配到每个服务器上。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BalanceServer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.servers = [<span class="string">"192.168.1.1"</span>,<span class="string">"192.168.1.2"</span>,<span class="string">"192.168.1.3"</span>,<span class="string">"192.168.1.4"</span>]</span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_server_by_random</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.servers[random.randint(<span class="number">0</span>,len(self.servers)<span class="number">-1</span>)]</span><br></pre></td></tr></table></figure></p><h2 id="源地址hash法"><a href="#源地址hash法" class="headerlink" title="源地址hash法"></a>源地址hash法</h2><p>这种方法是通过获取访问客户端的ip地址，通过hash函数算出ip地址的hash值，然后通过hash值对服务器列表长度取模，获得访问的服务器序号。<br>这种方法的好处在于每次客户端访问的服务器都是同一个，便于建立有状态的session会话。<br>而缺点在于如果有服务器扩展或者下线时，如果通过源地址hash算法获得的服务器资源可能会不存在，如session或者缓存，导致请求的失败。如果是缓存服务器，则可能导致缓存击穿或者缓存雪崩(详见下文)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BalanceServer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.servers = [<span class="string">"192.168.1.1"</span>,<span class="string">"192.168.1.2"</span>,<span class="string">"192.168.1.3"</span>,<span class="string">"192.168.1.4"</span>]</span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_server_by_origin_hash</span><span class="params">(self,ip)</span>:</span></span><br><span class="line">        ip_hash_code = hash(ip)</span><br><span class="line">        server = self.servers[ip_hash_code % len(self.servers)]</span><br><span class="line">        <span class="keyword">return</span> server</span><br></pre></td></tr></table></figure></p><h2 id="加权轮询法（Weight-Round-Robin）"><a href="#加权轮询法（Weight-Round-Robin）" class="headerlink" title="加权轮询法（Weight Round Robin）"></a>加权轮询法（Weight Round Robin）</h2><p>不同性能和配置的服务器对请求的抗压能力也不相同，让配置高，负载低的机器更高的权重，处理更多的请求，而配置低，负载高的机器则权重降低。通过权重我们可以重新构建服务器列表，然后再通过轮询获取服务器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BalanceServer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.servers = &#123;</span><br><span class="line">            <span class="string">'192.168.1.1'</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="string">'192.168.1.2'</span>:<span class="number">3</span>,</span><br><span class="line">            <span class="string">'192.168.1.3'</span>:<span class="number">4</span>,</span><br><span class="line">            <span class="string">'192.168.1.4'</span>:<span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_server_by_weight_round_robin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 这里可以避免服务器上下线</span></span><br><span class="line">        servers_list = []</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> self.servers.keys():</span><br><span class="line">            weight = self.servers[key]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(weight):</span><br><span class="line">                servers_list.append(key)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># self.pos需要加锁</span></span><br><span class="line">        <span class="keyword">if</span> self.pos &gt;= len(servers_list):</span><br><span class="line">            self.pos = <span class="number">0</span></span><br><span class="line">        server = servers_list[self.pos]</span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> server</span><br></pre></td></tr></table></figure></p><p>注意，这里的服务器的权重应该根据状态动态调整，而不是只是一个固定值。  </p><h2 id="加权随机法"><a href="#加权随机法" class="headerlink" title="加权随机法"></a>加权随机法</h2><p>和加权轮询法类似，只是在最后选择服务器上使用随机数，这里便不多说了。  </p><h2 id="最小连接数法"><a href="#最小连接数法" class="headerlink" title="最小连接数法"></a>最小连接数法</h2><p>这种方法较为灵活，它是站在后端服务器的角度，根据当前服务器集群的连接情况，动态选取一台当前积压连接数最少的服务器来处理本次请求，合理的进行分流。 </p><h2 id="后续思考"><a href="#后续思考" class="headerlink" title="后续思考"></a>后续思考</h2><h3 id="使用hash算法的问题"><a href="#使用hash算法的问题" class="headerlink" title="使用hash算法的问题"></a>使用hash算法的问题</h3><p>上文提到使用源地址hash算法选取服务器的问题，在有服务器上下线的情况下，缓存在对应的机器上没有，可能会导致诸多问题，轻一点的就是session消失，用户需要重新登录，而如果严重一点的话则会导致瞬间大量的请求获取不到缓存，从而把大量请求直接往db中打，轻则阻塞，重则宕机。我们举个例子：<br>假设刚开始有4台缓存服务器，分别为0,1,2,3号，hash(ip) = 6 ，那么hash(ip) % 4 = 2，那么我们就应该去2号缓存服务器上拿缓存。假设此时多了一台服务器4号，那么hash(ip) % 5 = 1，我们就变成了去1号缓存服务器拿缓存，那么可想而知，如果请求量够大，一瞬间就有去新服务器拿旧服务器的缓存，而新服务器没有缓存，就会去数据库中查找，相当于大规模的缓存瞬间失效了，导致<strong>缓存雪崩</strong>。 </p><h3 id="缓存穿透，缓存击穿，缓存雪崩"><a href="#缓存穿透，缓存击穿，缓存雪崩" class="headerlink" title="缓存穿透，缓存击穿，缓存雪崩"></a>缓存穿透，缓存击穿，缓存雪崩</h3><p>这三个概念不是本文重点，这里只是提个概念。<br>缓存穿透是指请求查询了一个不存在的数据，导致每次都去数据库查询，缓存服务器相当于失效，这种情况叫做缓存穿透。<br>缓存击穿是指大量的请求同时查询了一个已经失效的缓存，导致这些请求集体请求数据库。<br>缓存雪崩则是指某个时间发生了大规模的缓存失效问题，如缓存服务器宕机，或者是上文讲的由于hash取模所带来的问题。  </p><h3 id="一致性hash算法"><a href="#一致性hash算法" class="headerlink" title="一致性hash算法"></a>一致性hash算法</h3><p>由于常用的hash(obj) % N算法在对机器添加或者删除之后，会导致原来的许多数据无法找到，所以一致性hash算法诞生了。<br>一致性hash算法首先需要将0~(2^32)-1的数字形成一个环，可以想象成一个时钟。接着我们先将数据存储在环上，用上文的例子，即<br><code>hash(ip1)=key1,hash(ip2)=key2,hash(ip3)=key3</code>，<br>   这些key就是在环上的数字。接着我们同样通过hash算法将服务器的hash值映射到环上，例如<br><code>hash(server1)=KEY1,hash(server2)=KEY2,hash(server3)=KEY3,hash(server4)=KEY4</code>，<br>我们假设KEY1~KEY4分别在环的12点，3点，6点，9点钟方向，key1~key3分别在1点，4点，8点钟位置。<br>接着我们便可将key缓存到顺时针离自己最近的服务器上。即key1缓存在hash值KEY2的服务器上，key2缓存在KEY3的服务器上，key3缓存在KEY4的服务器上。<br><strong>接下来是机器的删除与添加。</strong>  </p><ol><li>删除<br>假设2号服务器宕机，即hash值为KEY3的服务器移除了，也就是6点钟的服务器移除了，那么影响到的只有key2，key2的映射位置从2号服务器移到3号服务器，也就是只有原本2号服务器上的数据收到影响，而没有改变其他服务器。  </li><li>添加<br>假设添加了一台服务器，hash(server5)位于时钟的2点钟方向，那么根据顺时针迁移，则key1的数据迁移到该服务器上，其他对象没有影响。  </li></ol><p>一致性hash算法将数据的迁移达到了最小，只有一部分数据需要迁移，而不是所有数据都进行迁移，这样的算法对于高并发，分布式的服务是十分合适的，避免了大量数据的迁移，减小了服务器压力。<br>如果文字讲解不够清楚的话，推荐可以看看<a href="https://blog.csdn.net/cywosp/article/details/23397179" target="_blank" rel="noopener">图解</a>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文讨论了负载均衡的几种算法，并对hash算法带来的数据迁移问题进行讨论，讲解了一致性hash算法来解决问题。本文对于缓存服务出现的三种问题并没有深入讨论，没有提出解决方案，这部分内容之后也会单独写写。那么这个高并发系列就还剩下数据库的主从复制。<br>ps.由于图床的原因，最近的文章都没有添加图片，主要是不好管理，虽然有备份，但图床失效后，后续迁移工作十分繁琐，所以作者尽量不添加图片来讲述原理，望理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇文章讲了负载均衡的几种实现方式，这期就重点讲讲当请求到达负载均衡服务器时，服务器可以根据哪些算法来进行分配请求。 &lt;/p&gt;
&lt;h1 i
      
    
    </summary>
    
    
      <category term="架构" scheme="http://re0.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>浅谈负载均衡</title>
    <link href="http://re0.top/2020/06/15/load_balancing/"/>
    <id>http://re0.top/2020/06/15/load_balancing/</id>
    <published>2020-06-15T09:10:00.000Z</published>
    <updated>2020-06-20T08:56:06.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面对大量的访问请求与海量的数据，我们可以通过加大单机的性能来实现服务的稳定，还可以考虑拆分系统来防止单机故障。<br>负载均衡（Load Balance）是指将负载（例如访问请求，任务等等）进行平衡分摊到多个服务器或组件上执行，以提高性能，作为单点故障的解决方案。<br>本文将讨论常见的负载均衡分类。</p><h1 id="负载均衡分类"><a href="#负载均衡分类" class="headerlink" title="负载均衡分类"></a>负载均衡分类</h1><p>从实现方式不同，可以分为软件实现与硬件实现。从实现的节点不同，我们可以分为DNS负载均衡，HTTP负载均衡，IP负载均衡，链路层负载均衡等等。</p><h2 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h2><p>这是一种利用域名解析来实现的负载均衡技术，在DNS服务器上配置多个A记录，这些A记录对应的是服务器集群，在大型网站中，DNS解析通常作为第一级负载均衡。<br>优点有：  </p><ul><li>使用简单，全交给DNS服务器来处理，不需要额外配置负载均衡服务器。  </li><li>基于用户的地址，可以解析成距离用户最近的服务器地址，加快访问速度。  </li></ul><p>缺点有：  </p><ul><li>DNS服务是多级服务，在增加或者修改DNS后，需要较长时间才能传递到全网。在这段时间内用户可能会访问失败。  </li><li>维护性差。由于DNS服务不能知道服务器的负载情况，所以支持的算法较少，无法根据服务器当前负载量进行调节。  </li><li>DNS的控制器通常来说在域名商手里，导致无法做更多的扩展。  </li></ul><h2 id="HTTP负载均衡"><a href="#HTTP负载均衡" class="headerlink" title="HTTP负载均衡"></a>HTTP负载均衡</h2><p>这是一种利用反代技术来转发HTTP流量的技术，通常使用Nginx作为负载均衡工具，在用户的HTTP请求到达后，由反向代理服务器根据算法，将HTTP请求发送给相应的服务器，服务器完成处理后，再将数据返回给代理服务器，由代理服务器将数据转交给用户。<br>优点有：  </p><ul><li>没有暴露真实服务器ip。可以有效的隐藏内网信息。  </li><li>支持的算法较多，可以根据需求不同来配置不同负载均衡策略。 </li><li>安装和配置相对简单。  </li></ul><p>缺点有：  </p><ul><li>对服务器的健康检查只支持端口检测，而不支持url检测。如出现错误，则会转至另一服务器进行重试。  </li><li>适用的范围较小，只支持http，https等协议。  </li></ul><h2 id="IP负载均衡"><a href="#IP负载均衡" class="headerlink" title="IP负载均衡"></a>IP负载均衡</h2><p>在网络层通过修改目的地址来实现负载均衡。用户请求到达负载均衡服务器后，负载均衡服务器从负载均衡算法得到一个真实服务器地址，将ip数据报的目的地址改为改真实服务器的地址。真实服务器处理完成后，将响应数据包返回给负载均衡服务器，负载均衡服务器再将ip数据报的源地址改为自身的ip地址，发送给用户。<br>其中，真实服务器将数据返回给负载均衡服务器时，存在两种方式，第一种是负载均衡服务器作为真实服务器集群的网关，则不用配置其他东西。第二种方式是负载均衡服务器在修改目的ip地址的同时修改源地址，然后就可从真实服务器收到返回数据，这种方式成为源地址转换(snat)。  </p><h2 id="链路层负载均衡"><a href="#链路层负载均衡" class="headerlink" title="链路层负载均衡"></a>链路层负载均衡</h2><p>工作在数据链路层，通过修改mac地址来进行负载均衡。在用户请求到达时，不修改ip地址，而是修改目的mac地址，配置真实服务器集群与负载均衡服务器的ip一致，达到不修改ip地址来进行数据转发。这种方式也成直接路由模式（DR模式）。     </p><h2 id="混合型负载均衡"><a href="#混合型负载均衡" class="headerlink" title="混合型负载均衡"></a>混合型负载均衡</h2><p>通常作为一个大型架构，不会只使用一种负载均衡方案，而是采用多个负载均衡方案来实现。<br>这里举个简单方式：<br>用户进行DNS查询时，由DNS服务器根据负载均衡算法返回不同的反向代理服务器，再由反向代理服务器将请求分配给应用负载均衡服务器，接着由应用负载均衡服务器通过ip模式或者DR模式进行请求转发。<br>这种方式反向代理服务器不仅用于请求的转发，并且可以缓存静态资源，当请求是静态资源时，可以直接返回，而不是将请求进行转发。如果是动态页面时，则请求后面的应用负载均衡服务器。  </p><p>由于混合模式需要根据具体场景来灵活搭配各种方式，所以以上的方式仅供参考。  </p><h2 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h2><p>硬件负载均衡是直接在服务器与外部网络间安装负载均衡设备。一般而言，硬件负载均衡在功能、性能上优于软件方式。硬件负载均衡通常用作全局负载均衡，搭配软件负载均衡来实现整个负载均衡架构。常见的硬件负载均衡器有F5和A10。<br>优点： 能够直接通过智能交换机实现,处理能力更强，而且与系统无关，负载性能强。<br>缺点： 成本高，配置冗余。负载均衡器可能无法掌握服务器集群的状态，而是从网络的层面来判断负载情况，网络负载正常的情况下，也可能应用层已经阻塞了。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上主要从负载均衡的分类入手，对各种负载均衡进行介绍，并简单介绍了常见负载均衡架构。<br>之后会单独聊聊负载均衡的算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;面对大量的访问请求与海量的数据，我们可以通过加大单机的性能来实现服务的稳定，还可以考虑拆分系统来防止单机故障。&lt;br&gt;负载均衡（Load B
      
    
    </summary>
    
    
      <category term="架构" scheme="http://re0.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>浅谈高并发引起的问题</title>
    <link href="http://re0.top/2020/06/14/high_concurrency/"/>
    <id>http://re0.top/2020/06/14/high_concurrency/</id>
    <published>2020-06-14T05:10:00.000Z</published>
    <updated>2020-06-14T08:40:46.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实在学生时代，基本上是遇不到高并发的架构，真正遇到高并发的问题，往往是在工作之后，我在学生时代所写的很多项目其实跟高并发是一点边都沾不上，但是我依旧学习了许多高并发的知识，希望以后能派上用场。<br>当然，其实脱离了实际去讲述高并发并不是正确的，因为不同的系统架构是不一致的，分析高并发与高可用性需要先分析整体架构再来定夺。<br>本篇文章就是整理在高并发架构下会产生哪些问题，以及部分解决方案，当然也可能将解决方案单独用一篇文章来讲述。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="何为高并发"><a href="#何为高并发" class="headerlink" title="何为高并发"></a>何为高并发</h2><p>高并发（High Concurrency）是系统设计的一个重要概念，它的目的是让系统能够同时<strong>并行</strong>处理多个请求。<br>同时与高并发相关的还有许多名词，如每秒请求数(QPS(Query Per Second))，响应时间(Response Time)，吞吐量(Throughput)等等。   </p><h2 id="高并发所带来的问题"><a href="#高并发所带来的问题" class="headerlink" title="高并发所带来的问题"></a>高并发所带来的问题</h2><p>其实我个人认为高并发带来的问题可以简单分为两个部分，一个是服务故障，另一个是数据的不一致。当然如果数据库服务故障也可能导致数据的不一致性，这里我就简单这么分类。</p><h3 id="服务单点故障"><a href="#服务单点故障" class="headerlink" title="服务单点故障"></a>服务单点故障</h3><p>这个问题是许多架构在遇到高并发请求时所遇到的最基础的问题，如何在如此高的请求量之下保证服务不被击穿。<br>其实解决这个问题的最好办法是将一个系统拆分成多个系统，再配合负载均衡来实现。简单来说，负载均衡器根据每个系统的性能高低分配请求，如果一个系统故障，另一个系统也可以正常提供服务。<br>也就是说要避免单点，而是将单点拓展成多个子系统。<br>这种方案称作服务器集群，一方面是可扩展性强，可以动态添加服务器，另一方面则是可用性较高，缺点就是根据添加的服务器数量，价格也会逐步上升。<br>这个负载均衡架构，之后会单独整理。  </p><h3 id="数据的不一致与不完整"><a href="#数据的不一致与不完整" class="headerlink" title="数据的不一致与不完整"></a>数据的不一致与不完整</h3><p>这个问题是本文的重点，也是为什么整理这篇文章的原因。<br>前些日子，某游戏公司因为访问人数过多导致充值数据不一致，只能进行回档处理。这一事情引发了我的思考，为什么会导致数据不一致呢？其实这里的数据不一致不单单是同时操作数据库中的数据而导致出现问题，也可能是缓存与数据库中数据不一致。<br>举一个例子：<br>存库量不仅在数据库中，也在缓存中加快访问速度，当需要更新操作时，先行修改了数据库，再去删除缓存，如果删除缓存失败了，那么缓存中就是旧数据，而数据库则是新数据，这就导致了一种数据不一致的情况。<br>那这种情况解决方案很简单，就是无论如何先删除缓存，再修改数据库，如果删除缓存成功，修改数据库失败，那么尽管数据库数据是旧的，但是缓存为空，从数据库读取数据，不会出现不一致情况；如果删除缓存失败就不用去修改数据库。如此一来便不会出现数据库与缓存不一致的情况。  </p><p>这里需要说的是，<strong>为什么是删除缓存，而不是更新缓存？</strong><br>原因很简单，在许多复杂的缓存场景中，更新缓存的代价是极高的，例如每次更新完数据库后，是不是要同时更新缓存？但如果频繁修改了一个与缓存相关的表，缓存也会频繁更新，但问题在于缓存是否会被频繁访问？<br>这就是一种懒加载的思想，只有需要缓存的时候我们再去获得缓存。</p><p>接着上一个问题，如果问题更加复杂一下：<br>假设需要修改库存量，我们先删除了缓存，然后更新数据库，如果在更新数据库的同时又来了一个新的请求读取缓存，此时缓存为空则读取数据库，但是查询到的是修改前的旧数据，并且放入了缓存中，此时更新数据库操作完成，但是缓存中是旧数据，而数据库中是新数据，那么怎么解决这个问题？<br>其实很容易想到，就是让读操作永远在写操作后面。比如我们可以使用一个队列，当读取缓存为空时，那么就可以将这个请求加入队列当中，然后队列按顺序执行操作，便可以等到缓存更新后再去读取，保证了数据的一致性。<br>但这种方案也存在一定问题。例如，读操作可能会导致超时，为什么？因为队列中可能会有多个数据的更新操作，如果更新次数过多，会导致读请求长时间阻塞。<br>还有一个问题就是短时间的大量数据库操作，缓存如果在同一个时间失效的话，会导致多个请求同时访问数据库，需要注意数据库的QPS，并且保证缓存不会在同一时间失效。  </p><p>上面是讲数据库与缓存的一致性问题，现在讲讲数据库自身的数据一致性。<br>我们也举一个简单例子：<br>假设我们没有缓存，还是库存量的问题，我们在更新库存时同时来了多个请求更新库存量，这时候该如何保证数据的一致性？<br>其实用上文所讲的队列也可以实现，这里不再赘述。主要要讲的是数据库事务与更新锁。数据库事务是一个整体，要嘛全部执行，要嘛全部不执行，失败了就进行回滚。而在事务中，我们通过更新锁(WITH (UPDLOCK))保证其他线程只能等这个事务结束之后才可进行更新操作。<br>当然锁的引入会导致性能的下降。但这些代价不可避免，为了解决数据一致性，需要牺牲一些性能。  </p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>前面说到游戏公司充值数据不一致的问题，据我的猜测，有可能是因为从支付宝或者苹果接口回调的时候发生了问题，由于高并发导致了服务宕机。另一种可能就是更新玩家充值数据时，由于使用数据库集群时，在进行数据库切换时，主从数据不一致，当然这也是我个人猜测。<br>这篇文章整理了高并发下会引发的问题，并且给了部分解决方案，之后会更新一系列文章，分别是负载均衡分析，数据库集群实现等等文章，来对这篇文章进行补充。<br>本文在网络上查找了许多文章，并加入了自己的理解。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;其实在学生时代，基本上是遇不到高并发的架构，真正遇到高并发的问题，往往是在工作之后，我在学生时代所写的很多项目其实跟高并发是一点边都沾不上，
      
    
    </summary>
    
    
      <category term="架构" scheme="http://re0.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>浅谈动态规划Ⅱ</title>
    <link href="http://re0.top/2020/06/13/dp2/"/>
    <id>http://re0.top/2020/06/13/dp2/</id>
    <published>2020-06-13T08:10:00.000Z</published>
    <updated>2020-06-13T15:03:03.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次简单讲了动态规划的概念与如何分析，本篇文章就理一理几道常见的典型的动态规划题目。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p><code>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</code><br>来自<a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">leetcode 42题</a>。<br>这道题目有两种大思路，一种是按行求，一种是按列求。由于我们只讨论动态规划，并且让理解相对简单，我们使用按列求该列可盛多少水。<br>首先，我们要明白，对于某一列，它能盛多少水在于它左右两边的最大柱子，而这列能盛的水，就是两边最高柱子中的较小者减去当前列的高度。<br>例如[0,1,0,2]这个高度数组，我们求下标为2的列能盛多少水。首先它左边最高的高度是1，右边最高的高度是2，所以它能盛的水就是min(1,2) - 0，也就是能盛1个高度的水。<br>由此我们便可以用暴力法解决这个问题。遍历每一个列时，分别求它左右最高的列，然后将结果加上min(maxleft,maxright) - height[i]。但使用暴力法的时间复杂度为O(N^2)，有可能会超时。  </p><p>这时使用态规划来降低时间复杂度，典型地使用空间换取时间，我们设置maxleft与maxright数组，maxleft[i]表示i左边最高的高度，maxright类似，然后对整个高度数组先进行两次遍历，状态转移方程也很简单，maxleft[i] = max(height[i],maxleft[i-1]) 与 maxright[j] = max(height[j],maxright[j+1])，一个从左往右，一个从右往左。之后便和暴力法的思路一致。</p><p>接下来我们优化空间，我们使用双指针分别在高度数组的两侧，maxleft与maxright分别初始化为左右两侧高度，然后开始循环，条件为left&lt;=right，此时我们便可开始求maxleft与maxright，取小的那一边，让结果加上min(maxleft,maxright)减去height[left] 或者 height[right]，取决于maxleft小还是maxright小。<br>由此我们便将时间复杂度降为O(N),空间复杂度降为O(1)。<br>下面是完整的双指针解法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(height)</span><br><span class="line"></span><br><span class="line">        left,right = <span class="number">0</span>, n - <span class="number">1</span>  </span><br><span class="line">        maxleft,maxright = height[<span class="number">0</span>],height[n - <span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            maxleft = max(height[left],maxleft)</span><br><span class="line">            maxright = max(height[right],maxright)</span><br><span class="line">            <span class="keyword">if</span> maxleft &lt; maxright:</span><br><span class="line">                ans += maxleft - height[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += maxright - height[right]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p><code>假设你正在爬楼梯。需要 n 阶你才能到达楼顶每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？  注意：给定 n 是一个正整数。</code><br>来自<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">leetcode 70题</a><br>这道题目使用动态规划是十分好理解的，从前往后或者从后往前都可以。<br>首先这道题目的状态转移方程十分容易想到。举个例子来说明，假设fx表示爬到x阶的方案数量，那么到达这一层只能是从下一阶爬一阶，或者是下两阶爬两阶。那么状态转移方程就是fx = f(x-1) + f(x-2)。那么就可以得出代码，注意这是从前往后<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>当然我们可以假设从0级到0级也有一种方案，那么就可以从下标为2的数组开始遍历。<br>由于dp[i] = dp[i-1] + dp[i-2],只和前两项有关，那么我们便可以使用三个变量替换dp数组，使用滚动数组思想将空间复杂度降至O(1)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        k = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            i = j</span><br><span class="line">            j = k</span><br><span class="line">            k = i + j</span><br><span class="line">        <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure></p><p>其实这个状态转移方程就是斐波那契数列，他是有通项公式的，即<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> sqrt5 = Math.sqrt(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">double</span> fibn = Math.pow((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>) - Math.pow((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>并且时间复杂度为O(logN)，即pow的时间，如果n过大，带入通项公式时间会更短。</p><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><p><code>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</code><br>来自<a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">leetcode 198题</a><br>这道题很有意思，现在当小偷都需要高智商了。(笑)<br>这题思路也很简单，状态转移方程也容易想到，我们用dp[i]表示偷窃到的金额，那么dp[i] = max(dp[i-1],dp[i-2]+nums[i])，其中边界条件为dp[0] = nums[0],dp[1] = max(nums[0],nums[1])。<br>完整代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> max(nums)</span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">1</span>],nums[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>由于dp[i]只与dp[i-1]还有dp[i-2]有关，python中可以使用两个变量来替代。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> max(nums)</span><br><span class="line">        </span><br><span class="line">        first, second = nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            first, second = second, max(first + nums[i], second)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> second</span><br></pre></td></tr></table></figure></p><h2 id="鸡蛋掉落"><a href="#鸡蛋掉落" class="headerlink" title="鸡蛋掉落"></a>鸡蛋掉落</h2><p><code>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。你的目标是确切地知道 F 的值是多少。无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</code><br>来自<a href="https://leetcode-cn.com/problems/super-egg-drop/" target="_blank" rel="noopener">leetcode 887题</a><br>这道题目是十分经典的动态规划题目。<br>我们先<strong>定义状态</strong>:<br>dp[i][j]表示有i层楼梯时，使用j个鸡蛋的最少实验次数。<br>接着我们开始<strong>推导状态转移方程</strong>：<br>我们假设我们在k层扔鸡蛋，其中1&lt;=k&lt;=i，<br>· 如果鸡蛋破碎，那么就说明我们要在k层以下做这个实验，那么实验次数就变为dp[k-1][j-1].<br>· 如果鸡蛋没碎，那么我们可以去k层以上做这个实验，因此F的值就为dp[i-k][j]。<br>所以，dp[i][j]应该是这两个子问题的较大者加上1，再取1&lt;=k&lt;=i区间中的最小值。即dp[i][j] = min(1&lt;=k&lt;=i)(max(dp[k-1][j-1],dp[i-k][j]) + 1).<br>给出代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">9999</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(K+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 楼层为0时都为0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(K+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 楼层为1时，0个鸡蛋扔0次，1个以上鸡蛋扔1次</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,K+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">1</span>][j] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 鸡蛋为0时 全都为0</span></span><br><span class="line">        <span class="comment"># 鸡蛋为1时 等于楼层高度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>,K+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = min(dp[i][j],max(dp[k<span class="number">-1</span>][j<span class="number">-1</span>],dp[i-k][j]) + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>这段代码的时间复杂度为O(N^2K)，即三层的循环，在数据量较大的情况下会超时，优化的关键点在于要找到1&lt;=k&lt;=i区间中的那个最小值。我们可以使用二分查找改写上面代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">9999</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(K+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 楼层为0时都为0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(K+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 楼层为1时，0个鸡蛋扔0次，1个以上鸡蛋扔1次</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,K+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">1</span>][j] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 鸡蛋为0时 全都为0</span></span><br><span class="line">        <span class="comment"># 鸡蛋为1时 等于楼层高度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>,K+<span class="number">1</span>):</span><br><span class="line">                left = <span class="number">1</span></span><br><span class="line">                right = i</span><br><span class="line">                <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">                    mid = (left + right) // <span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> dp[mid<span class="number">-1</span>][j<span class="number">-1</span>] &gt; dp[i-mid][j]:</span><br><span class="line">                        right = mid</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left = mid</span><br><span class="line">                </span><br><span class="line">                dp[i][j] = max(dp[left<span class="number">-1</span>][j<span class="number">-1</span>],dp[i-left][j]) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>为什么判断条件是<code>dp[mid-1][j-1] &gt; dp[i-mid][j]</code>?其实是因为dp[mid-1][j-1]代表着鸡蛋碎之后的F值，dp[i-mid][j]则是鸡蛋没碎的F值，如果鸡蛋碎了，那么下次应该在左边查找，所以right=mid-1，同理，如果鸡蛋没碎，我们应该提高楼层，让left = mid，去搜索右区间。<br>尽管复杂度已经降至O(NKlogN)，但上述代码在python中依旧是超时的。在java中是没有问题的，当然理解了思想使用什么语言都是一样的。（解释器语言不好混）</p><p>这里我们看看官方的解法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(k, n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> (k, n) <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">                <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                    ans = <span class="number">0</span></span><br><span class="line">                <span class="keyword">elif</span> k == <span class="number">1</span>:</span><br><span class="line">                    ans = n</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    lo, hi = <span class="number">1</span>, n</span><br><span class="line">                    <span class="comment"># keep a gap of 2 X values to manually check later</span></span><br><span class="line">                    <span class="keyword">while</span> lo + <span class="number">1</span> &lt; hi:</span><br><span class="line">                        x = (lo + hi) // <span class="number">2</span></span><br><span class="line">                        t1 = dp(k<span class="number">-1</span>, x<span class="number">-1</span>)</span><br><span class="line">                        t2 = dp(k, n-x)</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> t1 &lt; t2:</span><br><span class="line">                            lo = x</span><br><span class="line">                        <span class="keyword">elif</span> t1 &gt; t2:</span><br><span class="line">                            hi = x</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            lo = hi = x</span><br><span class="line"></span><br><span class="line">                    ans = <span class="number">1</span> + min(max(dp(k<span class="number">-1</span>, x<span class="number">-1</span>), dp(k, n-x))</span><br><span class="line">                                  <span class="keyword">for</span> x <span class="keyword">in</span> (lo, hi))</span><br><span class="line"></span><br><span class="line">                memo[k, n] = ans</span><br><span class="line">            <span class="keyword">return</span> memo[k, n]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp(K, N)</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>官方解法其实是差不多的，思路一致，改用递归加备忘录实现，速度上较快。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天总结了4道动态规划的题目，重新学习了这4道题目后感觉又学到了不少，对于扔鸡蛋的问题，这道题目是十分经典的，之后可能还会对这道题目进行深入探究。<br>下次再整理几道题目吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上次简单讲了动态规划的概念与如何分析，本篇文章就理一理几道常见的典型的动态规划题目。&lt;/p&gt;
&lt;h1 id=&quot;实践&quot;&gt;&lt;a href=&quot;#实
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>TopK问题与快速选择算法</title>
    <link href="http://re0.top/2020/05/13/topk/"/>
    <id>http://re0.top/2020/05/13/topk/</id>
    <published>2020-05-13T08:10:00.000Z</published>
    <updated>2020-05-13T15:54:29.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TopK问题通常指的是寻找数组中第k大(小)的数或前k大(小)的数组。最简单的方法当然是使用排序，本文将从TopK问题入手，讲讲常见的几种解决方法并详细讲解快速选择算法。</p><h1 id="实践1"><a href="#实践1" class="headerlink" title="实践1"></a>实践1</h1><p>解决TopK问题的解决方案有以下几种：</p><ul><li>排序</li><li>堆</li><li>快速选择算法</li></ul><p>我们使用剑指offer中给出的一道题目作为例子。<br><code>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</code><br>接下来我将详细讲解这几种解决方案来解决上述问题。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>排序是最容易想到也是比较简单的方法，许多语言中都内置了排序方法，当然自己实现排序也是可以的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr, k)</span></span></span><br><span class="line"><span class="function">        <span class="title">arr</span>.<span class="title">sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">arr</span>[:</span>k]</span><br></pre></td></tr></table></figure><br>由于python中的排序使用的是快速排序，所以平均时间复杂度为O(nlogn)。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>我们使用大根堆来解决上述问题。由于上述题目是寻找前k小的数，所以我们使用大根堆，poll出n-k个数，留下的就是前k小的数。详细思路为：将k个数插入大根堆中，从第k+1个数开始，如果当前数小于堆顶的数，把堆顶数弹出，再插入当前数。最后留在堆中的数即为前k小的数。<br>在java当中，可以使用<strong>PriorityQueue</strong>并重写比较器来实现一个大根堆，而python中因为heapq模块只支持<strong>小根堆</strong>，我们需要将数组中的数取反，才能使用小根堆来获得前k个最小值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k) &#123;</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; pq.peek()) &#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[pq.size()];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: pq) &#123;</span><br><span class="line">            res[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用小根堆<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr, k)</span></span></span><br><span class="line">        if k == 0:</span><br><span class="line">            <span class="keyword">return</span> list()</span><br><span class="line"></span><br><span class="line">        pq = [-x <span class="keyword">for</span> x <span class="keyword">in</span> arr[:k]]</span><br><span class="line">        heapq.heapify(hp)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(arr)):</span><br><span class="line">            <span class="keyword">if</span> -pq[<span class="number">0</span>] &gt; arr[i]:</span><br><span class="line">                heapq.heappop(pq)</span><br><span class="line">                heapq.heappush(pq, -arr[i])</span><br><span class="line">        ans = [-x <span class="keyword">for</span> x <span class="keyword">in</span> pq]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><br>使用堆的平均时间复杂度为O(nlogk)，空间复杂度为O(k)。</p><h2 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h2><p>快速选择算法其实是快速排序的思想，我们可以先回忆下<a href="https://re0.top/2018/06/02/quicksort/">快排</a>的思想。使用快排思想可以将数组分隔为左右两边，数组下标为[0,a)与[a,n)，如果a刚好等于k-1的话，那么[0,a)就是我们要的前k小的数，如果a小于k-1则在右区间继续寻找a，如果a大于k-1的话则在左区间寻找。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickSelect</span><span class="params">(arr,left,right,k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left &lt;= right:</span><br><span class="line">                i = left</span><br><span class="line">                j = right</span><br><span class="line">                key = arr[left]</span><br><span class="line">                <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[j] &gt; key:</span><br><span class="line">                        j -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[i] &lt;= key:</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i &lt; j:</span><br><span class="line">                        arr[i],arr[j] = arr[j],arr[i]</span><br><span class="line">                arr[left],arr[j] = arr[j],arr[left]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> j == k:</span><br><span class="line">                    <span class="keyword">return</span> arr[:j+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> j &gt; k:</span><br><span class="line">                    <span class="keyword">return</span> quickSelect(arr,left,j<span class="number">-1</span>,k)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> quickSelect(arr,j+<span class="number">1</span>,right,k)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> quickSelect(arr,<span class="number">0</span>,len(arr)<span class="number">-1</span>,k<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p><p>这个算法的改进之处与快排的改进之处一致，在于每次对于key的选取，如果数组本身有序，并且key总是取左边一个数作为对比，或者说key的选取总是最大值或最小值，那么可能导致时间复杂度退化为O(n^2)，并且由于快速选择相较于快速排序，只需要对左区间或者右区间进行partition，而不是左右区间都要partition，因此时间复杂度为N + N/2 + N/4 + … + N/N = 2N，即O(N)时间复杂度。</p><h1 id="实践2"><a href="#实践2" class="headerlink" title="实践2"></a>实践2</h1><p>上面一道题我们解决了前k小的数，而TopK其实说的是top，即第k个大的数。我们使用leetcode第215题。<br><code>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</code></p><p>我们照样使用堆和快速选择来解决这个问题。</p><h2 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h2><p>这里我们使用小根堆，将数全部入堆，如果堆大小超过k，则poll出堆顶元素，最后在堆顶的就是第k大的数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; hp =</span><br><span class="line">            <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n: nums) &#123;</span><br><span class="line">          hp.add(n);</span><br><span class="line">          <span class="keyword">if</span> (hp.size() &gt; k)</span><br><span class="line">            hp.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hp.poll();        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在python的heapq模块中，我们可以使用nlargest方法来获取前k个大的数，并返回最后一个<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k, nums)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><h2 id="快速选择-1"><a href="#快速选择-1" class="headerlink" title="快速选择"></a>快速选择</h2><p>我们可以完全复制上一道题的代码，只需改动些许地方。1.当j==k时，返回的是一个数。2.由于上一道题代码是找第k个小的数，所以刚好是下标与k-1相等时返回，也就是说寻找第k大相当于寻找第n-k+1小的数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickSelect</span><span class="params">(arr,left,right,k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left &lt;= right:</span><br><span class="line">                i = left</span><br><span class="line">                j = right</span><br><span class="line">                key = arr[left]</span><br><span class="line">                <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[j] &gt; key:</span><br><span class="line">                        j -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[i] &lt;= key:</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i &lt; j:</span><br><span class="line">                        arr[i],arr[j] = arr[j],arr[i]</span><br><span class="line">                arr[left],arr[j] = arr[j],arr[left]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> j == k:</span><br><span class="line">                    <span class="keyword">return</span> arr[j]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> j &gt; k:</span><br><span class="line">                    <span class="keyword">return</span> quickSelect(arr,left,j<span class="number">-1</span>,k)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> quickSelect(arr,j+<span class="number">1</span>,right,k)</span><br><span class="line">        <span class="comment"># len(nums)-k 是数组下标</span></span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>,len(nums)-k)</span><br></pre></td></tr></table></figure></p><p>老生常谈的优化，对于key的选择很关键，在LeetCode中，如果key总是为左边那个数，则时间耗时1100ms，而如果使用随机下标与left进行交换，则时间降至50ms以内。并且减少了递归所需要的内存消耗。具体部分代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">            <span class="keyword">if</span> left &lt;= right:</span><br><span class="line">                i = left</span><br><span class="line">                j = right</span><br><span class="line">                a = random.randint(left, right)</span><br><span class="line">                arr[left],arr[a] = arr[a],arr[left]</span><br><span class="line">                key = arr[left]</span><br><span class="line">                <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[j] &gt; key:</span><br><span class="line">                        j -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[i] &lt;= key:</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i &lt; j:</span><br><span class="line">                        arr[i],arr[j] = arr[j],arr[i]</span><br><span class="line">                arr[left],arr[j] = arr[j],arr[left]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="partition思路"><a href="#partition思路" class="headerlink" title="partition思路"></a>partition思路</h2><p>在官方答案中是将右边作为起始点，其思想大同小异，这里简单讲讲与我思路的不同。<br>首先随机选取一个pivot，并将这个数与最右边那个数进行一次交换。<br>第二步，定义i,j指针，初始化为left，循环退出条件为j指针等于最右边数的下标。查看nums[j]是否小于等于pivot，如果不是，则j向右移动。如果是，交换i,j位置的元素，并且i,j都向右移动。<br>第三步，重复第二步，直到j==right，此时交换i与j的元素，此时，i左边元素都小于它，右边元素都大于它。<br>以上就是另一种partition的思路。<br>这篇文章中的partition思路与那篇<a href="https://re0.top/2018/06/02/quicksort/">快速排序</a>的文章相同。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>快速选择算法与快速排序思想一致，通过对数组进行partition来获取前k小的数，通过写这篇文章，再一次复习了快速排序算法，并对两种算法有了自己的认识与理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;TopK问题通常指的是寻找数组中第k大(小)的数或前k大(小)的数组。最简单的方法当然是使用排序，本文将从TopK问题入手，讲讲常见的几种解
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>几种二分查找的模板与理解</title>
    <link href="http://re0.top/2020/04/29/binary_search/"/>
    <id>http://re0.top/2020/04/29/binary_search/</id>
    <published>2020-04-29T08:10:00.000Z</published>
    <updated>2020-05-02T15:44:50.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>二分查找是常见的一种搜索方式，通常用在顺序列表中查找特定的数或者区间，虽然看起来十分简单，但是在写代码的时候极容易出错，原因在于边界判断上，本质上还是对二分查找理解不到位。这篇文章整理下二分查找的模板以及谈谈自己的理解。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="大体框架"><a href="#大体框架" class="headerlink" title="大体框架"></a>大体框架</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = ...</span><br><span class="line">    <span class="keyword">while</span> (...):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = ...</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = ...</span><br><span class="line">    <span class="keyword">return</span> ...</span><br></pre></td></tr></table></figure>   <p>二分查找的模板大致如上，其中…表示需要注意的地方。在写二分查找时尽量将所有情况都用else if的形式写出来，直观一些。<br>其次在一些语言中，使用left+right有可能会溢出，所以可以改写成<code>left + (right - left) // 2</code>。<br>基于以上模板，我们可以详细分为几类。</p><h2 id="寻找特定的一个数"><a href="#寻找特定的一个数" class="headerlink" title="寻找特定的一个数"></a>寻找特定的一个数</h2><p>这个是我们常用到的，即在数组中寻找一个特定的数，前提是这个数组已经采用升序排序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><br>这里需要注意的有：</p><ol><li><p>Q：为什么while的条件是<strong>left &lt;= right</strong>，而不是<strong>left &lt; right</strong>？<br>A：当条件为&lt;=时，相当于搜索的是[left,right]区间，而&lt;则相当于[left,right)的区间，当right的取值为len(nums)时，我们的nums[right]是越界的，此时右区间需要开。<br>&lt;=的终止条件为left == right + 1，此时区间为[right+1,right]，区间为空。<br>&lt; 的终止条件为left == right，即[left,left)，只有一个数的区间，但此时这个数并没有被扫描到，所以使用&lt;作为判断的话需要加入一个判断语句<code>if nums[left] == target left else -1</code></p></li><li><p>Q：left 和 right 到底需要怎么改变？<br>A：上述代码中left=mid+1与right=mid-1是因为我们已经明确搜索区间是闭区间，即左右边界都已经搜索过，或者说mid这个索引的数已经被搜索过，所以我们需要根据需要在mid的左右区间进行搜索，即[left,mid-1]或者[mid+1,right]。</p></li></ol><h2 id="寻找左边界的二分查找"><a href="#寻找左边界的二分查找" class="headerlink" title="寻找左边界的二分查找"></a>寻找左边界的二分查找</h2><p>如果一个数组存在重复元素，并且需要你返回第一个出现这个数的索引，那么显然我们使用普通的二分查找并不能获得这个元素的在数组中出现的左边界。<br>我们先给出使用<strong>left &lt; right</strong>为条件的代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left_bound</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)</span><br><span class="line">    <span class="keyword">while</span> (left &lt; rgiht):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>这个代码是许多人常用来搜索左边界的代码，但是在结果返回时存在着一个问题。我们先整理一下问题:</p><ol><li><p>Q：如果数组中不存在这个数，那么返回不就不对了吗？<br>A：确实如此。我们刚才说到，使用&lt;为条件的搜索为右开区间，当退出循环时，此时区间为[left,left)，并且left的取值有可能为数组边界,所以我们需要两个判断语句，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if left == len(nums) or nums[left] != target:</span><br><span class="line">    return -1 </span><br><span class="line">else: </span><br><span class="line">    return left</span><br></pre></td></tr></table></figure></li><li><p>Q：为啥是left &lt; right?<br>A：理由同上，因为right被初始化为len(nums)，需要采用右开区间保证下标不越界。</p></li><li><p>Q：为什么left = mid + 1,right = mid?<br>A：因为是左闭右开区间，需要将区间分为[left,mid)与[mid+1,right)。</p></li><li><p>Q：能不能统一为left&lt;=right?<br>A：我个人认为统一left &lt;= right 比较好，前提是理解了搜索区间这个概念。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left_bound</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= len(nums) <span class="keyword">or</span> nums[left] != target:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="寻找右边界的二分查找"><a href="#寻找右边界的二分查找" class="headerlink" title="寻找右边界的二分查找"></a>寻找右边界的二分查找</h2><p>与上面代码类似，这里我只写出left&lt;=right为条件的代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right_bound</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; <span class="number">0</span> <span class="keyword">or</span> nums[right] != target:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>注意的点为：</p><ol><li>搜索左右边间的区别在于当nums[mid] == target时需要缩小哪个边界，当我们需要寻找<strong>左侧</strong>边界时，我们应该在搜索到target后，去搜索左侧区间；而当我们需要寻找<strong>右侧</strong>边界时，在搜索到target时，去寻找右区间。</li><li>之所以检测right是因为right的取值为[-1,len(nums)-1]，即当target比所有元素小时，right会减至-1，需要防止越界。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们明确搜索区间概念之后，统一将条件写为left&lt;=right，并从中总结规律。<br>先是二分查找<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><br>其次寻找左边界<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left_bound</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= len(nums) <span class="keyword">or</span> nums[left] != target:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>最后是寻找右边界<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right_bound</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; <span class="number">0</span> <span class="keyword">or</span> nums[right] != target:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure></p><p>寻找左右边界区别在于nums[mid] == target时需要收缩左侧边界还是右侧边界，还有因为left属于[0,len(nums)]，right属于[-1,len(nums)-1]，所以需要判断各自越界情况。<br>这些便是从升序数组中二分查找的方法。如果理解了这些，那降序数组的二分搜索也是万变不离其宗的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;二分查找是常见的一种搜索方式，通常用在顺序列表中查找特定的数或者区间，虽然看起来十分简单，但是在写代码的时候极容易出错，原因在于边界判断上，
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>浅谈动态规划</title>
    <link href="http://re0.top/2020/04/05/dp1/"/>
    <id>http://re0.top/2020/04/05/dp1/</id>
    <published>2020-04-05T08:10:00.000Z</published>
    <updated>2020-04-07T07:23:13.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>动态规划（Dynamic programming，简称 DP），是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。这与递归的思想一致，所以动态规划往往用于优化递归问题，利用动态规划的思想可以减少计算量。</p><h2 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h2><p>最优子结构指的是，问题的最优解包含子问题的最优解。即我们可以通过子问题的最优解，推导出问题的最优解。</p><h2 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h2><p>无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。</p><h2 id="重复子问题"><a href="#重复子问题" class="headerlink" title="重复子问题"></a>重复子问题</h2><p>不同的决策序列，到达某个相同阶段时，会产生重复的状态。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h2><p>解决动态规划问题，一般有两种思路，分别为状态转移表法和状态转移方程法。</p><h3 id="状态转移表法"><a href="#状态转移表法" class="headerlink" title="状态转移表法"></a>状态转移表法</h3><p>一般情况下，能使用动态规划解决的问题，都可以使用回溯法解决。先通过回溯法，找到是否存在重复子问题，以及相应的规律，尝试是否能使用动态规划解决。<br>找到重复子问题之后，就可以使用状态转移表来处理问题。<br>先画出一个状态表，一般来说都是二维的，可以用二维数组来表示，其中每个状态包括三个变量，行，列，数组值。根据递归关系，填充状态表的每个状态，最后翻译成代码，就是动态规划的代码了。<br>但如果问题较为复杂，状态表就有可能是高维的，这时候人在思考问题的时候就不那么简单了。<br>举个例子，要从矩阵左上角走到矩阵右下角，但是每格都有相应的权重，我们需要选择权重最小的路径。<br>这里我们可以采用回溯算法(深度优先中的一种)，回溯在遍历时不保留完整的结构，而深度优先则保留。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    self.minDist = float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistBT</span><span class="params">(i:int,j:int,dist:int,w:list[list[int],n:int)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == n <span class="keyword">and</span> j == n:</span><br><span class="line">            <span class="keyword">if</span> dist &lt; minDist:</span><br><span class="line">                self.minDist = dist</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; n:</span><br><span class="line">            self.minDistBT(i + <span class="number">1</span>,j,dist + w[i][j] , w, n)</span><br><span class="line">        <span class="keyword">if</span> j &lt; n:</span><br><span class="line">            self.minDistBT(i,j + <span class="number">1</span>,dist + w[i][j] , w, n)</span><br></pre></td></tr></table></figure> </p><p>我们可以看出，一个状态即一个节点，包含三个变量(i,j,dist)，其中i,j表示行列，dist表示起点到(i,j)的路径长度，尽管(i,j,dist)没有重复值，但(i,j)重复，对于(i,j)重复的节点，我们只需要选择dist最小的节点便可以继续递归求解了。<br>我们翻译成代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistDP</span><span class="params">(matrix:list[list[int]],n:int)</span>:</span></span><br><span class="line">        states = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sum += matrix[<span class="number">0</span>][i]</span><br><span class="line">            states[<span class="number">0</span>][i] = sum</span><br><span class="line">        </span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sum += matrix[i][<span class="number">0</span>]</span><br><span class="line">            states[i][<span class="number">0</span>] = sum</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                states[i][j] = matrix[i][j] + min(states[i][j<span class="number">-1</span>],states[i<span class="number">-1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> states[n<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>这里我们初始化了第一行和第一列的数据，然后每一个节点都是让该节点的权重加上，上方和左方中的最小值，就是该状态表的这个节点的最小dist值。最后返回右下角节点的值，便可以获得最短路径。</p><h3 id="状态转移方程法"><a href="#状态转移方程法" class="headerlink" title="状态转移方程法"></a>状态转移方程法</h3><p>这种方法与递归的思想类似，我们需要知道，某个问题如何通过子问题求解，即寻找最优子结构，根据最优子结构写出递归公式，即状态转移方程。以上面的问题来说，状态转移方程为：<br><code>min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))</code><br>状态转移方程是解决动态规划的关键所在，接下来翻译成代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    self.matrix = [[random.randint(<span class="number">1</span>,<span class="number">10</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">    self.n = <span class="number">4</span></span><br><span class="line">    self.mem = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">    <span class="comment"># 调用minDist(n-1,n-1)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDist</span><span class="params">(i:int,j:int)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.matrix[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> self.mem[i][j] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.mem[i][j]</span><br><span class="line">        </span><br><span class="line">        minLetf = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">if</span> j - <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">            minLetf = self.minDist(i,j<span class="number">-1</span>)</span><br><span class="line">        minUp = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">if</span> i - <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">            minUp = self.minDist(i<span class="number">-1</span>,j)</span><br><span class="line"></span><br><span class="line">        currMinDist = self.matrix[i][j] + min(minLetf,minUp)</span><br><span class="line">        self.mem[i][j] = currMinDist</span><br><span class="line">        <span class="keyword">return</span> currMinDist</span><br></pre></td></tr></table></figure></p><p>我们从右下角回溯到左上角。每个节点的值等于该节点的权重加上上方和左方节点中的最小值。<br>其实和上面的状态转移表法的实现是差不多的，只是思考的思路不同。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>尽管动态规划比回溯算法高效，但并不是所有问题都可以使用动态规划，能使用动态规划的问题，需要满足三个条件，最优子结构，无后效性，重复子问题。在重复子问题上，动态规划与分治算法区分明显，分治算法要求分割成的子问题不能有重复子问题，而动态规划则恰恰相反，它之所以高效，是因为回溯算法中存在大量的重复子问题。<br>解决动态规划问题的思路分别是状态转移表法和状态转移方程法。其中，状态转移表法解题思路大致可以概括为<strong>回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码。</strong>状态转移方程法的大致思路可以概括为，<strong>找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码。</strong><br>之后的文章会通过实际问题继续探讨动态规划。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;动态规划（Dynamic programming，简称 DP），是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。若要解一个
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的广度优先(层次)遍历</title>
    <link href="http://re0.top/2020/03/30/tree-traversal2/"/>
    <id>http://re0.top/2020/03/30/tree-traversal2/</id>
    <published>2020-03-30T09:10:00.000Z</published>
    <updated>2020-03-30T09:02:34.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇讲的是二叉树的三种遍历方式，前中后序遍历方式，它们都属于深度优先遍历，所谓深度优先就是沿着树的深度遍历树的节点。而广度优先遍历则是从root开始，从左到右从上到下水平遍历树的节点，所以又称为层次遍历。<br>深度优先借助的数据结构为栈，而广度优先借助的则是队列。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p>由于在LeetCode中并没有找到相应的题目，所以我直接给出代码。<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">breadthTraversal</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            queue = []</span><br><span class="line">            res = []</span><br><span class="line">            queue.append(root)</span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>二叉树的广度优先遍历较为简单，只要借助队列，让节点先进先出，便可得到层次遍历的结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上篇讲的是二叉树的三种遍历方式，前中后序遍历方式，它们都属于深度优先遍历，所谓深度优先就是沿着树的深度遍历树的节点。而广度优先遍历则是从ro
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的前中后序遍历</title>
    <link href="http://re0.top/2020/03/30/tree-traversal/"/>
    <id>http://re0.top/2020/03/30/tree-traversal/</id>
    <published>2020-03-30T08:10:00.000Z</published>
    <updated>2020-03-30T09:02:35.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在看面试题，基本已经知道算法这块地方是自己的薄弱点，特意复习记录一下。<br>今天写的是二叉树的前中后序遍历，我会分别用递归还有迭代的方法实现。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>来源LeetCode第144题。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>官方特意在题目中标注递归算法很简单，那么就先来看看递归算法。<br>递归算法就是先得到结点值，然后递归遍历左子树和右子树。<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        result.append(root.val)</span><br><span class="line">        <span class="comment"># 由于递归返回list，需要使用extend合并两个列表。</span></span><br><span class="line">        result.extend(self.preorderTraversal(root.left))</span><br><span class="line">        result.extend(self.preorderTraversal(root.right))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p>Java代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        preOrder(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>与python大同小异。</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>我们知道递归的本质是使用栈来实现，那么我们也可以使用一个栈来帮助我们进行迭代。<br>而栈的进入顺序为<strong>先右子树然后左子树</strong>，因为栈是先进后出的数据结构，所以我们让右子树先进栈，让左子树先出栈，才能实现root-left-right的顺序。<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            rerurn []</span><br><span class="line">        stack = []</span><br><span class="line">        result = []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            result.append(node.val)</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><br>Java代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode temp = stack.pop();</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>来自LeetCode第94题。<br>中序遍历是left-root-right的顺序，递归方法依旧很简单。</p><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># 可以省略判断</span></span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="keyword">None</span>:</span><br><span class="line">                inorder(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.right != <span class="keyword">None</span>:</span><br><span class="line">                inorder(root.right)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>其实可以省略判断，因为函数开始就已经判断root是否为空。</p><p>Java代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root.left,result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        helper(root.right,result);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><p>中序遍历的迭代方法与前序遍历难一些。中序遍历需要先将<strong>所有左子树</strong>压入栈中，然后开始从二叉树左下角的节点开始出栈，将本节点的的值放入结果中，然后将该节点的右子树放入栈中。之后便可按照left-root-right的顺序将值放入结果中。<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure></p><p>Java代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            result.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以稍微修改下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                result.add(root.val);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>LeetCode第145题。前中后序遍历官方给的难度是递增的。后序遍历难度为困难。</p><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>当然我们如果使用递归的话就比较简单。与前序中序相似，只改变一下节点值加入结果的顺序。<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># 可以省略判断</span></span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="keyword">None</span>:</span><br><span class="line">                postorder(root.left)</span><br><span class="line">            <span class="keyword">if</span> root.right != <span class="keyword">None</span>:</span><br><span class="line">                postorder(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>Java代码类似<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root.left,result);</span><br><span class="line">        helper(root.right,result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h3><p>困难主要在于使用迭代实现后序遍历。后序遍历的顺序为left-right-root，由于我们先获得的是root节点，之后才能获取左右子树，所以我们改变思路，<br>我们可以先从root-right-left的顺序下手，之后再反序，就可以得到后序遍历的结果。<br>由于我们使用的是栈，我们先把根节点放入栈中，然后依次放入左子树和右子树，这样栈的弹出顺序就是由右子树到左子树，那么我们的思路就确定了：<br>先将根节点push到栈中，pop出来后将值存入结果中，然后分别push左右子树到栈中，右子树先出栈，得到了右子树的值，然后得到左子树的值，即遍历顺序就为根-右子树-左子树。<br>因此，我们的入栈顺序就是为root-left-right<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res.append(node.val)</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>Java代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode temp = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">            stack.push(temp.left);</span><br><span class="line">            stack.push(temp.right);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次总结了三种二叉树的遍历方式，相比于之前，确实又加深了不少理解。三种遍历方式使用递归方法都非常简单，但是使用迭代方法就有些难度了，<br>其中前序遍历最简单，只要将root-right-left依次放进栈中便可得到结果。<br>而后序遍历与前序遍历多了一个翻转的思想，入栈顺序为root-left-right，之后反转结果，便可得到后序遍历的结果。<br>最后是中序遍历，将所有左子树放入栈中，然后从左下角的节点开始出栈，每当出栈后，把节点值放入结果中，然后将右子树放入栈中，如此迭代，便可得到left-root-right的顺序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在看面试题，基本已经知道算法这块地方是自己的薄弱点，特意复习记录一下。&lt;br&gt;今天写的是二叉树的前中后序遍历，我会分别用递归还有迭代的方
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
