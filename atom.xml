<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zer0e&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://re0.top/"/>
  <updated>2022-04-08T14:12:20.699Z</updated>
  <id>https://re0.top/</id>
  
  <author>
    <name>Zer0e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>devtools协议分析与自动化录制实现</title>
    <link href="https://re0.top/2022/04/08/devtools/"/>
    <id>https://re0.top/2022/04/08/devtools/</id>
    <published>2022-04-08T10:00:00.000Z</published>
    <updated>2022-04-08T14:12:20.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近有个需求是做web自动化脚本录制，简单来说就是点击页面上的一个元素，就能把对应节点的xpath和自动化语法添加到脚本中。在airtest中，已经实现了这个功能，这里不再演示，通过实际使用，我认为这一技术实现的关键在于devtools，即通过与浏览器devtools的交互，实现当前节点的选取与脚本录制。<br>目前网上能搜索到的文章有限，本文将详细描述与自动化相关的devtools协议的研究与demo实现。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>首先是去寻找下devtools的<a href="https://chromedevtools.github.io/devtools-protocol/">文档</a>。CDP协议，全程Chrome DevTools Protocol，是用来检测、检查、调试和分析 Chromium、Chrome 和其他基于 Blink 的浏览器。通过开启调试端口，就能与devtools进行通信，从而实现事件与监听。  </p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先使用<code>chrome.exe --remote-debugging-port=9222</code>开启chrome的远程调试端口。也可以加上<code>--headless</code>启用无头浏览器。<br>当启动完成后，访问<code>http://localhost:9222/json</code>即可获取到可交互的devtools地址。<strong>devtools采用websocket协议进行通信</strong>，通过与webSocketDebuggerUrl进行websocket连接即可与devtools进行通信。<br>到这，准备工作已经完成，现在需要分析需要的devtools协议。</p><h2 id="使用原有工具观察协议"><a href="#使用原有工具观察协议" class="headerlink" title="使用原有工具观察协议"></a>使用原有工具观察协议</h2><p>相信各位都使用过devtools的inspect模式，这个模式能高亮选中的元素，并且当点击这个元素后，elements标签里会跳到对应节点的html代码处。<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/devtools/1.png" alt="1.png"><br>要观察devtools协议传输了什么，可以通过打开devtools前端的协议观察器。在devtools的试验设置里可以打开。打开后，在更多里打开协议监听器。<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/devtools/2.png" alt="2.png"><br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/devtools/3.png" alt="3.png"><br>点击inspect，选中页面上的元素，即可出现相关的协议请求，包括请求方法，请求参数，还有响应。  </p><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>当然，知道了通信具体参数并不代表可以直接发送数据了，我们还需了解交互的格式，在官方文档中，我们找到了一份<a href="https://github.com/aslushnikov/getting-started-with-cdp/blob/master/README.md">getting-start</a>，这份文档用js写了份示例，根据示例我们可以清楚看到websocket交互的请求体。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;params&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中id作为请求的唯一标识，用于让请求方标识返回的内容是对应哪个请求的，当devtools返回时，会将此id返回，因此当需要当出现多个请求同时发出时，需要确保id唯一。<br>method字段对应响应的方法，而params字段则是方法对应的参数。<br>最后发送的是json数据的stringfy。  </p><h2 id="大体实现"><a href="#大体实现" class="headerlink" title="大体实现"></a>大体实现</h2><p>回到protocol monitor，我们可以发现当启用inspect模式时，会发送<code>Overlay.setInspectMode</code>方法，开启检查模式。虽然也可以在官方文档中看到，但是官方文档方法实在太多了，不如这种方式来的直接。<br>其次在页面上选中元素时，会接收一个<code>Overlay.nodeHighlightRequested</code>事件，会返回一个nodeId，而当在页面上点击一个元素时会接收一个<code>Overlay.inspectNodeRequested</code>事件，返回一个backendNodeId。<br>而无论是nodeId还是backendNodeId，都可以通过<code>DOM.describeNode</code>方法发送指定参数的请求，获取这个节点的详细信息。这个方法的参数如下：  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;nodeId&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="attr">&quot;backendNodeId&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="attr">&quot;objectId&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="attr">&quot;depth&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"><span class="attr">&quot;pierce&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>实际使用中，我们只需要发送nodeId或者backendNodeId即可。<br>其他实现自动化需要的事件还有<code>DOM.documentUpdated</code>，这个事件说明dom被更新了，需要重新获取dom，否则前后端的节点会不一致，可以通过<code>DOM.getDocument</code>方法重新获取dom，顺带一提，连接完成后，也应该执行一次这个方法。<br>至此，我们已经可以完成一个简单的自动化节点监控。下面简单写下代码。  </p><h2 id="简易实现代码"><a href="#简易实现代码" class="headerlink" title="简易实现代码"></a>简易实现代码</h2><p>这里我们使用websocket-client作为websocket的客户端连接到devtools。<br>先从<code>http://127.0.0.1:9222/json</code>获取到webSocketDebuggerUrl。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">send_msg_template = &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;method&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;params&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">searchForNode = &#123;</span><br><span class="line">    <span class="string">&quot;mode&quot;</span>: <span class="string">&quot;searchForNode&quot;</span>,</span><br><span class="line">    <span class="string">&quot;highlightConfig&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;showInfo&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;showRulers&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;showStyles&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;showAccessibilityInfo&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;showExtensionLines&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;contentColor&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;r&quot;</span>: <span class="number">111</span>,</span><br><span class="line">            <span class="string">&quot;g&quot;</span>: <span class="number">168</span>,</span><br><span class="line">            <span class="string">&quot;b&quot;</span>: <span class="number">220</span>,</span><br><span class="line">            <span class="string">&quot;a&quot;</span>: <span class="number">0.66</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">disableSearchForNode = deepcopy(searchForNode)</span><br><span class="line">disableSearchForNode[<span class="string">&#x27;mode&#x27;</span>] = <span class="string">&quot;none&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">ws, msg</span>):</span></span><br><span class="line">        data = json. loads(msg)</span><br><span class="line">        pprint(data)</span><br><span class="line">        method = data[<span class="string">&#x27;method&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> method == <span class="string">&#x27;Overlay.inspectNodeRequested&#x27;</span>:</span><br><span class="line">            <span class="comment"># 当在Inspector模式下，节点被按下时触发的事件</span></span><br><span class="line">            backend_node_id = data[<span class="string">&quot;params&quot;</span>][<span class="string">&#x27;backendNodeId&#x27;</span>]</span><br><span class="line">            <span class="comment"># pprint(backend_node_id)</span></span><br><span class="line">            <span class="comment"># 获取下详细的节点信息</span></span><br><span class="line">            send_msg(ws, <span class="string">&quot;DOM.describeNode&quot;</span>, &#123;<span class="string">&#x27;backendNodeId&#x27;</span>: backend_node_id&#125;)</span><br><span class="line">            <span class="comment"># 然后关闭Inspector模式</span></span><br><span class="line">            send_msg(ws, <span class="string">&quot;Overlay.setInspectMode&quot;</span>, disableSearchForNode)</span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">&quot;Overlay.nodeHighlightRequested&quot;</span>:</span><br><span class="line">            <span class="comment"># 这个方法是Inspector模式下，节点被选中时触发的，前提是已经获取过dom</span></span><br><span class="line">            send_msg(ws, <span class="string">&quot;DOM.describeNode&quot;</span>, &#123;<span class="string">&#x27;nodeId&#x27;</span>: data[<span class="string">&#x27;params&#x27;</span>][<span class="string">&#x27;nodeId&#x27;</span>]&#125;)</span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">&quot;DOM.documentUpdated&quot;</span>:</span><br><span class="line">            <span class="comment"># 收到这个方法说明dom被更新，需要重新获取下dom</span></span><br><span class="line">            send_msg(ws, <span class="string">&quot;DOM.getDocument&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_msg</span>(<span class="params">ws, method, params=<span class="literal">None</span></span>):</span></span><br><span class="line">        send_msg_template[<span class="string">&#x27;id&#x27;</span>] += <span class="number">1</span></span><br><span class="line">        msg = deepcopy(send_msg_template)</span><br><span class="line">        msg[<span class="string">&#x27;method&#x27;</span>] = method</span><br><span class="line">        msg[<span class="string">&#x27;params&#x27;</span>] = params <span class="keyword">if</span> params <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">        ws.send(json.dumps(msg))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_open</span>(<span class="params">ws</span>):</span></span><br><span class="line">        send_msg(ws, <span class="string">&quot;DOM.enable&quot;</span>)</span><br><span class="line">        send_msg(ws, <span class="string">&quot;Overlay.enable&quot;</span>)</span><br><span class="line">        send_msg(ws, <span class="string">&quot;Inspector.enable&quot;</span>)</span><br><span class="line">        send_msg(ws, <span class="string">&quot;DOM.getDocument&quot;</span>)</span><br><span class="line">        send_msg(ws, <span class="string">&quot;Overlay.setInspectMode&quot;</span>, searchForNode)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> websocket <span class="keyword">import</span> WebSocketApp</span><br><span class="line">    ws = WebSocketApp(<span class="string">&quot;ws://127.0.0.1:9222/devtools/page/EA63C0AE33770FD58FB89FD3A6ACB165&quot;</span>, on_message=on_message,</span><br><span class="line">                      on_open=on_open)</span><br><span class="line"></span><br><span class="line">    ws.run_forever()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    t = threading.Thread(target=main)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure><p>这里我们在连接完成后，立即发送几个方法，分别是<code>DOM.enable</code>,<code>Overlay.enable</code>,<code>Inspector.enable</code>,<code>DOM.getDocument</code>,<code>Overlay.setInspectMode</code>，其中几个enable是开启对应的功能，这里不再赘述，然后是立即获取一次dom，随后开启inspect模式，这里我们不需要浏览器中devtools的inspect那么多显示，如元素的padding，因此我们只保留最基础的设置。<br>随后我们在收到消息后就监听几个事件，分别是我们前文所讲的几个事件，随后在节点被按下后，取消inspect模式。<br>可以看看效果  </p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","preload":"none","video":{"url":"https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/devtools/1.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>这里当我们移动到一个元素上时，会打印出该节点的详细信息，在按下节点后，inspect模式随即解除。  </p><h2 id="使用第三方库监听"><a href="#使用第三方库监听" class="headerlink" title="使用第三方库监听"></a>使用第三方库监听</h2><p>当然，我们也可以专注于事件的监听和方法的发送，无需关注websocket的实现，<a href="https://github.com/fate0/pychrome">pychrome</a>就是这样的一个库，它的核心代码不过二百多行，它可以通过设置listener来实现指定方法的监听，根据官方示例，我们可以简单改造下上面的代码。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pychrome</span><br><span class="line">browser = pychrome.Browser(url=<span class="string">&quot;http://127.0.0.1:9222&quot;</span>)</span><br><span class="line">tab = browser.list_tab()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_node</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">result = tab.call_method(<span class="string">&quot;DOM.describeNode&quot;</span>, **kwargs)</span><br><span class="line">pprint(result)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_node_and_stop_inspect</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">result = tab.call_method(<span class="string">&quot;DOM.describeNode&quot;</span>, **kwargs)</span><br><span class="line">pprint(result)</span><br><span class="line">tab.call_method(<span class="string">&quot;Overlay.setInspectMode&quot;</span>, **disableSearchForNode)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_dom</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">tab.call_method(<span class="string">&quot;DOM.getDocument&quot;</span>)</span><br><span class="line"></span><br><span class="line">tab.set_listener(<span class="string">&quot;Overlay.inspectNodeRequested&quot;</span>, get_node_and_stop_inspect)</span><br><span class="line">tab.set_listener(<span class="string">&quot;Overlay.nodeHighlightRequested&quot;</span>, get_node)</span><br><span class="line">tab.set_listener(<span class="string">&quot;DOM.documentUpdated&quot;</span>, update_dom)</span><br><span class="line"></span><br><span class="line">tab.start()</span><br><span class="line">tab.call_method(<span class="string">&quot;DOM.enable&quot;</span>)</span><br><span class="line">tab.call_method(<span class="string">&quot;Overlay.enable&quot;</span>)</span><br><span class="line">tab.call_method(<span class="string">&quot;Inspector.enable&quot;</span>)</span><br><span class="line">tab.call_method(<span class="string">&quot;DOM.getDocument&quot;</span>)</span><br><span class="line">tab.call_method(<span class="string">&quot;Overlay.setInspectMode&quot;</span>, **searchForNode)</span><br><span class="line"></span><br><span class="line">tab.wait(<span class="number">10</span>)</span><br><span class="line">tab.stop()</span><br></pre></td></tr></table></figure><p>改造完成后，瞬间就很清爽，我们只需要对指定事件监听即可，脚本运行的情况与之前脚本相同，这里就不再演示。<br>唯一遗憾的是pychrome不支持一个event监听多个方法，新方法会覆盖旧方法。之后有机会提下pr吧。  </p><h2 id="获取节点xpath"><a href="#获取节点xpath" class="headerlink" title="获取节点xpath"></a>获取节点xpath</h2><p>至此，我们的自动化录制已经实现了一大部分，那么剩下就是获取这个节点的xpath，唯一确定这个节点的位置，就可以在selenium准确点击这个元素了。<br>回到刚刚的<code>DOM.describeNode</code>方法，这个方法的返回如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;node&#x27;</span>: &#123;<span class="string">&#x27;attributes&#x27;</span>: [<span class="string">&#x27;href&#x27;</span>,</span><br><span class="line">                                    <span class="string">&#x27;https://www.iana.org/domains/example&#x27;</span>],</span><br><span class="line">                     <span class="string">&#x27;backendNodeId&#x27;</span>: <span class="number">14</span>,</span><br><span class="line">                     <span class="string">&#x27;childNodeCount&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                     <span class="string">&#x27;localName&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;nodeId&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">                     <span class="string">&#x27;nodeName&#x27;</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;nodeType&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                     <span class="string">&#x27;nodeValue&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>我们知道这个节点的名称，attributes，但是我们却没有结构，来完成路径组装。其实<code>DOM.getDocument</code>是可以获取到完整结构树的，如果没有参数传递，那么最多只会获取1层的子树，我们可以指定depth参数为-1获取整个document结构。<br>有了整个dom树，那么我们就可以从上到下遍历树，从而获取节点的路径，我们也无需再次通过<code>DOM.describeNode</code>获取节点的数据。代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">dom_root = tab.call_method(<span class="string">&quot;DOM.getDocument&quot;</span>, depth=-<span class="number">1</span>)[<span class="string">&#x27;root&#x27;</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_path_from_root</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">backend_node_id = kwargs.get(<span class="string">&quot;backendNodeId&quot;</span>)</span><br><span class="line">path = _get_path(dom_root, backend_node_id, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;path: &quot;</span> + <span class="built_in">str</span>(path))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_path</span>(<span class="params">node, backend_node_id, path</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">递归获取结构</span></span><br><span class="line"><span class="string">:param node:</span></span><br><span class="line"><span class="string">:param backend_node_id:</span></span><br><span class="line"><span class="string">:param path</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> node[<span class="string">&#x27;backendNodeId&#x27;</span>] == backend_node_id:</span><br><span class="line"><span class="keyword">return</span> path + <span class="string">&quot;/&quot;</span> + node[<span class="string">&#x27;localName&#x27;</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> node.get(<span class="string">&#x27;children&#x27;</span>, []):</span><br><span class="line">child_path = _get_path(child, backend_node_id, path + <span class="string">&quot;/&quot;</span> + node[<span class="string">&#x27;localName&#x27;</span>])</span><br><span class="line"><span class="keyword">if</span> child_path:</span><br><span class="line"><span class="keyword">return</span> child_path</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>我们点击页面上超链接，得到<code>path: //html/body/div/p/a</code>，这里前面多个/符号是因为root没有名称，获取后做下处理即可。下面的代码会改进。<br>当然只用路径肯定不够，当有id时，我们优先使用id来实现，顺便改造下之前的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_path</span>(<span class="params">node, backend_node_id, path</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">递归获取结构</span></span><br><span class="line"><span class="string">:param node:</span></span><br><span class="line"><span class="string">:param backend_node_id:</span></span><br><span class="line"><span class="string">:param path</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">node_attributes = node.get(<span class="string">&#x27;attributes&#x27;</span>, [])</span><br><span class="line">node_id = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(node_attributes), <span class="number">2</span>):</span><br><span class="line"><span class="keyword">if</span> node_attributes[i] == <span class="string">&quot;id&quot;</span>:</span><br><span class="line">node_id = node_attributes[i + <span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> node_id:</span><br><span class="line">new_path = <span class="string">&quot;//*[@id=\&quot;&#123;&#125;\&quot;]&quot;</span>.<span class="built_in">format</span>(node_id)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">new_path = (path + <span class="string">&quot;/&quot;</span> + node[<span class="string">&#x27;localName&#x27;</span>]) <span class="keyword">if</span> node[<span class="string">&#x27;localName&#x27;</span>] <span class="keyword">else</span> path</span><br><span class="line"><span class="keyword">if</span> node[<span class="string">&#x27;backendNodeId&#x27;</span>] == backend_node_id:</span><br><span class="line"><span class="keyword">return</span> new_path</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> node.get(<span class="string">&#x27;children&#x27;</span>, []):</span><br><span class="line">child_path = _get_path(child, backend_node_id, new_path)</span><br><span class="line"><span class="keyword">if</span> child_path:</span><br><span class="line"><span class="keyword">return</span> child_path</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="也许是完善？"><a href="#也许是完善？" class="headerlink" title="也许是完善？"></a>也许是完善？</h2><p>当然这个获取xpath的代码还不完全，当节点有其他attr时也可以以这些属性作为xpath，并且还需要考虑同级别下有相同节点，此时需要用序号来标识。<br>并且通过id获取xpath也不能确保准确，因为网站的编写者可能重复使用id。(<del>CV程序员</del>)<br>例如，如下的html文件，我们在devtools的element里选中第一个p元素后右键复制XPath后，显示的path是<code>//*[@id=&quot;1&quot;]</code>，但这明显是有问题的，虽然是网页编写者的问题，但我们为了兼容所有系统，可以使用完整的path作为真正的xpath。  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&#x27;1&#x27;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&#x27;2&#x27;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&#x27;1&#x27;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&#x27;2&#x27;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基于以上观点，我们在这不使用带有attribute的xpath，只使用完整的xpath路径作为节点的唯一路径。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_path</span>(<span class="params">node, backend_node_id, path, idx=<span class="number">1</span></span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">递归获取结构</span></span><br><span class="line"><span class="string">:param node:</span></span><br><span class="line"><span class="string">:param backend_node_id:</span></span><br><span class="line"><span class="string">:param path</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">new_path = (path + <span class="string">&quot;/&quot;</span> + node[<span class="string">&#x27;localName&#x27;</span>]) <span class="keyword">if</span> node[<span class="string">&#x27;localName&#x27;</span>] <span class="keyword">else</span> path</span><br><span class="line"><span class="keyword">if</span> idx != <span class="number">1</span> <span class="keyword">and</span> new_path:</span><br><span class="line">new_path = new_path + <span class="string">&quot;[&#123;&#125;]&quot;</span>.<span class="built_in">format</span>(idx)</span><br><span class="line"><span class="keyword">if</span> node[<span class="string">&#x27;backendNodeId&#x27;</span>] == backend_node_id:</span><br><span class="line"><span class="keyword">return</span> new_path</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">children = node.get(<span class="string">&#x27;children&#x27;</span>, [])</span><br><span class="line">tag_map = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(children)):</span><br><span class="line">child = children[i]</span><br><span class="line"><span class="keyword">if</span> child[<span class="string">&#x27;localName&#x27;</span>] <span class="keyword">in</span> tag_map:</span><br><span class="line">tag_map[child[<span class="string">&#x27;localName&#x27;</span>]] += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tag_map[child[<span class="string">&#x27;localName&#x27;</span>]] = <span class="number">1</span></span><br><span class="line">child_path = _get_path(child, backend_node_id, new_path, tag_map[child[<span class="string">&#x27;localName&#x27;</span>]])</span><br><span class="line"><span class="keyword">if</span> child_path:</span><br><span class="line"><span class="keyword">return</span> child_path</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>通过以上代码我们已经能初步实现步骤的自动化录制。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文就网页自动化录制提出了自己的一些思路与代码实现，初步实现了自动化录制。当然，我相信仍旧有许多实际问题没有被我发现，只能等之后的具体开发才能发现会有什么问题。<br>其次，就airtest的功能来看，它认为节点的id不会重复，并且attribute大概率不会重复，因此它的xpath是多样的。<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/devtools/4.png" alt="4.png"><br>相较于airtest的录制功能，这篇文章最后代码使用的是完整的xpath路径，保证路径唯一。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近有个需求是做web自动化脚本录制，简单来说就是点击页面上的一个元素，就能把对应节点的xpath和自动化语法添加到脚本中。在airtest
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://re0.top/tags/Python/"/>
    
      <category term="自动化测试" scheme="https://re0.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>由于代码架构设计不佳而引发的异常消失</title>
    <link href="https://re0.top/2022/01/01/2022-first/"/>
    <id>https://re0.top/2022/01/01/2022-first/</id>
    <published>2022-01-01T10:00:00.000Z</published>
    <updated>2022-01-01T11:37:40.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>真的好久没写文章了，上一篇还是21年的6月写的。工作上事情再加上回来只想打游戏，这半年就没输出文章，中间其实有几次想过写写，但是不知道写点啥。  </p><p>打扫完房间，坐下打开电脑，正好原神预下载，也想想好久没写文章了，正好最近有个有意思的也是自己遇到问题，就边下载边码字了。  </p><p>今天是2022年的元旦，先祝看到这篇文章的朋友新年快乐吧。</p><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>这篇文章聊聊finally关键字，这个关键字Python和Java程序员肯定都不陌生。相信很多程序员其实都看过很多文章说finally关键字里面最好不要有return关键字，这点肯定很多人都知道，鉴于可能有人不知道，这里还是讲讲(水字数石锤)。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="由多个return导致返回值缺失"><a href="#由多个return导致返回值缺失" class="headerlink" title="由多个return导致返回值缺失"></a>由多个return导致返回值缺失</h2><p>上文说，很多文章警告不要在finally中使用return，他们文章里给出的例子很简单，这里我以Python为例，假设有以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">finally</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么其实这个函数返回值是2，而不是1，容易引起误解，所以大多数情况下，我们不会再finally中写任何return，防止返回值与预期不一致。</p><h2 id="脚本执行架构设计"><a href="#脚本执行架构设计" class="headerlink" title="脚本执行架构设计"></a>脚本执行架构设计</h2><p>而这篇文章要讲的也是finally，但不是因为返回值不一致。要讲这个之前，我想先讲一讲为啥我会遇到这个问题。  </p><p>大概是21年10月份，我们的测试框架打算引入前置与后置功能，那这部分的实现就落在我身上了，领导也很看重，希望能实现一个健硕的执行架构，那我也看了一些执行框架源码，比如rebot，但是其实关键部分光看源码其实看不出所以然出来，所以我决定先写下第一行代码再说。  </p><p>熟悉测试的同学应该知道，测试脚本呢，其实分为三部分，一是环境的准备（setup），测试主体（main），资源回收（teardown），用户只关心的是测试主体是否成功。那基于我们的测试执行框架，其实这三部分并没有什么差别，是分为三个脚本去执行，因此就需要一个调度框架去控制执行的顺序。  </p><p>执行的代码我们可以简化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self, stage</span>):</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> stage == <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;执行main&quot;</span>)</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">elif</span> stage == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;执行setup&quot;</span>)</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">elif</span> stage == <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;执行teardown&quot;</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">print</span>(<span class="string">&quot;发生异常，记录，置该脚本状态为FAIL&quot;</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">finally</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;根据stage不同，回填不同阶段的日志到服务器上&quot;</span>)</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;回填日志失败，记一下错误&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大概就是这个样子，这个就是最基础的执行方法，通过传入不同的stage，执行方法和回填日志。那调度方法可以简化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_case</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​        execute(<span class="number">0</span>)  <span class="comment"># 执行setup</span></span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> self.result == <span class="string">&quot;PASS&quot;</span>:</span><br><span class="line"></span><br><span class="line">​            execute(<span class="number">1</span>)  <span class="comment"># setup成功才执行main</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">finally</span>:</span><br><span class="line"></span><br><span class="line">​        execute(<span class="number">2</span>)  <span class="comment"># 无论如何都需要执行teardown</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然真实情况远没有那么简单，因为是一个执行树，所以需要递归调用，但这个地方不是重点，这里只讲最简单的架构。  </p><p>起初我对这个设计还是比较满意的，借助try和finally实现了对不同阶段的调用，之后我便考虑如何去停止正在执行的脚本。而关于停止，我设计了两套实现，其一是停止后，继续执行已执行过setup的脚本的teardown内容，其二是真正停止运行，不执行teardown。</p><p>我在类中声明了两个类变量，self.exit 和 self.real_exit，分别代表两种退出。其中当real_exit为True时，exit一定为True，但反过来不一定。因此上面的调度代码被我改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_case</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​        execute(<span class="number">0</span>)  <span class="comment"># 执行setup</span></span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> <span class="keyword">not</span> self.exit <span class="keyword">and</span> self.result == <span class="string">&quot;PASS&quot;</span>:</span><br><span class="line"></span><br><span class="line">​            execute(<span class="number">1</span>)  <span class="comment"># setup成功才执行main</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">finally</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> self.real_exit:</span><br><span class="line"></span><br><span class="line">​            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">​        execute(<span class="number">2</span>)  <span class="comment"># 无论如何都需要执行teardown</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>请注意，这段代码是有问题的。</strong> </p><p>这里先说说exit和real_exit的赋值，上面有说过，因为是执行树，其实这两个变量在使用前其实必须使用self.exit = self.parent.get_exit()，通过递归来获取最顶层的状态，这里暂且提一下，这个不是本文的重点。</p><p>请注意，这里我在finally中用了return关键字，乍一看没啥问题，我当初觉得也没啥问题。首先run_case这个方法是没有返回值的，执行结果全在类变量中，然后是execute这个方法，全程也是在try/except的代码块中的，因此当初我认为不会有什么问题。这里run_case方法上层其实还有一层，为用户实际执行的层次，可以简化为：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">job</span>):</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​        job.run_case()</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">print</span>(<span class="string">&quot;执行发生异常，做个标记&quot;</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">finally</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">print</span>(<span class="string">&quot;有异常就通知用户，没有就通知已完成执行&quot;</span>)</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">print</span>(<span class="string">&quot;发送邮件&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，这个执行调度架构也直接上线了。期间也没出现过什么离谱的问题，满意度还是比较高的。</p><h2 id="开始意识到不对"><a href="#开始意识到不对" class="headerlink" title="开始意识到不对"></a>开始意识到不对</h2><p>我们服务器是保留1个月的日志，所以有概率seaweed会爆满的，当爆满时，日志无法回填，但其实测试脚本还是会继续跑的。所以有用户与我反馈说能不能上传失败就停下脚本，这样很浪费时间，执行完也没报告看，还不如不执行。我觉得有道理，便开始了改造，这改造不要紧，结果发现了这个架构中的大问题，也是我写这篇文章的原因。  </p><p>由于日志回填是在execute方法中，因此我们改造这个方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self, stage</span>):</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> stage == <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;执行main&quot;</span>)</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">elif</span> stage == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;执行setup&quot;</span>)</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">elif</span> stage == <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;执行teardown&quot;</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="built_in">print</span>(<span class="string">&quot;发生异常，记录，置该脚本状态为FAIL&quot;</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">finally</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;根据stage不同，回填不同阶段的日志到服务器上&quot;</span>)</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">​            <span class="built_in">print</span>(<span class="string">&quot;回填日志失败，记一下错误&quot;</span>)</span><br><span class="line"></span><br><span class="line">​            self.upload_error_time += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">​            <span class="keyword">if</span> self.upload_error_time &gt;= <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">​                self.root_case.real_exit = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">​                <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;上传错误次数累计超过上限&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我在日志回填的时候，增加了简单的错误次数判断，那么如果顺利的话，当上传错误超过3次时，应该是这么一个流程：execute方法在finally中抛出了一个异常，由于没有捕获，抛给了它的调用方run_case，run_case是在try中接收了这个异常，但由于也没有捕获，又向上抛给了run方法，run方法捕获了这个异常，停止执行，并通知用户。</p><p>而之所以加入了self.root_case.real_exit，其实是为了不让run_case中finally执行，即不执行teardown。但我在写这篇文章的时候意识到，其实应该让teardown执行才对，不然环境没回收也是个问题，找个时间改下。当然这个也不是重点，因为我们就只想要上传失败3次后停下来，不想多执行其他的脚本了。</p><p>写完这个需求，我笑到，这个需求也是蛮简单的。但当我进行调试时，却发现事情的不对。首先我在回填日志时每次都抛出一个异常来模拟出现问题，这里便不多说。然后批量执行几个脚本，观察是否会如同预期一样，3次后直接抛出异常。这里要说的是，不管脚本的前置后置有没有内容，日志都会回填，我的执行树大概是这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root_case</span><br><span class="line">    folder</span><br><span class="line">        case1</span><br><span class="line">        case2</span><br><span class="line">        case3</span><br></pre></td></tr></table></figure><p>那么失败3次，就是root_case，folder，case1的setup都失败，此时发生异常退出。</p><p>但并没有像我预想的一样异常退出，而是正常退出？！我觉得可能是哪里有问题，又多执行了几次，但是还是这样。我就开始调试代码了。调试了很久，因为执行树是递归调用，所以调试很不容易，调了半个下午，这时候我才意识到我的异常被run_case中的finally中的return给吞噬了。</p><p>虽然run_case没有返回值，但是finally中的return还是出现了问题，这就是这次经历给我带来的教训，无论如何，不要在finally中写下return！不管是什么原因。</p><p>那么后来我便改成了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_case</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​        execute(<span class="number">0</span>)  <span class="comment"># 执行setup</span></span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> <span class="keyword">not</span> self.exit <span class="keyword">and</span> self.result == <span class="string">&quot;PASS&quot;</span>:</span><br><span class="line"></span><br><span class="line">​            execute(<span class="number">1</span>)  <span class="comment"># setup成功才执行main</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">finally</span>:</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">if</span> <span class="keyword">not</span> self.real_exit:</span><br><span class="line"></span><br><span class="line">​            execute(<span class="number">2</span>)  <span class="comment"># 无论如何都需要执行teardown</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时候异常就顺利向上抛出了。趁着没人发现这个bug，偷偷把它修了，哈哈。虽然没造成什么影响就是了，因为下层的一些会发生异常的操作方法，都会捕获异常。实际使用时并不会向上抛异常。</p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>这篇文章其实废话有点多，其实关键就一点，就是finally中不要写任何return，无论什么原因，除非你保证没有返回值或者下层绝对不会抛出异常。</p><p>除开这个，也讲了讲自己设计和编写的执行架构，我个人认为这个架构还是挺不错的，鉴于篇幅只讲了其中的一小部分，有机会的话可以来讲讲这个框架里我的callback设计，即执行单个脚本或者整个批次后进行一些调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;真的好久没写文章了，上一篇还是21年的6月写的。工作上事情再加上回来只想打游戏，这半年就没输出文章，中间其实有几次想过写写，
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="https://re0.top/tags/Python/"/>
    
      <category term="架构" scheme="https://re0.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>zbot架构畅谈</title>
    <link href="https://re0.top/2021/06/08/zbot/"/>
    <id>https://re0.top/2021/06/08/zbot/</id>
    <published>2021-06-08T06:10:00.000Z</published>
    <updated>2021-06-08T06:53:49.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>zbot是由我个人编写的简易机器人框架，它依赖于mirai与mirai_api_http，目前实现了关键字回复与定时功能，<a href="https://github.com/zer0e/zbots">zbot项目地址</a>。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>本文的目的是聊聊zbot的项目架构，这个项目应该是我第一个思考并运用架构知识所编写的框架应用，虽然功能简单，但其中架构部分却值得思考与拓展。<br>zbot主要由以下几部分组成：</p><ul><li>handler，主要用于处理消息或者定时处理</li><li>receiver，从mirai_api_http接收消息的websocket客户端</li><li>pluginLoader，负责从外部加载用户自定义插件到框架中</li><li>Api，封装mirai_api_http的部分功能供用户插件使用</li><li>registry，注册中心，负责插件注册，调度和转发请求 </li></ul><h2 id="借鉴主流RPC框架架构"><a href="#借鉴主流RPC框架架构" class="headerlink" title="借鉴主流RPC框架架构"></a>借鉴主流RPC框架架构</h2><p>zbot前期架构准备中，借鉴了主流RPC框架的架构，以dubbo框架为例，这是一张dubbo的架构图。<img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/zbot/dubbo1.jpg" alt="dubbo架构"><br>在dubbo中，provider，即服务提供方通过主动方式向注册中心注册服务；而消费端则是通过向注册中心获取已经注册的服务列表，需要时通过协议直接对服务提供方进行调用。这么做的好处是注册中心只负责了服务注册与发现，不转发请求，减小了注册中心的压力，这对整个架构是必须的。  </p><h2 id="更换架构"><a href="#更换架构" class="headerlink" title="更换架构"></a>更换架构</h2><p>虽然dubbo框架的架构方案十分不错，但考虑到以下几点</p><ul><li>需要设计私有协议</li><li>服务提供方必须提供其注册中心地址进行注册，但zbot插件必须是无配置或者少配置的，因为需要令插件无需配置就能运行在各个环境中</li><li>为了开箱即用，注册中心无需成为单独节点，如zk，而是直接整合进框架中</li><li>对提供方可能得编写单独依赖，如TCP支持，自动注册等等</li></ul><p><strong>zbot的目的是插件开发简单，并且开箱即用。</strong>综合以上几点，主流RPC框架的架构其实并不适用与zbot。随后我借助RPC框架的各个节点角色重新设计架构。以下是项目架构图。<img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/zbot/zbot.jpg" alt="zbot架构">   </p><h2 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h2><p>首先谈谈关键的插件部分，对应到RPC框架中就是服务提供方，那在zbot中，服务提供方不再通过主动方式去注册，而是通过pluginLoader对服务进行扫描，主要做法是读取框架配置与目录下的插件，再将开启的有效插件进行统一注册。那在后续的思考中，我认为zbot的架构中registry与pluginLoader应该合并为一个新的registry，由注册中心主动扫描并注册插件。但考虑到框架整体已经完成，并没有太大必要去整合架构，此处只是提出个人看法。  </p><hr><p>其次就是服务消费端的调用流程，在zbot中，服务消费端就是msghandler，他通过订阅注册中心的关键词列表，负责消息的处理。重点是，在RPC框架中，当需要消费提供者的服务时，是由消费端主要通过协议调用提供者，而在zbot中，则是消费端需要调用服务时，将消息与服务端的id转发至注册中心，由注册中心进行调用。<br>这么做的好处是消费端不用存储服务端的地址，前面提到，提供方需要简单开发，尽管通过依赖与注解或许能暴露服务端的接口，但需要占用端口，并且框架的开发难度也会加大。那么坏处就是注册中心的压力变大，不仅需要负责服务发现并且需要请求转发。  </p><hr><p>最后是调用方式，从消费端转发给注册中心，再从注册中心调用消费端，均采用异步方式，因为消费端不依赖与服务提供者，所以可以不用同步进行调用。这样可以防止服务提供方的故障，或者说避免API方面故障使得框架出现异常卡死。</p><h1 id="后续思考"><a href="#后续思考" class="headerlink" title="后续思考"></a>后续思考</h1><p>目前想到的点其实是插件热加载。如果以目前的架构来说，热加载只能让pluginLoader再次去加载插件，因此需要从头开始扫描。如果是主动服务注册的方式，那么热加载实现可能会更灵活。只能说各有利弊，前面也有提到，插件不能分离与框架，插件不应该独立运行，而是依托于整个框架。并且采用主动注册方式也就需要重新加载所有插件，令插件自行去注册。从这方面来看，zbot不管采用主动注册方式还是被动加载方式都没有什么差别。<br>目前的实现方案还是在zbot框架前套一个启动器，zbot包含以上几个部分，因为需要将这几个部分组合起来。在不影响现有代码的情况下，通过编写不同工厂方法能在原有zbot的基础上封装一个类似命令行的界面，reload命令实现重新加载插件与配置，这是目前的方案。至于实现日期，<del>咕咕咕</del>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;zbot是由我个人编写的简易机器人框架，它依赖于mirai与mirai_api_http，目前实现了关键字回复与定时功能，&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="架构" scheme="https://re0.top/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="Java" scheme="https://re0.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>对bsgamesdk的签名逆向分析</title>
    <link href="https://re0.top/2021/04/05/bsgamesdk-re/"/>
    <id>https://re0.top/2021/04/05/bsgamesdk-re/</id>
    <published>2021-04-05T06:10:00.000Z</published>
    <updated>2021-04-05T08:40:54.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近看到pcr查看个人信息的脚本，比较感兴趣就稍微研究了一下。之前很早的时候对pcr进行过抓包，没想到是基于http协议的，感觉日本那边的it技术比国内的稍微落后一点。<br>pcr接入的是bilibili游戏，要登录游戏得先登录b站账号，抓包之后发现登录过程还是比较简单的，首先是从服务器获取rsa公钥，然后把密码进行rsa加密，添加公共请求头就可以登录了。但是请求中存在的sign参数文档并没有公开。<br>虽然网上的脚本已经把逻辑写清楚，但是我还是决定深入sdk源码，查看签名的逻辑。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>从<a href="http://open.biligame.com/wiki/">官网</a>上下载最新的SDK和demo，用AndroidStudio打开工程就可以准备开始了。  </p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>在左侧的external libraries点开demo项目所依赖的sdk。有classes.jar和r-classes.jar。r里面就只有与Alipay相关的东西，应该不是所要找的代码。<br>点开classes.jar，随便点开几个发现都被简单混淆了。随后翻到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classes.jar!\com\bsgamesdk\android\api</span><br></pre></td></tr></table></figure><p>这个包应该是与api请求相关的。<br>大部分类都被混淆了。只留下三个有名字的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BSGameSdkAuth</span><br><span class="line">BSGameSdkExceptionCode</span><br><span class="line">BSGameSdkHttpQueryMap</span><br></pre></td></tr></table></figure>  <p>一个一个看，Auth类基本上都是parse方法，对传入的参数进行json解析。ExceptionCode则是各类错误码和错误提示。<br>那重点可能会在HttpQueryMap中。  </p><h2 id="初露曙光"><a href="#初露曙光" class="headerlink" title="初露曙光"></a>初露曙光</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">a</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">    var1 = var1.replace(<span class="string">&quot;+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">    var1 = var1.replace(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;%2A&quot;</span>);</span><br><span class="line">    var1 = var1.replace(<span class="string">&quot;%7E&quot;</span>, <span class="string">&quot;~&quot;</span>);</span><br><span class="line">    var1 = var1.replace(<span class="string">&quot;!&quot;</span>, <span class="string">&quot;%21&quot;</span>);</span><br><span class="line">    var1 = var1.replace(<span class="string">&quot;(&quot;</span>, <span class="string">&quot;%28&quot;</span>);</span><br><span class="line">    var1 = var1.replace(<span class="string">&quot;)&quot;</span>, <span class="string">&quot;%29&quot;</span>);</span><br><span class="line">    var1 = var1.replace(<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;%27&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>首先是个转义方法，pass。接着看下一个方法：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendToUri</span><span class="params">(Builder var1, String var2)</span> <span class="keyword">throws</span> UnsupportedEncodingException, NoSuchAlgorithmException </span>&#123;</span><br><span class="line">    BSGameSdkHttpQueryMap.a var3 = <span class="keyword">this</span>.getSignedQuery(var2);</span><br><span class="line">    Iterator var4 = <span class="keyword">this</span>.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">        Entry var5 = (Entry)var4.next();</span><br><span class="line">        String var6 = (String)var5.getKey();</span><br><span class="line">        String var7 = (String)var5.getValue();</span><br><span class="line">        var1.appendQueryParameter(var6, var7);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var1.appendQueryParameter(<span class="string">&quot;sign&quot;</span>, var3.b);</span><br><span class="line">    String var9 = var1.build().getEncodedQuery();</span><br><span class="line">    String var8 = <span class="keyword">this</span>.a(var9);</span><br><span class="line">    var1.encodedQuery(var8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>我们看到了sign，就是我们想要知道的，也就是sign的值应该是var3.b，而var3则是从getSignedQuery方法获得的。并且是一个<code>BSGameSdkHttpQueryMap.a</code>类，这是一个内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">a</span> </span>&#123;</span><br><span class="line">    String a;</span><br><span class="line">    String b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>接着看getSignedQuery方法。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BSGameSdkHttpQueryMap.<span class="function">a <span class="title">getSignedQuery</span><span class="params">(String var1)</span> <span class="keyword">throws</span> UnsupportedEncodingException, NoSuchAlgorithmException </span>&#123;</span><br><span class="line">    BSGameSdkHttpQueryMap.a var2 = <span class="keyword">new</span> BSGameSdkHttpQueryMap.a();</span><br><span class="line">    StringBuilder var3 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Iterator var4 = <span class="keyword">this</span>.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">        Entry var5 = (Entry)var4.next();</span><br><span class="line">        String var6 = (String)var5.getKey();</span><br><span class="line">        String var7 = (String)var5.getValue();</span><br><span class="line">        String var8 = URLEncoder.encode(var7, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        var8 = <span class="keyword">this</span>.a(var8);</span><br><span class="line">        var3.append(var6.toLowerCase(Locale.US));</span><br><span class="line">        var3.append(<span class="string">&#x27;=&#x27;</span>).append(var8).append(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> var13 = var3.length();</span><br><span class="line">    <span class="keyword">if</span> (var13 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        var3.deleteCharAt(var13 - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var2.a = var3.toString();</span><br><span class="line">    MessageDigest var14 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">    var14.reset();</span><br><span class="line">    var14.update(var2.a.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    var14.update(var1.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    StringBuffer var15 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">byte</span>[] var16 = var14.digest();</span><br><span class="line">    <span class="keyword">byte</span>[] var17 = var16;</span><br><span class="line">    <span class="keyword">int</span> var9 = var16.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var10 = <span class="number">0</span>; var10 &lt; var9; ++var10) &#123;</span><br><span class="line">        <span class="keyword">byte</span> var11 = var17[var10];</span><br><span class="line">        <span class="keyword">int</span> var12 = var11 &amp; <span class="number">255</span>;</span><br><span class="line">        <span class="keyword">if</span> (var12 &lt; <span class="number">16</span>) &#123;</span><br><span class="line">            var15.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var15.append(Integer.toHexString(var12));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var2.b = var15.toString().toLowerCase(Locale.US);</span><br><span class="line">    <span class="keyword">return</span> var2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>先看前一部分，首先是对var4进行迭代，把所有的参数和值以<code>key=value&amp;</code>的方式进行拼接，然后去掉最后一个&amp;符号。<br>接着是调用MessageDigest对所有参数进行md5，但是注意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var14.update(var2.a.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">var14.update(var1.getBytes(&quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure><p>var14除了对参数进行update外还对var1进行了update。值得一提的是，messagedigest进行多次update相当于两个拼接后再进行update。因此这个var1是关键，而var1又是appendToUri的var2，因此只需要寻找appendToUri的调用者就知道这个参数是什么了。<br>但是遗憾的是，ide对源码中的usage的支持不怎么样。因此到这里线索断了。  </p><h2 id="再辟新径"><a href="#再辟新径" class="headerlink" title="再辟新径"></a>再辟新径</h2><p>没办法，只能一个个看api包下的其他混淆类。这里因为是源码是用class文件编译出来的，所以高级搜索没法用。<br>幸运的是，我们在e类中找到了请求的api。因为在抓包的时候，我们发现客户端会对<code>/api/client/rsa</code>进行获取rsa公钥。我们在e类中发现了这个地址。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BSGameSdkAuth <span class="title">b</span><span class="params">(<span class="keyword">final</span> Context var1)</span> <span class="keyword">throws</span> BSGameSdkExceptionCode, HttpException, IOException </span>&#123;</span><br><span class="line">    c var2 = <span class="keyword">new</span> c&lt;BSGameSdkAuth&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> BSGameSdkAuth <span class="title">b</span><span class="params">(String var1x)</span> <span class="keyword">throws</span> BSGameSdkExceptionCode, HttpException, IOException </span>&#123;</span><br><span class="line">            Builder var2 = Uri.parse(var1x).buildUpon();</span><br><span class="line">            var2.path(<span class="string">&quot;/api/client/rsa&quot;</span>);</span><br><span class="line">            Map var3 = e.c(var1, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.a(var3);</span><br><span class="line">            e.<span class="keyword">this</span>.a(var1, var3, var1x);</span><br><span class="line">            e.c(var3);</span><br><span class="line">            BSGameSdkAuth var4 = <span class="keyword">new</span> BSGameSdkAuth();</span><br><span class="line">            Uri var5 = var2.build();</span><br><span class="line">            HttpPost var6 = HttpDNSConfig.queryCachePost(var5.toString(), var3);</span><br><span class="line">            var6.addHeader(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 BSGameSDK&quot;</span>);</span><br><span class="line">            String var7 = HttpManager.executeForString(var1, var6);</span><br><span class="line">            var4.parseRSAResponse(var7);</span><br><span class="line">            <span class="keyword">return</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (BSGameSdkAuth)var2.a(<span class="number">0</span>, a.s(), <span class="string">&quot;rsa&quot;</span>, (String)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>主要还是看中间的几行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map var3 = e.c(var1, 1);</span><br><span class="line">this.a(var3);</span><br><span class="line">e.this.a(var1, var3, var1x);</span><br><span class="line">e.c(var3);</span><br></pre></td></tr></table></figure><p>先看e.c方法。cr^b进入方法。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">c</span><span class="params">(Context var0, <span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">    a();</span><br><span class="line">    HashMap var2 = <span class="keyword">new</span> HashMap();</span><br><span class="line">    var2.put(<span class="string">&quot;game_id&quot;</span>, com.bsgamesdk.android.model.c.a);</span><br><span class="line">    var2.put(<span class="string">&quot;merchant_id&quot;</span>, com.bsgamesdk.android.model.c.f);</span><br><span class="line">    var2.put(<span class="string">&quot;version&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    var2.put(<span class="string">&quot;timestamp&quot;</span>, <span class="string">&quot;&quot;</span> + com.bsgamesdk.android.api.b.b());</span><br><span class="line">    var2.put(<span class="string">&quot;client_timestamp&quot;</span>, <span class="string">&quot;&quot;</span> + System.currentTimeMillis());</span><br><span class="line">    var2.put(<span class="string">&quot;server_id&quot;</span>, com.bsgamesdk.android.model.c.g);</span><br><span class="line">    var2.put(<span class="string">&quot;sdk_ver&quot;</span>, com.bsgamesdk.android.model.c.l);</span><br><span class="line">    var2.put(<span class="string">&quot;sdk_type&quot;</span>, com.bsgamesdk.android.model.c.s);</span><br><span class="line">    var2.put(<span class="string">&quot;c&quot;</span>, a.c());</span><br><span class="line">    var2.put(<span class="string">&quot;isRoot&quot;</span>, com.bsgamesdk.android.model.c.q);</span><br><span class="line">    var2.put(<span class="string">&quot;udid&quot;</span>, com.bsgamesdk.android.model.c.p);</span><br><span class="line">    var2.put(<span class="string">&quot;support_abis&quot;</span>, com.bsgamesdk.android.model.c.r);</span><br><span class="line">    var2.put(<span class="string">&quot;mac&quot;</span>, TextUtils.isEmpty(ab.d()) ? <span class="string">&quot;&quot;</span> : ab.d());</span><br><span class="line">    var2.put(<span class="string">&quot;imei&quot;</span>, TextUtils.isEmpty(ab.b(var0)) ? <span class="string">&quot;&quot;</span> : ab.b(var0));</span><br><span class="line">    var2.put(<span class="string">&quot;android_id&quot;</span>, TextUtils.isEmpty(l.b(var0)) ? <span class="string">&quot;&quot;</span> : l.b(var0));</span><br><span class="line">    <span class="keyword">boolean</span> var3 = com.bsgamesdk.android.b.b.checkIsLogined(var0);</span><br><span class="line">    <span class="keyword">boolean</span> var4 = com.bsgamesdk.android.b.b.checkIsTouristLogined(var0);</span><br><span class="line">    String var5 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String var6 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (var3) &#123;</span><br><span class="line">        UserParcelable var7 = (<span class="keyword">new</span> m(var0)).c();</span><br><span class="line">        var5 = var7.uid_long + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        var6 = var7.access_token + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var4) &#123;</span><br><span class="line">        TouristUserParceable var10 = (<span class="keyword">new</span> com.bsgamesdk.android.model.k(var0)).c();</span><br><span class="line">        var5 = var10.uid_long + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        var6 = var10.access_token + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var2.put(<span class="string">&quot;uid&quot;</span>, var5);</span><br><span class="line">    var2.put(<span class="string">&quot;access_key&quot;</span>, var6);</span><br><span class="line">    var2.put(<span class="string">&quot;app_id&quot;</span>, com.bsgamesdk.android.model.c.a);</span><br><span class="line">    var2.put(<span class="string">&quot;sdk_log_type&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    var2.put(<span class="string">&quot;ver&quot;</span>, com.bsgamesdk.android.model.c.i);</span><br><span class="line">    var2.put(<span class="string">&quot;version_code&quot;</span>, com.bsgamesdk.android.model.c.j);</span><br><span class="line">    var2.put(<span class="string">&quot;channel_id&quot;</span>, com.bsgamesdk.android.model.c.c);</span><br><span class="line">    h.a(var2);</span><br><span class="line">    var2.put(<span class="string">&quot;platform_type&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">    var2.put(<span class="string">&quot;model&quot;</span>, h.c(var0));</span><br><span class="line">    var2.put(<span class="string">&quot;brand&quot;</span>, h.d(var0));</span><br><span class="line">    var2.put(<span class="string">&quot;net&quot;</span>, h.a(var0));</span><br><span class="line">    var2.put(<span class="string">&quot;operators&quot;</span>, h.b(var0));</span><br><span class="line">    var2.put(<span class="string">&quot;pf_ver&quot;</span>, h.e(var0));</span><br><span class="line">    var2.put(<span class="string">&quot;dp&quot;</span>, com.bsgamesdk.android.model.c.t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String var11 = TextUtils.isEmpty(o.a(var0).c) ? <span class="string">&quot;&quot;</span> : o.a(var0).c;</span><br><span class="line">        String var8 = TextUtils.isEmpty(o.a(var0).d) ? <span class="string">&quot;&quot;</span> : o.a(var0).d;</span><br><span class="line">        var2.put(<span class="string">&quot;old_buvid&quot;</span>, var11);</span><br><span class="line">        var2.put(<span class="string">&quot;cur_buvid&quot;</span>, var8);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">        var2.put(<span class="string">&quot;old_buvid&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        var2.put(<span class="string">&quot;cur_buvid&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        LogUtils.printThrowableStackTrace(var9);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(b)) &#123;</span><br><span class="line">        b = com.bsgamesdk.android.utils.a.a(var0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var2.put(<span class="string">&quot;apk_sign&quot;</span>, b);</span><br><span class="line">    var2.put(<span class="string">&quot;oaid&quot;</span>, TextUtils.isEmpty(com.bsgamesdk.android.model.c.z) ? <span class="string">&quot;&quot;</span> : com.bsgamesdk.android.model.c.z);</span><br><span class="line">    var2.put(<span class="string">&quot;fingerprint&quot;</span>, TextUtils.isEmpty(com.bsgamesdk.android.model.c.A) ? <span class="string">&quot;&quot;</span> : com.bsgamesdk.android.model.c.A);</span><br><span class="line">    <span class="keyword">return</span> var2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中，参数var1是个遗留参数，并没有使用。应该只是为了重载方法。这个方法的作用就是添加各种参数，这些参数在抓包的时候param里面基本上都有。除了个别参数。和sign无关，往回看。接下来是两个this.a方法，也都是添加参数。<br>接下来是另一个c方法。<code>e.c(var3);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">(Map&lt;String, String&gt; var0)</span> </span>&#123;</span><br><span class="line">    String var1 = d(var0);</span><br><span class="line">    var0.put(<span class="string">&quot;sign&quot;</span>, var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>很好，这可能是我们需要的，继续跟进d方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">d</span><span class="params">(Map&lt;String, String&gt; var0)</span> </span>&#123;</span><br><span class="line">    String var1 = a(var0);</span><br><span class="line">    String var2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    var2 = p.a(var1, com.bsgamesdk.android.model.c.b);</span><br><span class="line">    <span class="keyword">return</span> var2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>先看第一行<code>String var1 = a(var0);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">(Map&lt;String, String&gt; var0)</span> </span>&#123;</span><br><span class="line">    ArrayList var1 = <span class="keyword">new</span> ArrayList(var0.keySet());</span><br><span class="line">    Collections.sort(var1);</span><br><span class="line">    String var2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var1.size(); ++var3) &#123;</span><br><span class="line">        String var4 = (String)var1.get(var3);</span><br><span class="line">        <span class="keyword">if</span> (var4 != <span class="keyword">null</span> &amp;&amp; !var4.equalsIgnoreCase(<span class="string">&quot;item_name&quot;</span>) &amp;&amp; !var4.equalsIgnoreCase(<span class="string">&quot;item_desc&quot;</span>)) &#123;</span><br><span class="line">            String var5 = (String)var0.get(var4);</span><br><span class="line">            var2 = var2 + var5;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>逻辑很简单，对map的参数key进行排序，然后把value拼接到一起。<br>接着看<code>var2 = p.a(var1, com.bsgamesdk.android.model.c.b);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">a</span><span class="params">(String var0, String var1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String var2 = var0 + var1;</span><br><span class="line">        MessageDigest var3 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        var3.update(var2.getBytes(Charset.defaultCharset()));</span><br><span class="line">        <span class="keyword">byte</span>[] var4 = var3.digest();</span><br><span class="line">        <span class="keyword">return</span> a(var4);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException var5) &#123;</span><br><span class="line">        LogUtils.printExceptionStackTrace(var5);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>其实就是把两个参数拼接起来然后进行MD5摘要。这就是我们的sign。<br>总结：sign就是所有参数排序后保留value然后拼接<code>com.bsgamesdk.android.model.c.b</code>的值进行hash。<br>那新的问题来了，这个model.c.b的值又是什么呢？</p><h2 id="接近答案"><a href="#接近答案" class="headerlink" title="接近答案"></a>接近答案</h2><p>跟进model.c类，b是一个静态String，而b的赋予在c类的a方法中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(Context var0, String var1, String var2, String var3, String var4, String var5, String var6, <span class="keyword">boolean</span> var7, String var8)</span> </span>&#123;</span><br><span class="line">    f = var1;</span><br><span class="line">    a = var2;</span><br><span class="line">    g = var3;</span><br><span class="line">    d = var7;</span><br><span class="line">    i = f(var0);</span><br><span class="line">    j = g(var0);</span><br><span class="line">    k = var5;</span><br><span class="line">    l = var6;</span><br><span class="line">    m = var8;</span><br><span class="line">    b = var4;</span><br><span class="line">    c = d(var0);</span><br><span class="line">    e = com.bsgamesdk.android.utils.o.a(var0).a();</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>之后就没有了，既然反向不行，那就从正向开始。<br>我们找到demo的MainActivity，跟进官方的文档，必须在oncreate中调用BSGameSdk.initialize方法完成sdk的初始化。我们跟进initialize方法。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BSGameSdk <span class="title">initialize</span><span class="params">(<span class="keyword">boolean</span> var0, Activity var1, String var2, String var3, String var4, String var5, InitCallbackListener var6, ExitCallbackListener var7)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">        com.bsgamesdk.android.utils.f.a(var1.getApplicationContext());</span><br><span class="line">        f = <span class="keyword">new</span> BSGameSdk(var0, var1, var2, var3, var4, var5, var6, var7);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <p>跟进BSGameSdk</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressLint(&#123;&quot;NewApi&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">BSGameSdk</span><span class="params">(<span class="keyword">boolean</span> var1, Activity var2, String var3, String var4, String var5, String var6, <span class="keyword">final</span> InitCallbackListener var7, ExitCallbackListener var8)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    com.bsgamesdk.android.model.c.a(var2, var3, var4, var5, var6, var9.getSDK_NAME(), var9.getSDK_Version(), var9.isBiliSDK(), var9.getVersion());</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>我们找到了刚才model.c的中a方法的调用方。<br>a方法中我们需要的值是参数中的var4也就是a方法中的第5个参数。对应到BSGameSdk构造方法就是var6，而var6在这则是第6个参数，再往上走是initialize方法，第6个参数是var5，也是第6个参数。<br>最后是MainActivity调用方，第6个参数对应的是app_key，至此破案。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们从源码中得到了sign的计算方式，是一堆参数排序后取value，然后拼接app_key后进行md5摘要。刚开始的HttpQueryMap可能是针对get方法在其他地方使用到，毕竟进行了url转义，当然也可能是一个遗留类，我们不得而知。<br>这次源码分析还是比较顺利，主要还是源码没有强加密和混淆，使得分析更加容易些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近看到pcr查看个人信息的脚本，比较感兴趣就稍微研究了一下。之前很早的时候对pcr进行过抓包，没想到是基于http协议的，感觉日本那边的i
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://re0.top/tags/Java/"/>
    
      <category term="Android" scheme="https://re0.top/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Spring Boot自动配置</title>
    <link href="https://re0.top/2020/12/13/autoConfiguration/"/>
    <id>https://re0.top/2020/12/13/autoConfiguration/</id>
    <published>2020-12-13T06:10:00.000Z</published>
    <updated>2020-12-13T09:41:54.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久没写技术性文章了，今天就来谈谈SpringBoot中最常见但是却很少人去了解的知识，那就是SpringBoot是如何让你免去如此多的xml配置的。<br>本人技术有限，文章如有错误请谅解。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>用过SpringBoot的人都很清楚，它很方便，不用配置xml，开箱即用，那你是否想过SpringBoot是如何实现自动配置的呢？我也很好奇，那本文就深入源码看看SpringBoot都做了些什么来自动配置的吧。  </p><h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>那我们当然是新建一个项目啦，我们很清楚，springboot项目都用一个以@SpringBootApplication为注解的主类，这是我们项目的入口点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FirstDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>那通过上面的导入，我们知道@SpringBootApplication来自autoconfigure包中，看名字就知道这是我们需要的自动配置相关的包。那我们跟进这个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <p>这个注解里面使用@AliasFor将多个注解组合，简单解释就是将它上面的注解合并成当前注解，即SpringBootApplication。换句话来说，@SpringBootApplication就相当于@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解一起作用。<br>那其中@ComponentScan是我们比较熟悉的，用于扫描bean组件装配到ioc容器中，这里我们便不展开。<br>然后是@SpringBootConfiguration，跟进后我们发现其实就是@Configuration中的一种，也就是配置类，这里我们也不多讲。<br>本文的主角就是@EnableAutoConfiguration。</p><h2 id="深入-EnableAutoConfiguration"><a href="#深入-EnableAutoConfiguration" class="headerlink" title="深入@EnableAutoConfiguration"></a>深入@EnableAutoConfiguration</h2><p>我们跟进@EnableAutoConfiguration。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>有两个主要注解，@AutoConfigurationPackage和@Import({AutoConfigurationImportSelector.class})。<br>我们先来看看@AutoConfigurationPackage。</p><h3 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(&#123;Registrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>这里提一下，import注解是spring提供的，它的作用是将某个类实例化后加入ioc容器中。<br>那么我们就可以知道@AutoConfigurationPackage其实就是将Registrar.class实例化后加入ioc容器当中。继续跟进Registrar类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line">    Registrar() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        AutoConfigurationPackages.register(registry, (String[])(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>我们发现是一个静态内部类，其中有两个方法registerBeanDefinitions和determineImports。我们分别在两个方法中加入断点，调试下。其中<code>(String[])(new AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(new String[0])</code>返回的是@SpringBootApplication注解所在的类的包名，在这个项目中就是<code>com.example.first_demo</code>。<br>然后就是determineImports，在项目中没有触发断点，我们通过无敌的google大法知道返回的是一组代表要导入项的对象。这对本文的主题无多大关系，因此就略过。<br><strong>至此，@AutoConfigurationPackage的作用就是将主配置类所在的包及子包中的所有组件扫描到ioc容器当中。</strong></p><h3 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h3><p>重新回到@EnableAutoConfiguration，发现它将AutoConfigurationImportSelector添加到容器中。这应该就是自动配置的核心所在，我们跟进这个类。这个类中的方法很多，我们挑一些重要的来讲。<br>像getAutoConfigurationEntry方法，源码中还特意添加了注释。这个方法用于获取需要自动装配的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the &#123;<span class="doctag">@link</span> AutoConfigurationEntry&#125; based on the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125;</span></span><br><span class="line"><span class="comment"> * of the importing &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotationMetadata the annotation metadata of the configuration class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the auto-configurations that should be imported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>在这个方法中又有一个比较重要的方法，getCandidateConfigurations。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the auto-configuration class names that should be considered. By default</span></span><br><span class="line"><span class="comment"> * this method will load candidates using &#123;<span class="doctag">@link</span> SpringFactoriesLoader&#125; with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #getSpringFactoriesLoaderFactoryClass()&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the source metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> attributes the &#123;<span class="doctag">@link</span> #getAttributes(AnnotationMetadata) annotation</span></span><br><span class="line"><span class="comment"> * attributes&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a list of candidate configurations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">            getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">            + <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>这个方法返回所有候选配置类，即包括需要加载的和用户指定排除的。<br>在这个方法中使用了SpringFactoriesLoader.loadFactoryNames，SpringFactoriesLoader是Spring框架的一个内部工具类，用于加载类。继续跟进方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the fully qualified class names of factory implementations of the</span></span><br><span class="line"><span class="comment"> * given type from &#123;<span class="doctag">@value</span> #FACTORIES_RESOURCE_LOCATION&#125;, using the given</span></span><br><span class="line"><span class="comment"> * class loader.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As of Spring Framework 5.3, if a particular implementation class name</span></span><br><span class="line"><span class="comment"> * is discovered more than once for the given factory type, duplicates will</span></span><br><span class="line"><span class="comment"> * be ignored.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factoryType the interface or abstract class representing the factory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader the ClassLoader to use for loading resources; can be</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125; to use the default</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if an error occurs while loading factory names</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadFactories</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    ClassLoader classLoaderToUse = classLoader;</span><br><span class="line">    <span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    String factoryTypeName = factoryType.getName();</span><br><span class="line">    <span class="keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>这个方法返回加载类的全名，通过loadSpringFactories私用方法，我们详细来看这个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line">                String[] factoryImplementationNames =</span><br><span class="line">                        StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line">                <span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">                    result.computeIfAbsent(factoryTypeName, key -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;())</span><br><span class="line">                            .add(factoryImplementationName.trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Replace all lists with unmodifiable lists containing unique elements</span></span><br><span class="line">        result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()</span><br><span class="line">                .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>那么简单看下源码我们可以得知，该方法就是读取每个类中的META-INF/spring.factories文件中设置的所有xxxAutoConfiguration类，并使用PropertiesLoaderUtils.loadProperties获取其所有属性值，将这些值作为自动配置类添加到ioc容器当中，相当于完成了配置，以前需要手动配置的东西，自动配置帮我们添加了默认值。<br>我们可以看看spring-boot-autoconfigure中的spring.factories。这些都是默认自动装配的。<br>简单贴一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br></pre></td></tr></table></figure>  <p>比如我们看看AopAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(Advice.class)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">        <span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = false)</span></span><br><span class="line">        <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;,</span></span><br><span class="line"><span class="meta">                matchIfMissing = false)</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">        <span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line">        <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">                matchIfMissing = true)</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingClass(&quot;org.aspectj.weaver.Advice&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">            matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassProxyingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassProxyingConfiguration(BeanFactory beanFactory) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">                BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">                AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>可以清楚地看到，springboot提供了默认配置类，并通过条件注解来加载配置到容器中。</p><h2 id="第三方jar自动配置"><a href="#第三方jar自动配置" class="headerlink" title="第三方jar自动配置"></a>第三方jar自动配置</h2><p>从上面我们已经可以知道springboot会扫描所有类的spring.factories，并从中读取自动配置类。就比如常用的mybatis，我们在项目中导入mybatis，并查看它的依赖。<br>一般来说，我们在springboot项目中都是使用mybatis-spring-boot-starter导入到pom文件中，我们查看这个包的依赖，其实就是导入mybatis，jdbc，还有mybatis-spring-boot-autoconfigure，看到autoconfigure，我们知道肯定就是这个包完成自动配置。<br>我们查看这个包的资源文件，果然发现了spring.factories文件。里面就几行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span><br></pre></td></tr></table></figure>  <p>这里默认配置类我就不贴了，就是通过条件注解将默认配置添加到spring中。</p><h2 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h2><p>上文提到了条件注解，它作用在类上就是满足一定条件时类才会进行装配，其中条件注解有：</p><ul><li>ConditionalOnBean 容器中存在某个bean时生效</li><li>ConditionalOnClass classpath中存在某类时生效</li><li>ConditionalOnCloudPlatform 当指定的云平台处于活动状态时生效</li><li>ConditionalOnExpression SpEL表达式结果为true时生效</li><li>ConditionalOnJava 指定的Java版本存在时生效</li><li>ConditionalOnJndi 指定的JNDI存在时生效</li><li>ConditionalOnMissingBean 容器中不存在某个bean时生效</li><li>ConditionalOnMissingClass classpath中不存在某类时生效</li><li>ConditionalOnNotWebApplication 非Web应用环境下生效</li><li>ConditionalOnProperty 参数设置或者值一致时生效</li><li>ConditionalOnResource 指定的文件存在时生效</li><li>ConditionalOnSingleCandidate 容器中该类型Bean只有一个或@Primary的只有一个时生效</li><li>ConditionalOnWarDeployment 使用WAR部署时生效</li><li>ConditionalOnWebApplication Web应用环境下生效</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那本文简单从源码入手，讲解了springboot是如何自动配置的，@SpringBootApplication注解中包含了@EnableAutoConfiguration，这个注解帮助我们自动配置。<br>首先springboot在启动时扫描同一个包类的所有的组件，并检查各个jar包中是否存在META-INF/spring.factories 文件，然后如果第三方jar中存在这个文件，会根据文件中设置的自动装配类进行加载，使之生效。如此便实现了自动配置。<br>不过话说回来，说是自动配置，其实就是源码和第三方包中帮你把配置的功夫省下来了，节约不少时间，也能防止很多bug的出现。<br>那本文也留下很多没提到的，比如springboot怎么开始自动配置的，我们知道它如何装配，但是我们却不知道如何开始。这个也是个有趣的点，之后会写一写springboot的生命周期相关的文章。</p><h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><p>那本文写到这里就结束了，2020年马上也要过去了，时间是真的快，有空的话也会写写2020年的总结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;好久没写技术性文章了，今天就来谈谈SpringBoot中最常见但是却很少人去了解的知识，那就是SpringBoot是如何让你免去如此多的xm
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://re0.top/tags/Java/"/>
    
      <category term="Spring" scheme="https://re0.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>回顾数据库事务隔离级别</title>
    <link href="https://re0.top/2020/11/01/transaction_isolation/"/>
    <id>https://re0.top/2020/11/01/transaction_isolation/</id>
    <published>2020-11-01T06:10:00.000Z</published>
    <updated>2020-11-02T07:24:22.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于数据库隔离级别，前前后后可能复习了好多遍，但是很经常就忘记，今天就简单整理下概念和实例，方便以后回顾。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>首先我们先明确事务是什么？为什么要有事务？<br>事务(Transaction)，其实就是一个操作序列，我们知道，操作数据库是什么一条条SQL语句来实现的，那么事务就是包含这些SQL操作的清单。<br>至于为什么要有事务，是因为事务是为了解决并发情况下如何保持数据一致性的问题。通过事务，我们能在并发情况下保持数据的一致性。    </p><h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><p>事务的四大特性简称ACID，分别为原子性(Atomicity)，一致性(Consistency)，隔离性(Isolation)，持久性(Durability)。<br>所谓原子性，是指事务中包含的所有操作必须全部成功或者全部失败。<br>一致性，是指事务执行前后，数据的状态是一致的。一般来说，就是指数据不会凭空产生或消失。就拿库存和订单来说，商品的订单增加必定伴随着库存的减少，两者涉及的商品总量是一致的。<br>隔离性，是指多个事务并发执行时，彼此之间要相互隔离，简单来说就是事务感受不到其他事务的存在。这就是我之后要讲的隔离级别。<br>持久性，是指事务一旦提交，那么对于数据库中数据的改变是永久性的。  </p><h2 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h2><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p>通常情况下，对mysql命令行的所有语句都是自动提交的，可以简单理解成每条SQL语句都是一个独立的事务，在我们写SQL之前就开启了事务，当我们回车之后自动帮我们提交给数据库。<br>那这只是单条SQL语句，如果在命令行中要执行多条SQL语句的事务，需要使用begin和commit命令来显示开启事务。在事务提交之前，所有的修改都不会应用到数据上。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | abc  |</span><br><span class="line">|  2 | asd  |</span><br><span class="line">+----+------+</span><br><span class="line">2 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user values (3,&quot;aaa&quot;);</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | abc  |</span><br><span class="line">|  2 | asd  |</span><br><span class="line">|  3 | aaa  |</span><br><span class="line">+----+------+</span><br><span class="line">3 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected</span><br></pre></td></tr></table></figure><p>如果我们在commit之前打开另一个命令行进行查询，我们可以发现新插入的数据并没有在数据库中。  </p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>那在Spring中我们要使用事务，简单来说就是使用@Transactional注解来实现，即在方法上标注注解就可以实现。简单写下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDAO userDAO;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = userDAO.insert(user);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;显式抛出异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在addUser方法中手动抛出异常，如果@Transactional注解指定了触发回滚的异常类型，那么如果抛出了该种异常，就会自动回滚(rollback)，数据不会插入到数据库中。<br>那么关于spring中的事务管理与深入学习，就留到之后的文章再讨论吧。  </p><h2 id="并发事务所出现的问题"><a href="#并发事务所出现的问题" class="headerlink" title="并发事务所出现的问题"></a>并发事务所出现的问题</h2><p>前面提到在并发事务时，事务是相互隔离的，但是隔离有性能代价的，隔离越彻底，那么性能就越差，所以数据库会提供不同级别的隔离策略，开发者需要考虑事务并发的安全性与性能上的差异，来选择合适的隔离级别。<br>那么事务并发会引发哪些数据上的不安全性呢？  </p><h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p>丢失更新分为两类，一般称为第一类丢失更新和第二类丢失更新。<br>第一类丢失更新是指，在A事务回滚后，把已经提交的B事务的数据给覆盖掉了。例如A事务是扣款100元，而B事务是增加100元，在A事务已经修改余额但是还未提交或回滚时，B事务已经增加了100元。这时候A事务回滚，变为原来的钱，此时B事务增加的100元就消失了。<br>第二类丢失更新，是指在A事务提交后，把已经提交的B事务的数据给覆盖掉了。与第一类丢失更新类似，区别在于第一类是回滚，而第二类是提交。<br>丢失更新本质上和<strong>可重复读</strong>是同一类并发的问题，多个数据查询同一数据，都是基于自己的查询来更新数据，会造成最后一个提交或回滚的事务覆盖掉其他已经提交的事务。  </p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读的定义是读到未提交的数据。<br>这个好理解，假设原来有100元，现在A事务增加100元，余额变成200元，但此时还未提交，这时B事务读取到了事务A修改后的数据，即读取到余额为200元，然后把200元扣款成0元，并提交了数据。但最后A事务却进行了回滚，把余额重新变为100元。这样就相当于无缘无故增加了200块钱。<br>在默认隔离级别下，避免了脏读操作。  </p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读是指读到了已经提交的更新数据，即一个事务中两次相同查询却返回了不同的<strong>更新数据</strong>。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>幻读与不可重复读类似。幻读是指在一个事务中的两次相同查询却查到了另一个事务已提交的<strong>新插入数据</strong>。<br>两者区别是不可重复读是由数据修改产生的，而幻读是数据插入或者删除产生的。  </p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>那么为了解决上述的事务并发问题，Mysql中定义了四种隔离级别，分别是读未提交，读已提交，可重复读，可串行化。  </p><h3 id="读未提交-READ-UNCOMMITTED"><a href="#读未提交-READ-UNCOMMITTED" class="headerlink" title="读未提交(READ UNCOMMITTED)"></a>读未提交(READ UNCOMMITTED)</h3><p>在这种隔离级别下，事务A能读取到事务B修改但是未提交的数据，那么就会导致脏读，不可重复读和幻读问题。  </p><h3 id="读已提交-READ-COMMITTED"><a href="#读已提交-READ-COMMITTED" class="headerlink" title="读已提交(READ COMMITTED)"></a>读已提交(READ COMMITTED)</h3><p>这种隔离级别下，事务A只能在事务B修改并且提交之后才能读取到修改后的数据。<br>它解决了脏读问题，但是会发生不可重复读和幻读问题。  </p><h3 id="可重复读-REPEATABLE-READ"><a href="#可重复读-REPEATABLE-READ" class="headerlink" title="可重复读(REPEATABLE READ)"></a>可重复读(REPEATABLE READ)</h3><p>在这种隔离级别下，当事务B做出修改并提交后，只有事务A<strong>提交之后</strong>才能读到事务B修改的数据。<br>那可重复读解决了脏读和不可重复读问题，但是仍可能会发生幻读问题。<br>Q：Mysql中在update的时候会锁住当前行，但是为什么其他事务还能读到数据呢？<br>A：因为Mysql的innoDB有MVCC机制，可以使用快照读取数据，而不阻塞。那后面我会讲讲这个机制。  </p><h3 id="可串行化-SERIALIZABLE"><a href="#可串行化-SERIALIZABLE" class="headerlink" title="可串行化(SERIALIZABLE)"></a>可串行化(SERIALIZABLE)</h3><p>在这种隔离级别下，如果两个事务都是对数据进行修改，那么事务将以串行化的方式顺序执行，保证数据的安全。以下分四种情况讨论，假设事务A先于事务B：  </p><ul><li>如果事务A与事务B都是读取同一个数据，那这种情况下事务不会阻塞。因为没有读数据进行修改。</li><li>如果事务A先读取数据，这时事务B要修改这行数据，那么事务B会阻塞直到事务A提交。</li><li>如果事务A先修改数据，事务B要读取数据，那么事务B会阻塞直到事务A提交。  </li><li>如果事务A先修改数据，而事务B也要修改这行数据，那么事务B会等到事务A提交过后再进行修改。  </li></ul><p>那么综上所述，可串行化就是根据事务的先后顺序，来决定读取和修改数据的先后。可以简单理解成当前一个事务结束，后一个事务才开始，但是要注意的是，后一个事务其实早就开始了，只是被阻塞而已。<br>可串行化下，读取会获得<strong>表级的共享锁</strong>，因此读写相互就会阻塞。<br>那么在可串行化下，解决了脏读，不可重复读还有幻读问题，避免了并发事务中的读取与修改问题。  </p><h3 id="查看和修改事务隔离级别"><a href="#查看和修改事务隔离级别" class="headerlink" title="查看和修改事务隔离级别"></a>查看和修改事务隔离级别</h3><p>分别为系统隔离级别和会话隔离级别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@global.tx_isolation,@@tx_isolation;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| @@global.tx_isolation | @@tx_isolation  |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| REPEATABLE-READ       | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">1 row in set</span><br><span class="line"></span><br><span class="line">mysql&gt; set global transaction isolation level Repeatable Read;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; set session transaction isolation level Repeatable Read;</span><br><span class="line">Query OK, 0 rows affected</span><br></pre></td></tr></table></figure><h2 id="mysql如何实现隔离级别"><a href="#mysql如何实现隔离级别" class="headerlink" title="mysql如何实现隔离级别"></a>mysql如何实现隔离级别</h2><h3 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h3><p>首先我们要明白数据库遵循的是两段锁协议，即事务分为两个阶段，加锁和解锁。<br>加锁阶段，就是在相应的操作前要申请对应的锁。如在读操作前要申请S锁(share共享锁)，此时其他事务可以继续添加S锁，但不能添加X锁；又如在写操作前要申请X锁(排他锁)，此时其他事务不能添加任何锁。如果加锁不成功那么事务会等待直到加锁成功。<br>解锁阶段，一般在事务的提交时，会同时释放这个事务所申请的所有锁。<br>那么两段锁协议无法避免死锁，但是能保证事务并发调度是串行化的(注意不是隔离级别)，在数据备份与恢复时十分重要。 </p><h3 id="读已提交与可重复读的加锁方式"><a href="#读已提交与可重复读的加锁方式" class="headerlink" title="读已提交与可重复读的加锁方式"></a>读已提交与可重复读的加锁方式</h3><p>前面有提到过，mysql当中有表锁和行锁，表锁锁住的是整张表，例如可串行化下就是使用表锁，而行锁则是锁住有限的数据行。  </p><h4 id="读已提交-RC"><a href="#读已提交-RC" class="headerlink" title="读已提交(RC)"></a>读已提交(RC)</h4><p>在读已提交这个隔离级别中，假设事务A与事务B都要修改同一条数据，但是事务A先于事务B，那么根据前面我们知道，读已提交就是事务B只能读到事务A已经修改的数据。那么当事务A修改数据后，但是并未提交时，根据两段锁协议，事务A会在修改之前申请X锁，在提交之后释放，那么事务A一直不commit，则会导致事务B一直拿不到锁，直到超时。  </p><p>那么这里有一个值得注意的地方。那就是mysql如何确定要获取哪个行的行级锁呢？答案就是索引。假设id为索引，那么<code>update user set name = &quot;123&quot; where id = 1;</code>这条语句会根据id来找到相应的行，并获取这个行的行级锁。如果SQL语句的条件不是根据索引，那么此时mysql会给整个表的行加行级锁。<br>那么更有意思的出现了，mysql锁住所有行之后，会再次进行过滤，发现条件不满足时，会直接将该行的行级锁给释放，这违反了二段锁协议。这样确定了最后只有满足条件的行上加了锁。（详情见《高性能Mysql》）  </p><h4 id="可重复读-RR"><a href="#可重复读-RR" class="headerlink" title="可重复读(RR)"></a>可重复读(RR)</h4><p>这个是Mysql中innodb默认的隔离级别。我们知道这个级别下，同一个事务中的相同查询只会查到相同的数据。假设事务A做了两次查询，但是事务B和事务C同时在两次查询中间修改了数据，但是却返回了相同的数据。<br>如果使用锁来实现，又是如何实现呢？很简单，既然不可重复读的重点是update和delete，那么我在读取数据时直接加X锁，其他事务无法修改这些数据，那么就可以实现可重复读了。但是幻读又是怎么解决的呢？前面也简单提到过，可串行化的隔离级别，本质上就是通过读锁和写锁实现，只不过读写锁互斥，这就解决了幻读问题。<br>上面所讲的，就是使用<strong>悲观锁</strong>来实现隔离级别的，但是mysql出于性能考虑，RR级别下是采用乐观锁为基础的MVCC协议来实现。  </p><h3 id="MVCC协议"><a href="#MVCC协议" class="headerlink" title="MVCC协议"></a>MVCC协议</h3><h4 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h4><p>在谈这个协议之前，我们先来讲讲悲观锁和乐观锁。<br>前面的文章我也提到过，悲观锁是指认为所有数据随时都可能被修改，而乐观锁则是认为数据并不是随时会更新，所以它只会在更新时判断数据是否已经进行了更新。<br>那么乐观锁大多数是基于版本号来实现的。即在数据行中添加一个新的数据段version，通过这个version来判断读取的数据和当前数据库中的数据是否是同一个，也就是是否已经被修改过。  </p><h4 id="innoDB中MVCC的实现"><a href="#innoDB中MVCC的实现" class="headerlink" title="innoDB中MVCC的实现"></a>innoDB中MVCC的实现</h4><p>MVCC，全称为Multi-Version Concurrency Control，即多版本并发控制。MVCC没有固定的规范，所以每个数据库的实现可能会不同，这里讲讲innoDB中的实现。<br>在innoDB当中，每行记录都会由两个隐藏的列，一个是创建版本号，另一个是删除版本号。创建版本号是指创建一个数据行的事务版本号(事务版本号：事务开始时的系统版本号；系统版本号：每开始一个事务，系统版本号就会递增)。(ps.搁着套娃呢)<br>删除版本号则是delete操作时的版本号。<br>在RR级别下，各种操作如下：</p><ul><li>insert操作时，记录当前事务版本号为当前行的创建版本号。</li><li>delete操作时，记录当前事务版本号到删除版本号。</li><li>update操作时，先记录当前事务版本号到删除版本号，再增加一条记录，保存当前事务版本号为创建版本号。  </li><li>select操作时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或者&gt;当前事务版本号。即创建操作早于当前事务，删除操作晚于当前事务。</li></ul><p>那么通过MVCC协议，虽然会增加额外的存储空间，但是可以减少锁的使用，读取数据时不用加锁。<br>那这里又有一个有趣的点，那就是不管从书上还是网上，基本上是说RR级别解决了不可重复读，无法解决幻读。但是在mysql当中却是另一种情况。<br>假设事务A两次读取中间我们使用事务B增加一条数据，理论上来说事务A第二次读会读取到事务B中增加的行。<br>那么实验出结果，先是事务A读取一次数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | abc  |</span><br><span class="line">|  2 | asd  |</span><br><span class="line">|  3 | aaa  |</span><br><span class="line">+----+------+</span><br><span class="line">3 rows in set</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>好，我们读取到三条数据。此时打开另一个命令行添加一条数据进去。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into user values (4,&quot;aaa&quot;);</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | abc  |</span><br><span class="line">|  2 | asd  |</span><br><span class="line">|  3 | aaa  |</span><br><span class="line">|  4 | aaa  |</span><br><span class="line">+----+------+</span><br><span class="line">4 rows in set</span><br></pre></td></tr></table></figure><p>由于是自动提交，我没有开启新事务，这不要紧。接着我们返回事务A再次查询数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | abc  |</span><br><span class="line">|  2 | asd  |</span><br><span class="line">|  3 | aaa  |</span><br><span class="line">+----+------+</span><br><span class="line">3 rows in set</span><br></pre></td></tr></table></figure><p>发现依旧是三条数据。那么就很神奇了，mysql的RR级别似乎真的解决了幻读问题？？<br>那么我们就继续实验，我们知道目前数据库中存在四条数据，但是事务A读取的确实三条，那么此时我在事务A中修改新添加的数据行应该是失败的。那么我们就将事务A中的所有数据行修改下，看看它是否会影响到第四条数据。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update user set name = &quot;zer0e&quot;;</span><br><span class="line">Database changed</span><br><span class="line">Rows matched: 4  Changed: 4  Warnings: 0</span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">+----+-------+</span><br><span class="line">4 rows in set</span><br></pre></td></tr></table></figure>  <p>那么很明显，mysql直接提示有四条数据被修改，之后再读取就变成了四条数据，很显然幻读问题并没有真正解决。  </p><h4 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h4><p>那么到底为什么会出现上述情况？查阅资料后发现在RR级别下，通过MVCC协议，我们读取的数据变为可重复读，但是它可能是一个历史数据，那么我们称它为快照读，而读取到数据库最新数据的方式，我们称它为当前读。<br>select操作默认都是快照读，之后select都会返回这次快照读，因此实现了可重复读。<br>而对数据的更新操作(update,insert,delete)都是当前读，执行这几个操作会读取最新的记录，在事务中执行修改操作后会导致快照读变更。也就是我们所测试的那样。<br>如果我们要让select读取到当前读，我们可以手动进行加锁。<br>事务A先读取数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">+----+-------+</span><br><span class="line">4 rows in set</span><br></pre></td></tr></table></figure> <p>此时事务B新增一条记录(5,”aaa”)，这里我就不写了，我们来看看事务A再次读取的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">+----+-------+</span><br><span class="line">4 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user lock in share mode;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">|  5 | aaa   |</span><br><span class="line">+----+-------+</span><br><span class="line">5 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user for update;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">|  5 | aaa   |</span><br><span class="line">+----+-------+</span><br><span class="line">5 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">+----+-------+</span><br><span class="line">4 rows in set</span><br></pre></td></tr></table></figure>   <p>我们可以发现使用<code>for update</code>或者<code>lock in share mode</code>都可以获取到当前读。<br>所以综上，在RR级别下，幻读并未真正解决，而是因为快照读所以无法读取到最新数据。  </p><h3 id="解决幻读"><a href="#解决幻读" class="headerlink" title="解决幻读"></a>解决幻读</h3><p>那么在RR级别下innodb到底有没有解决幻读问题？通过什么解决？<br>答案是解决了，通过Next-Key锁来实现。</p><h4 id="Next-Key锁"><a href="#Next-Key锁" class="headerlink" title="Next-Key锁"></a>Next-Key锁</h4><p>Next-Key锁是行锁和间隙锁的合并，所谓间隙锁，就是在锁住当前行时，同时锁住当前索引的上下范围。<br>下面进行几项实验：  </p><h5 id="无主键表"><a href="#无主键表" class="headerlink" title="无主键表"></a>无主键表</h5><p>首先隔离级别定为RR，创建表t1，并插入几条间隔数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t1(id int,key id(id))engine=innodb;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1 values(1),(3),(5);</span><br><span class="line">Query OK, 3 rows affected</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  1 |</span><br><span class="line">|  3 |</span><br><span class="line">|  5 |</span><br><span class="line">+----+</span><br><span class="line">3 rows in set</span><br></pre></td></tr></table></figure>   <p>事务A通过for update锁住id=5的数据行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 where id=5 for update;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  5 |</span><br><span class="line">+----+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure>   <p>此时开启事务B，添加一个数据行在id=5前后。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t1 values(2);</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1 values(4);</span><br><span class="line">1049 - Unknown database &#x27;ate user set name = &quot;aaa&quot; where id = 5&#x27;</span><br><span class="line">terminated by user</span><br><span class="line">mysql&gt; use test;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; insert into t1 values(6);</span><br><span class="line"></span><br></pre></td></tr></table></figure> <p>我们会发现事务B会等待，直到事务A提交过后，事务B才插入成功。<br>那么Next-Key锁锁住的到底是多少行？其实它锁住的是它上下的一个范围。例如上述表中，对id=5的行进行加锁，那么innodb会把数据分为几个段，分别为(negative infinity,3]，(3,5]，(5,positive infinity]，都是左闭右开区间，那么对id=5的行添加行锁，同时会对(3,5]，(5,positive infinity]这两个区间添加gap锁(即间隙锁)，导致其他事务无法在这个区间进行更新操作。  </p><h5 id="有主键表"><a href="#有主键表" class="headerlink" title="有主键表"></a>有主键表</h5><p>上面的例子中没有主键，只是有一个普通索引而已。我们再来试一下有主键的例子。<br>创建表并插入几条数据：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t2(id int primary key)engine = innodb;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t2 values(1),(3),(5);</span><br><span class="line">Query OK, 3 rows affected</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure> <p>开启事务A并对id=5的行进行锁定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t2 where id = 5 for update;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  5 |</span><br><span class="line">+----+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure> <p>然后尝试在事务B中插入数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t2 values(4);</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t2 values(6);</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t2 where id = 5 for update;</span><br><span class="line">....</span><br></pre></td></tr></table></figure> <p>我们发现innodb并没有使用gap锁，而是只锁定了当前行。<br>那其实在innodb当中，<strong>行级锁是通过给索引上的索引项加锁来实现的，当查询的索引含有唯一属性时（主键索引，唯一索引），那么innodb会对next-key锁进行优化，使它降级为行级锁，锁住的不再是范围。</strong><br>所以如果把id不设置成主键，而是设置成唯一索引，也能达到相应的效果。  </p><h5 id="使用无索引字段"><a href="#使用无索引字段" class="headerlink" title="使用无索引字段"></a>使用无索引字段</h5><p>最后我们尝试下使用无索引字段来加锁会如何。<br>先创建表，并插入数据。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t3(id int,name varchar(10),key id(id))engine=innodb;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t3 values (1,&quot;a&quot;),(3,&quot;b&quot;),(5,&quot;c&quot;);</span><br><span class="line">Query OK, 3 rows affected</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure> <p>开启事务A对name=”c”的行加锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t3 where name = &quot;c&quot; for update;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  5 | c    |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set</span><br><span class="line"></span><br></pre></td></tr></table></figure> <p>在事务B中尝试加锁其他行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t3 where name = &quot;a&quot; for update;</span><br><span class="line">...</span><br><span class="line">mysql&gt; select * from t3 where name = &quot;b&quot; for update;</span><br><span class="line">...</span><br><span class="line">mysql&gt; insert into t3 values (4,&quot;d&quot;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure> <p>可以发现innodb其实对其他行都添加了锁，无法进行更新操作。那通过之前的结论，我们知道行级锁是通过索引加锁，条件中的列没有索引，因此innodb会给全表加上间隙锁。除非事务A提交，否则其他事务无法进行更新操作。  </p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>那之所以<a href="/2020/11/01/transaction_isolation/#innoDB%E4%B8%ADMVCC%E7%9A%84%E5%AE%9E%E7%8E%B0">前一个实验</a>“没有”解决幻读，原因在于快照读没有通过行级锁锁住当前行，表中也没有索引，条件语句中没有增加索引条件。我们可以通过添加索引并使用索引的当前读，来解决幻读问题。<br>所以在innodb当中，行级锁防止别的事务对当前行进行修改和删除，间隙锁防止其他事务新增数据，行级锁和间隙锁形成的next-key锁共同解决了RR级别下写的幻读问题。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那本篇的大致内容就写到这里了，本来只计划整理下基础知识，没想到越写越多，多整理了一个mysql中隔离级别的实现。这部分知识我之前是不太了解的，通过自己做下实验后，有种柳暗花明的感觉。也许这就是学习技术所带来的乐趣吧。  </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://dev.mysql.com/doc/">mysql参考手册</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对于数据库隔离级别，前前后后可能复习了好多遍，但是很经常就忘记，今天就简单整理下概念和实例，方便以后回顾。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://re0.top/tags/Java/"/>
    
      <category term="Mysql" scheme="https://re0.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>浅谈雪花算法</title>
    <link href="https://re0.top/2020/10/09/snowflake/"/>
    <id>https://re0.top/2020/10/09/snowflake/</id>
    <published>2020-10-09T06:40:00.000Z</published>
    <updated>2020-10-09T07:54:27.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近学习也有点陷入迷茫状态，不知道学些什么，也不知道写点什么。那就想起什么就写点啥，就当是重新学习。<br>今天要来讲的是分布式系统中常用的一种算法，雪花算法。 </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="什么是雪花算法"><a href="#什么是雪花算法" class="headerlink" title="什么是雪花算法"></a>什么是雪花算法</h2><p>雪花算法(snowflake)，它是Twitter公司使用的在分布式系统中生成唯一ID的一个算法，在2014年开源。<br>雪花算法是在高并发环境下生成为ID的算法，它能保证分布式环境下ID不重复，且基本有序递增，并且不依赖与其他的第三方库。  </p><h2 id="雪花算法的原理"><a href="#雪花算法的原理" class="headerlink" title="雪花算法的原理"></a>雪花算法的原理</h2><p>雪花算法的原理十分简单，它生成的ID由64bit组成，其中包括：</p><ul><li>1bit的标志位，由于二进制中最高为1的都是负数，并且生成的id一般都是整数，所以这一位通常为0.</li><li>41bit的时间戳，可以存储69年的时间，一般来说起始时间戳为系统上线的时间戳。</li><li>10bit的机器id，可以部署1024个节点。</li><li>12bit序列号，用来表示同一时间戳下生成的不同id，在同一个时间戳下可以表示4095个序列号。  </li></ul><p>因为刚好是64bit，所以在Java中刚好由long类型来存储。倒不如说是这个算法可能一开始就想好使用long类型来存储。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>当然最重要的还是如何生成ID啦，那生成的算法网上有很多，我就依照可能大家看的最多的代码，来讲讲自己的理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowFlake</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务上线时间 2020-10-09 00:00:00</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> startTimestamp = <span class="number">1602172800L</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 机器id所占位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">10L</span>;</span><br><span class="line">    <span class="comment">// 支持的最大机器id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = ~(-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    <span class="comment">//序列号占用的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line">    <span class="comment">//最大序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = ~(-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 机器ID向左移12位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line">    <span class="comment">// 时间截向左移22位(10+12)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//机器id，通过构造器传入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId;</span><br><span class="line">    <span class="comment">//序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">//上一次生成id的时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnowFlake</span><span class="params">(<span class="keyword">long</span> workerId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先机器id不能小于0或大于2^workerIdBits - 1</span></span><br><span class="line">        <span class="keyword">if</span> (workerId &lt; <span class="number">0</span> || workerId &gt; maxWorkerId)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;机器id不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法必须是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//如果当前时间小于上一次生成id的时间，说明系统时钟被回退过，需要抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;系统时间被回退&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前时间戳与上次生成id的时间戳相等，则增加序列</span></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp)&#123;</span><br><span class="line">            <span class="comment">// 这里是为了避免超出sequenceBits，即超出后会变成0</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="comment">//如果等于0说明溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 重新获取时间戳</span></span><br><span class="line">                timestamp = getNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不等于上次生成id的时间则序列号直接为0</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line">        <span class="comment">//通过位运算将三个部分进行拼接</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - startTimestamp) &lt;&lt; timestampLeftShift)</span><br><span class="line">                | (workerId &lt;&lt; workerIdShift)</span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞到下一个毫秒，直到获取新的时间戳</span></span><br><span class="line">    <span class="comment">// 由于获取下一个时间戳前进行了时钟回滚判断，所以这里不会长时间阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp)&#123;</span><br><span class="line">            timestamp = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>在代码中都有相应的注释。其中需要理解的可能是生成最大值的位运算，比如<code>maxWorkerId = ~(-1L &lt;&lt; workerIdBits);</code>。<br>首先负数在计算机中是使用补码进行表示，补码是负数绝对值的原码，取反码再加一。-1的绝对值是1，1的原码就是最后一位是1，取反码，就是0变1,1变0，再加1，就得到了全是1的二进制。<br>然后左移workerIdBits位，也就是12位，然后再取反，就得到了最大值，即1023。<br>那其实取最大值有两种写法，一种是<code>maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);</code>还有一种就是上面的写法，一种是异或一种是取反，得到的结果都是相同的。我个人也不确定哪种比较好，idea中提示我使用取反操作，那就当取反操作可能更好一些。当然这只是idea的建议，真正要区分的话还得看两种方法的底层速度比较，我对位运算不熟悉，希望有大佬能比较一下。  </p><h1 id="后续一些思考"><a href="#后续一些思考" class="headerlink" title="后续一些思考"></a>后续一些思考</h1><p>那雪花算法并不算难，通常情况下我们可以对雪花算法进行魔改。比如我可能不需要用到1024个节点啊，那么就把workIdBit减少，然后时间戳增加或者序列号增加。<br>又或者我这个系统可能用不到69年，那就可以适当减少时间戳比特位。<br>那还有就是workid的问题，即workid该怎么决定？那我们可以通过JVM传参，即-D选项，那如果是通过容器化部署的话，可能没办法传入不同参数，那可以通过某些规则来计算workid，比如可以通过该台机器的ip地址或者mac地址来计算workid，但是需要保证workid不重复，否则即使在并发不高的情况下，id也可能重复，至于实现，这里便不再展开，感兴趣的可以自己写写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近学习也有点陷入迷茫状态，不知道学些什么，也不知道写点什么。那就想起什么就写点啥，就当是重新学习。&lt;br&gt;今天要来讲的是分
      
    
    </summary>
    
    
      <category term="Java" scheme="https://re0.top/tags/Java/"/>
    
      <category term="算法" scheme="https://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="分布式" scheme="https://re0.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>谈谈设计模式</title>
    <link href="https://re0.top/2020/09/17/design_patterns/"/>
    <id>https://re0.top/2020/09/17/design_patterns/</id>
    <published>2020-09-17T08:40:00.000Z</published>
    <updated>2020-09-17T08:35:45.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设计模式是提高代码可读性的途径之一，面对不同的场景选择不同的设计模式，可以提高代码可读性，提高代码的可重用性还有可扩展性。接下来就讲讲什么是设计模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="何为设计模式"><a href="#何为设计模式" class="headerlink" title="何为设计模式"></a>何为设计模式</h2><p>设计模式是在面向对象语言中，思想都是一致的，而在面向过程语言，函数式编程的语言中讨论设计模式是没有意义的。所谓的设计模式，就是前面提到的，在面向对象编程中的一些”套路”，在面对不同需求场景时，可以选择不同的设计模式，来提高代码的可读性，重用性与扩展性。   </p><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>在GoF设计模式书籍中，共有23种设计模式。<br>而这23种设计模式又可以分为三大类型:  </p><ul><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>这一类设计模式的目的是为了创建对象。其中包括：  </p><ol><li><a href="/2020/08/13/abstract_factory_pattern/">抽象工厂模式</a></li><li><a href="/2020/08/12/factory_pattern/">工厂方法模式</a></li><li><a href="/2020/08/07/singleton/">单例模式</a></li><li><a href="/2020/09/02/prototype_pattern/">原型模式</a></li><li><a href="/2020/09/14/builder_pattern/">构建模式</a></li></ol><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>这一类设计模式是为了优化不同类，对象，接口之间的结构关系。其中包括：  </p><ol><li><a href="/2020/08/10/proxy_pattern/">代理模式</a></li><li><a href="/2020/08/17/decorator_pattern/">装饰器模式</a></li><li><a href="/2020/09/17/composite_pattern/">组合模式</a></li><li><a href="/2020/09/04/bridge_patterns/">桥接模式</a></li><li><a href="/2020/08/22/adapter_pattern">适配器模式</a></li><li><a href="/2020/08/16/facade_pattern/">外观模式</a></li><li><a href="/2020/09/17/flyweight_pattern/">享元模式</a></li></ol><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>这一类设计模式的目的是更好地实现类与类之间的交互还有算法的执行。包括：  </p><ol><li><a href="/2020/08/27/strategy_pattern/">策略模式</a></li><li><a href="/2020/08/17/command_pattern/">命令模式</a></li><li><a href="/2020/09/06/state_pattern/">状态模式</a></li><li><a href="/2020/09/05/chain_of_responsibility_pattern/">责任链模式</a></li><li><a href="/2020/09/05/interpreter_pattern">解释器模式</a></li><li><a href="/2020/08/08/observer/">观察者模式</a></li><li><a href="/2020/09/06/memento_pattern">备忘录模式</a></li><li><a href="/2020/08/27/iterator_pattern/">迭代器模式</a></li><li><a href="/2020/09/08/template_method_pattern/">模板方法模式</a></li><li><a href="/2020/09/08/visitor_pattern/">访问者模式</a></li><li><a href="/2020/08/12/mediator_pattern/">中介者模式</a></li></ol><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>以上就是全部设计的种类。因为随着不断进步，设计模式远不止这一些，但掌握这些设计模式在日常编程中就可以有效保证代码的健康。<br>算是挖了一个新的大坑吧，之后会陆陆续续写写这23种设计模式的理解与实现。<br>2020.08.07 单例模式<br>2020.08.08 观察者模式<br>2020.08.10 代理模式<br>2020.08.12 工厂方法模式,中介者模式<br>2020.08.13 抽象工厂模式<br>2020.08.16 外观模式<br>2020.08.17 命令模式,装饰器模式<br>2020.08.22 适配器模式<br>2020.08.27 策略模式,迭代器模式<br>2020.09.02 原型模式<br>2020.09.04 桥接模式<br>2020.09.05 责任链模式,解释器模式<br>2020.09.06 状态模式,备忘录模式<br>2020.09.08 模板方法模式,访问者模式<br>2020.09.14 构建模式<br>2020.09.17 享元模式,组合模式  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;设计模式是提高代码可读性的途径之一，面对不同的场景选择不同的设计模式，可以提高代码可读性，提高代码的可重用性还有可扩展性。接下来就讲讲什么是
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之组合模式</title>
    <link href="https://re0.top/2020/09/17/composite_pattern/"/>
    <id>https://re0.top/2020/09/17/composite_pattern/</id>
    <published>2020-09-17T08:00:00.000Z</published>
    <updated>2020-09-17T08:34:07.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇是23种设计模式的最后一篇了，不知不觉整理了一个月，其实应该快点整理完，每天一到两篇文章虽然量不多，但是写的时候其实挺累人。言归正传，本文来讲最后一种设计模式，组合模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>组合模式又称部分整体模式，它属于结构型模式，通常适用于有结构的系统，用于表示部分与整体层次。顺带一提，这里的有结构一般是树形结构。<br>那这个模式他模糊了简单元素与复杂元素的概念，可以统一使用同一个对象来进行操作。<br>那常见的场景有，上下级关系的构建，或者是文件系统的构建。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>那我们就来简单实现一个文件系统，我们知道一般文件系统包括普通文件和文件夹，但是学过操作系统后我们知道，文件夹其实是一种特殊的文件，在标志处不一样而已。那我们就来实现这个系统。<br>首先我们创建抽象类File</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>这里的display方法如果是文件夹是显示它所有文件，如果是文件则打印文件名。<br>接着我们创建Folder。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Folder</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;File&gt; fileList;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Folder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        fileList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (File file : fileList)&#123;</span><br><span class="line">            file.display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        fileList.add(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        fileList.remove(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>接着我们创建两种类型的文件，文本文件和图片文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFile</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文本文件，文件名为：&quot;</span> + <span class="keyword">super</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageFile</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;图片文件，文件名为：&quot;</span> + <span class="keyword">super</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>最后我们创建客户端调用试试，我们创建一个这样的文件系统，有一个文件夹all，包含1.txt，1.jpg，还有一个文件夹1；然后文件夹1中还有2.txt和2.jpg。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Folder all = <span class="keyword">new</span> Folder(<span class="string">&quot;all&quot;</span>);</span><br><span class="line">        File txt1 = <span class="keyword">new</span> TextFile(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        File txt2 = <span class="keyword">new</span> TextFile(<span class="string">&quot;2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        File jpg1 = <span class="keyword">new</span> ImageFile(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">        File jpg2 = <span class="keyword">new</span> ImageFile(<span class="string">&quot;2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Folder folder1 = <span class="keyword">new</span> Folder(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        all.add(txt1);</span><br><span class="line">        all.add(jpg1);</span><br><span class="line">        all.add(folder1);</span><br><span class="line"></span><br><span class="line">        folder1.add(txt2);</span><br><span class="line">        folder1.add(jpg2);</span><br><span class="line"></span><br><span class="line">        all.display();</span><br><span class="line">        folder1.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <p>那这里就有个问题，就是总文件夹中打印文件名时，会把子文件夹中的一并打印出来，那么这时候我们可以在抽象类中设置一个type属性，依照参数，比如-r表示是否递归，来判断是否递归打印。通过判断type来实现，这里就不实现了，感兴趣的可以自行实现。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>那组合模式的优点是可以定义一些分层次的对象，添加组件也很简单。其次就是客户端调用简单。最后就是符合开闭原则，添加新的组件不用修改原有代码。<br>那缺点在于整个系统会变得抽象，维护成本增加，其次就是违反依赖导致原则，就像上文的例子一样，客户端要创建文件夹时，需要依赖的是Folder实现类，而不是File抽象类。  </p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>那设计模式这个系列到这里基本上是告一段落了，前前后后整理这个系列花了一个多月的时间，那接下来可能还是会写一些自己感兴趣的话题或者技术，有时间的话博客还是会坚持写下去的。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这篇是23种设计模式的最后一篇了，不知不觉整理了一个月，其实应该快点整理完，每天一到两篇文章虽然量不多，但是写的时候其实挺累人。言归正传，本
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之享元模式</title>
    <link href="https://re0.top/2020/09/17/flyweight_pattern/"/>
    <id>https://re0.top/2020/09/17/flyweight_pattern/</id>
    <published>2020-09-17T07:00:00.000Z</published>
    <updated>2020-09-17T07:42:35.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文谈谈享元模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>享元模式属于结构型模式，它主要是缓存重复的对象，以减少内存的消耗，这些相同的对象往往需要重复的使用，如果不对其进行缓存，可能会导致内存溢出。那享元模式一般配合工厂模式一起使用。<br>常见的应用场景有Java中的String，在创建String时判断缓存池里是否有这个字符串，有的话直接返回，没有才进行创建。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>享元模式中有以下几个角色：</p><ul><li>抽象享元类（Flyweight）：接口或者抽象类，声明公共方法。</li><li>具体享元类（ConcreteFlyweight）：实现抽象享元类，结合单例模式提供唯一的对象。 </li><li>享元工厂类（FlyweightFactory）：用来创建及管理享元对象，可以参考工厂模式。  </li></ul><p>这里我们举个简单例子，一般商店里的物品不止一样，那么我们可以把同一个名称的商品作为共享的。<br>我们创建抽象接口FlyWeight</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyWeight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>接着我们可以创建商品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">implements</span> <span class="title">FlyWeight</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;卖出一件商品: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>创建工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWeightFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Item&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getItem</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        Item item = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(name))&#123;</span><br><span class="line">            item = map.get(name);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            item = <span class="keyword">new</span> Item(name);</span><br><span class="line">            map.put(name,item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>那么客户端调用也很简单，商品从工厂类中获取即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FlyWeightFactory flyWeightFactory = <span class="keyword">new</span> FlyWeightFactory();</span><br><span class="line">        Item milk1 = flyWeightFactory.getItem(<span class="string">&quot;牛奶&quot;</span>);</span><br><span class="line">        Item milk2 = flyWeightFactory.getItem(<span class="string">&quot;牛奶&quot;</span>);</span><br><span class="line">        System.out.println(milk1 == milk2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        milk1.sell();</span><br><span class="line">        milk2.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>那以上例子还可以继续细化，比如Item类作为抽象类，而具体商品则继承它，那具体商品就可以有更多的属性，比如价格，批次等等。那在工厂类添加的时候可能需要根据传入名称来创建类，具体可以使用反射机制，这里就不再展开。<br>总而言之，享元模式中共享的对象是同一个，实现这个模式常常结合工厂模式，单例模式来使用，需要注意的是在多线程中需要使用线程安全的容器来存储对象。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>享元模式优点很明显，可以减少重复对象的创建，减低内存使用率。<br>那缺点可能就是需要区分外部状态与内部状态，内部状态不随环境改变，可共享，外部状态岁环境改变，不能共享。也就是上文例子中name作为外部状态可改变，如果再添加一个无法更改的属性比如价格，那么就是内部状态，无法被更改。<br>所以享元模式一定程度上增加了系统的复杂性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文谈谈享元模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之构建模式</title>
    <link href="https://re0.top/2020/09/14/builder_pattern/"/>
    <id>https://re0.top/2020/09/14/builder_pattern/</id>
    <published>2020-09-14T07:00:00.000Z</published>
    <updated>2020-09-14T08:29:53.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>构建模式又称建造模式，建造者模式等等。<br>本篇来简单谈谈这种设计模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>构建模式(Builder Pattern)，由于存在多种叫法，为了统一名称，统一写作Builder模式。它属于创建型模式，是使用一个个对象构建复杂对象的设计模式。<br>它的意图在于拆分复杂对象，使得可以由子对象生成，子对象相对稳定，通过组合子对象来构造复杂对象。<br>那使用的场景通常是对象的内部结构较为复杂或者内部属性相互依赖。<br>那Java中常见的就是各种Builder，例如StringBuilder。<br>那项目中何时使用这种设计模式呢？通常来说，当类的构造函数非常多时(大于4个)可以改用Builder模式来创建对象。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>先来讲讲Builder模式中的几个角色：</p><ul><li>Builder角色：一个接口，规范产品对象中各个子对象的构建。</li><li>ConcreteBuilder：具体的实现类，提供产品的实例。</li><li>Director：负责调用具体的ConcreteBuilder来创建对象。</li><li>Product：即我们需要构建的复杂对象。  </li></ul><p>我们就用这几个角色来写写基础的Builder模式。<br>首先我们定义我们的Product对象中，有两个string担任它的子对象。那我们可以写出代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>首先这个类并没有构造器，而是采用javabean的方式来设置对象，这有利于我们使用builder来创建这个对象。<br>接着我们写抽象的Builder接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildId</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>这个接口中有两个方法用来创建product对象中的子对象。而第三个方法则是来获取一个创建完成的product对象。<br>接着是ConcreteBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setId(<span class="string">&quot;01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setName(<span class="string">&quot;产品1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>接着是导演类，用来引导ConcreteBuilder创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        builder.buildId();</span><br><span class="line">        builder.buildName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>我们通过把builder传递给导演类，然后调用导演类的construct方法，就可以创建一个product对象到builder对象中，获取就可以得到这个product对象。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        director.construct();</span><br><span class="line">        Product product = builder.getProduct();</span><br><span class="line"></span><br><span class="line">        System.out.println(product.getId());</span><br><span class="line">        System.out.println(product.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>如此我们便简单实现了Builder模式。<br>那实际场景中哪里使用到了Builder模式呢？<br>MyBatis中就大量使用了这个模式。原生的mybatis(不整合spring)在SqlSessionFactory中使用了XMLConfigBuilder，得益于builder模式，mybatis隐藏了解析XML文件的细节，我们只需要少量的基本参数(比如地址，账号密码等)，就可以使用。其他参数根据用户是否提供，如果没有就使用默认参数。因此mybatis使用成本大大降低。</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>所以当我们在编写复杂类，或者是一个大型框架时，可以采用Builder模式，将大量参数通过这个模式来创建对象，而不是使用构造函数来创建。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>那Builder模式的优点在于可以精确控制产品的创建，开发者可以根据需要创建出想要的对象。其次，客户端可以不知道产品内部实现细节，结果与过程解耦。最后添加新的Builder无需修改原有代码，Director是针对Builder进行编程的，所以方便系统扩展，符合开闭原则。<br>那缺点就是产品之间需要有共同点，有所限制。其次就是如果内部复杂，会导致Builder过多，系统臃肿。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;构建模式又称建造模式，建造者模式等等。&lt;br&gt;本篇来简单谈谈这种设计模式。  &lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; 
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList扩容之后内存地址会发生改变吗？</title>
    <link href="https://re0.top/2020/09/13/arraylist_resize/"/>
    <id>https://re0.top/2020/09/13/arraylist_resize/</id>
    <published>2020-09-13T06:20:00.000Z</published>
    <updated>2020-09-13T08:01:20.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>那标题的这个内容，是我在面试时候的一道问题。那这篇文章我们来讲讲ArrayList的扩充机制以及扩容之后会发生什么样的改变。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>首先使用过Java的基本上都用过ArrayList，那它是一个数组队列，其实现了List接口，那ArrayList的底层是一个动态数组。我们来看看默认的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>这里的源码基于JDK1.8，那其他的源码这里就不贴了，我直接进行总结：</p><ul><li>ArrayList内部有一个数组，使用默认的构造函数时，默认容量为0。而在1.6以前，默认容量为10.</li><li>当第一次插入元素时，容量分配10，之后会以1.5倍的增长。</li></ul><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>还是简单写写ArrayList的扩容机制。首先默认的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>我们可以知道默认的容量是0。那扩容机制一定会发生在add操作中，我们查看add方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>ensureCapacityInternal是确保内部容量，也就是确保数组容量应该是现有数据数量加上1。接着跟进</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>那这里就很明朗，calculateCapacity通过传入的需要容量与当前数组容量，计算出需要的最小容量，其中如果数组为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，那么就返回DEFAULT_CAPACITY与需要容量的最大值，DEFAULT_CAPACITY为10。<br>因此当第一次扩容时，容量被设置为10，其余情况最小容量都为传入的所需容量。<br>接着是ensureExplicitCapacity方法，当最小容量大于当前数组长度时，进行扩容操作，即grow方法，我们接着跟进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>首先新容量的计算方式为oldCapacity + (oldCapacity &gt;&gt; 1)，那么相当于oldCapacity + 0.5 * oldCapacity，即1.5倍的原容量，而采用位运算则更快。其次这里判断了元素的最大个数，源码里的注释解释道，原因是因为jvm允许数组的最大大小为Integer.MAX_VALUE - 8，超过这个值会OutOfMemory，因此MAX_ARRAY_SIZE设置为Integer.MAX_VALUE - 8避免溢出。<br>最后是调用Arrays.copyOf方法来获得一个新的数组，而copyOf方法是调用System.arraycopy方法，这个方法是个native方法，就不是我们所关心的内容了。<br>至此，扩容的机制就是如果是默认构造器初始化，则设置当前容量为10，当所需容量大于10时，会进行1.5倍的扩容，以此类推。</p><h2 id="ArrayList对象分配在哪"><a href="#ArrayList对象分配在哪" class="headerlink" title="ArrayList对象分配在哪?"></a>ArrayList对象分配在哪?</h2><p>首先ArrayList是new出来的，那么毫无疑问，它存放在堆中，而变量存放在栈中，指向堆中的对象。就比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure> <p>其中list变量在栈中，指向堆中的某个ArrayList实例对象。<br>那数组也不例外，因为数组也是个对象，所以内部的elementData也存放在堆当中。  </p><h2 id="那扩容之后的地址改变吗"><a href="#那扩容之后的地址改变吗" class="headerlink" title="那扩容之后的地址改变吗?"></a>那扩容之后的地址改变吗?</h2><p>这就是标题所提到的问题，先说结论，肯定是不变的。我们先来做个试验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>通过对add下断点，我们可以发现list的id是不变的，因此内存当中的地址是不改变的。通过步入调试，可以发现elementData的id发生了改变，因为我们可以得出结论，ArrayList扩容之后地址不会发生改变，发生改变的是内部数组的内存地址。<br>那为什么不变呢？根本原因在于list变量所指向的对象是同一个，很好理解，尽管实例内部的elementData一直在改变，但实例中只是某个变量的指向不断在改变而已，并没有重新分配内存，只有当内部方法重新new本类时，list所指向的内存地址才会发生改变。<br>因此，<strong>大部分通过内部变量引用机制进行扩容的容器并不会改变自身的内存地址</strong>。<br>但一些基础容器，例如数组，通过Arrays.copyOf方法进行扩容时，因为数组内存是有序的，所以需要重新分配内存，导致地址发生改变。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇谈了谈ArrayList的扩容机制以及扩容之后地址的改变情况。那相似的问题，比如hashmap扩容等等我们都知道了，因为其内部有引用，所以只是内部变量的地址发生改变，其本身的内存地址不发生改变，对象还是同一个。<br>那以上就是这篇文章的内容，如有问题，望指出。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;那标题的这个内容，是我在面试时候的一道问题。那这篇文章我们来讲讲ArrayList的扩充机制以及扩容之后会发生什么样的改变。&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://re0.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java内存模型</title>
    <link href="https://re0.top/2020/09/13/jmm/"/>
    <id>https://re0.top/2020/09/13/jmm/</id>
    <published>2020-09-13T05:00:00.000Z</published>
    <updated>2020-09-13T06:25:32.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想写一篇文章，由于涉及到Java内存的知识，就先来写写前置知识。那本篇就来说说JVM的基础，Java内存区域与Java内存模式（JMM）。<br>ps. 本篇基本上想到哪里说到哪里，并无什么先后顺序。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p>那我相信学习过JVM的同学基本上都知道JVM将运行时内存划分为几个区域。总体上可以分为两类：线程共享区域与线程私有区域。<br>其中线程共享区域分为方法区和堆。线程私有区域有虚拟机栈，本地方法栈还有程序计数器。</p><h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>方法区中主要用于存储已经被虚拟机加载的类信息，常量还有一些静态变量。注意，方法区中有一个运行时常量池，用于存储编译器生成的各种字面量与符号引用，加载过后存放在此。</p><h3 id="堆（Java-Heap）"><a href="#堆（Java-Heap）" class="headerlink" title="堆（Java Heap）"></a>堆（Java Heap）</h3><p>这个区域是我们常见的区域，主要是存放对象实例，几乎所有的对象实例都在这里分配内存，也是GC的主要区域。</p><h3 id="虚拟机栈（JVM-Stacks）"><a href="#虚拟机栈（JVM-Stacks）" class="headerlink" title="虚拟机栈（JVM Stacks）"></a>虚拟机栈（JVM Stacks）</h3><p>是线程私有的区域，与线程同时创建，每一个方法执行的时候都会创建一个叫做栈帧的东西来存储方法的变量表，动态链接方法，返回值等等信息，并存放在栈中，调用方法就是入栈，而调用结束就是出栈操作。 </p><h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><p>在操作系统中我们也学习过这个概念。主要是代表当前线程所执行的字节码行号的指示器。运行代码时，通过改变计数器的值来选取下一条需要执行的字节码指令。</p><h3 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h3><p>主要是用到的Native方法相关的信息，一般来说无需关心。</p><h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p>那由于JVM运行程序是以线程为单位，所以每个线程创建的时候JVM会为其创建一个工作内存，用于存储变量私有的数据，而JMM规定所有变量都存储在主内存，主内存是共享的，所有线程都能访问，因此对变量的操作是这样的，首先从主内存中拷贝变量到工作内存中，修改变量完成后再写回主内存中。所以线程共享的变量必须通过主内存来完成。  </p><h2 id="Java内存区域与JMM"><a href="#Java内存区域与JMM" class="headerlink" title="Java内存区域与JMM"></a>Java内存区域与JMM</h2><p>这两个是不同的概念，JMM是一组规则，控制程序中各个变量在共享区域与私有区域的访问方式。他们的相似点在于都存在共享区域与私有区域，JMM中主内存属于共享区域，从内存模型来讲应该包括了方法区与堆，私有区域同理。</p><h2 id="JMM如何保证原子性，可见性，有序性"><a href="#JMM如何保证原子性，可见性，有序性" class="headerlink" title="JMM如何保证原子性，可见性，有序性"></a>JMM如何保证原子性，可见性，有序性</h2><p>那在Java当中我们要保证原子性可以使用锁来实现，工作内存与主内存的可见性可以使用synchronized关键字或者volatile关键字，而因为指令重排导致的有序性问题可以使用volatile关键字。<br>那仅靠synchronized和volatile关键字会使得代码变得十分繁琐。因此JMM还提供一个叫做happens-before的原则来保证三性。规则的内容如下：</p><ul><li>程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</li><li>锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。</li><li>volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</li><li>线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见</li><li>传递性 A先于B ，B先于C 那么A必然先于C</li><li>线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</li><li>线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</li><li>对象终结规则 对象的构造函数执行，结束先于finalize()方法</li></ul><p>以上八条原则使得某些情况下需要任何同步就可达到预期效果。</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>被volatile所修饰的变量对所有线程都是可见的，即对该变量的写操作都能立即反应到其他工作内存中。但这个关键字并不保证操作的原子性。因为对变量的修改往往需要两个步骤，读与更新，如果不能保证这个两个操作是同时进行，那么线程就是不安全的。<br>那volatile关键字的工作原理又是什么？其实就是线程在写一个volatile变量时，会把线程所对应的工作内存设置为无效的，那该线程只能从主内存中重新读取变量。其次就是禁止指令重排，之前在写单例模式的时候也提到过，对实例的赋值其实并不是我们预想的那样，例如<code>instance = new A();</code>，我们期待是先分配内存，然后初始化对象，最后进行赋值，那JVM可能会将该代码指令进行重排序，即先分配空间，然后赋值，最后再初始化对象。<br>那在单线程中是完全ok的，没什么影响，那在多线程中就可能出现一致性问题，也就是出现了线程安全问题。那禁止指令的重排，我们就可以使用volatile关键字来解决。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇主要是简单讲讲Java的内存区域与内存模型(JMM)，其中我们需要知道JMM其实就是一组规则，意图是解决并发编程中出现的线程安全问题，它提供了happen-before原则，并且我们还可以使用synchronized或volatile，来帮助我们实现多线程环境下的原子性，可见性，有序性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;想写一篇文章，由于涉及到Java内存的知识，就先来写写前置知识。那本篇就来说说JVM的基础，Java内存区域与Java内存模式（JMM）。&lt;
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="https://re0.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之访问者模式</title>
    <link href="https://re0.top/2020/09/08/visitor_pattern/"/>
    <id>https://re0.top/2020/09/08/visitor_pattern/</id>
    <published>2020-09-08T07:00:00.000Z</published>
    <updated>2020-09-08T08:02:10.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇来讲讲行为型模式的最后一篇，访问者模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>访问者模式，我们使用一个访问者类来访问数据对象，通常是为了不污染数据对象类，而实现的关键是在数据对象类中提供一个接待访问者的接口。<br>那这种设计模式了除了不污染原类，很大一部分原因是为了将数据结构与操作相分离。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>由于这种设计模式在开发中很少用，一般是在框架或者源码中才会使用到。所以这里我就简单实现一下概念。<br>首先访问者模式中有几个角色：</p><ul><li>Visitor（抽象访问者）：抽象类或接口，对每一种具体元素类ConcreteElement声明一个操作方法，由具体访问者去实现。  </li><li>ConcreteVisitor（具体访问者）：实现抽象访问者的方法。</li><li>Element（抽象元素）：一般会定义一个Accept方法，接受一个visitor对象作为参数。</li><li>ConcreteElement（具体元素）：具体实现抽象元素。</li><li>ObjectStructure（对象结构）：可以是任意一种数据结构，能枚举它包含的元素，并提供一个接口，允许visitor进行访问。  </li></ul><p>下面我将简单写写代码实现。<br>首先我们先定义抽象访问者吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>然后是具体访问者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorA</span> <span class="keyword">implements</span> <span class="title">Visitor</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问 ElementA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问 ElementB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>接着定义抽象元素，有一个accept方法接收一个visitor对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>然后是具体元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>我们定义一个对象结构来存放所有的元素，并且定义accept方法来逐个访问元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Element element: elements)&#123;</span><br><span class="line">            element.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(Element element)</span></span>&#123;</span><br><span class="line">        elements.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(Element element)</span></span>&#123;</span><br><span class="line">        elements.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>我们编写客户端调用试试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义元素及访问者</span></span><br><span class="line">        Element elementA = <span class="keyword">new</span> ConcreteElementA();</span><br><span class="line">        Element elementB = <span class="keyword">new</span> ConcreteElementB();</span><br><span class="line">        Visitor visitor = <span class="keyword">new</span> ConcreteVisitorA();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单个元素访问</span></span><br><span class="line">        elementA.accept(visitor);</span><br><span class="line">        elementB.accept(visitor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多个元素访问</span></span><br><span class="line">        ObjectStructure objectStructure = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line">        objectStructure.addElement(elementA);</span><br><span class="line">        objectStructure.addElement(elementB);</span><br><span class="line">        objectStructure.accept(visitor);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>那所以是否定义ObjectStructure取决于你是否需要同时访问多个元素。<br>书写代码之后，我第一感觉就是耦合较高，访问者与元素之间相互依赖极高。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>访问者模式的优点在于添加新的访问操作较为方便，无需修改元素类，修改抽象访问者及其具体访问者即可，并且类的职责更加清晰，元素类负责数据，而访问者负责访问，符合单一职责原则。<br>而缺点就是添加元素类就十分麻烦，添加一个元素类后，需要修改每个访问者的代码，违背了开闭原则。并且在依赖上，具体访问者依赖于具体元素类，没有依赖抽象对象。最后，为了供访问者访问，有时候元素类不得不暴露己类的某些细节，封装性被破坏。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇来讲讲行为型模式的最后一篇，访问者模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之模板方法模式</title>
    <link href="https://re0.top/2020/09/08/template_method_pattern/"/>
    <id>https://re0.top/2020/09/08/template_method_pattern/</id>
    <published>2020-09-08T06:00:00.000Z</published>
    <updated>2020-09-08T08:03:08.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇聊聊模板方法模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>模板方法模式属于行为型模式，它定义一个模板结构，然后让其子类去实现。其主要作用是提高代码的复用性，并且在不改变模板的情况下子类能重写方法。<br>那这种设计模式就十分常见了，在父类中定义执行顺序，子类再去具体的去实现，这就是模板方法模式。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>举个例子，比如我们平常去超市买东西，基本上分为几个步骤，拿购物车或篮子，挑选商品，结算。那就用这个例子来写写代码。  </p><h2 id="未使用模板方法模式"><a href="#未使用模板方法模式" class="headerlink" title="未使用模板方法模式"></a>未使用模板方法模式</h2><p>首先我们一般来说我们是先定义一个父类，然后子类再去实现父类方法。也就是<strong>没使用模板方法模式</strong>时，我们可能会这么写：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿购物车</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getShoppingCart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挑选商品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">selectGoods</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全流程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>那在子类当中，我们可能这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingByOnlinePay</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getShoppingCart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取购物车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectGoods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;挑选商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用网上支付&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getShoppingCart();</span><br><span class="line">        selectGoods();</span><br><span class="line">        pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>那这样写就是在抽象类中不写任何逻辑，所有的实现都在子类中实现，如果后续有问题也较好发现，但我们可以发现，其实shopping方法是固定的，也就是流程固定，那么我们这些代码是不是可以移动到抽象类中呢？是的，可以，这就是模板方法模式。</p><h2 id="使用模板方法"><a href="#使用模板方法" class="headerlink" title="使用模板方法"></a>使用模板方法</h2><p>我们重写下抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿购物车</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getShoppingCart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挑选商品</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">selectGoods</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结算</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全流程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getShoppingCart();</span><br><span class="line">        <span class="keyword">this</span>.selectGoods();</span><br><span class="line">        <span class="keyword">this</span>.pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>我们将子类需要重写的方法定义为protected，因为这些方法不需要暴露给其他类，只需要子类自己实现即可，然后我们把购物流程在抽象类中以final修饰，因为流程固定不需要修改。<br>我们接着写现金付款和网上支付两种结算方式的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingByOnlinePay</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">getShoppingCart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取购物车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">selectGoods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;挑选商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用网上支付&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingByCash</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">getShoppingCart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取购物车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">selectGoods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;挑选商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用现金结算&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>那这里调用就很简单，我就不写了，直接调用shopping方法即可。<br>如此，我们就使用模板方法模式实现了这个简单的例子。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>模板方法模式具有良好的封装性，即把一成不变的代码封装在父类当中，而子类去实现基本方法的逻辑，并且扩展性良好，符合开闭原则和单一职责原则。那最重要的还是复用了重复代码。<br>那缺点嘛，可能就是实现类都需要单独的子类去实现，可能会增加类的数量，但我个人认为这个其实严格来说不能说是缺点，除非是实现的种类存在几十种上百种。当然，仁者见仁智者见智，算不算缺点只有在用到的时候才能知道。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇聊聊模板方法模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之备忘录模式</title>
    <link href="https://re0.top/2020/09/06/memento_pattern/"/>
    <id>https://re0.top/2020/09/06/memento_pattern/</id>
    <published>2020-09-06T07:00:00.000Z</published>
    <updated>2020-09-06T07:58:33.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇来谈谈备忘录模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>备忘录模式保存对象的某个状态，以便当需要时恢复这个状态，它属于行为型模式。<br>它又称快照模式或token模式。它的意图是在不破坏封装的条件下，将对象的状态保存下来，并存储，并且可以在未来的某个时刻恢复。<br>这个模式涉及三个角色：</p><ul><li>备忘录(Memento)：将发起人对象的内部状态存储起来，并且可以保护不被发起人以外的对象所读取。</li><li>发起人(Originator)：创建一个含有内部状态的备忘录对象，并存储自己的内部状态。</li><li>负责人(Caretaker)：负责保存备忘录对象，不检查备忘录对象的内容。 </li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们先创建备忘录(Memento)，这里对象的内部状态我们使用string来表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>创建发起人(Originator)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">savaStateToMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>创建负责人(Caretaker)，负责保存备忘录对象，这里用list存储一系列状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">retrieveMemento</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveMemento</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        mementoList.add(memento);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>创建客户端，并设置一下状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">        Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line"></span><br><span class="line">        originator.setState(<span class="string">&quot;state 1&quot;</span>);</span><br><span class="line">        caretaker.saveMemento(originator.savaStateToMemento());</span><br><span class="line"></span><br><span class="line">        originator.setState(<span class="string">&quot;state 2&quot;</span>);</span><br><span class="line">        caretaker.saveMemento(originator.savaStateToMemento());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        originator.getStateFromMemento(caretaker.retrieveMemento(<span class="number">0</span>));</span><br><span class="line">        System.out.println(originator.getState());</span><br><span class="line"></span><br><span class="line">        originator.getStateFromMemento(caretaker.retrieveMemento(<span class="number">1</span>));</span><br><span class="line">        System.out.println(originator.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>这里我们设置两个状态，并拍摄快照，最后依次恢复快照查看状态。  </p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>上文也提过，这个模式适合拍摄快照，例如游戏存档，可以将玩家的某个状态存储，并适时的时候恢复。还有就是提供可回滚的操作，等等。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>那备忘录模式的优点是给用户提供了一种可恢复的机制，可以较为方便地回到某个时间点。其次就是调用者无需关心如何保存状态。<br>那缺点也很明显，就是占用内存或空间，如果类的状态和变量过多，则会消耗一定的资源。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇来谈谈备忘录模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之状态模式</title>
    <link href="https://re0.top/2020/09/06/state_pattern/"/>
    <id>https://re0.top/2020/09/06/state_pattern/</id>
    <published>2020-09-06T07:00:00.000Z</published>
    <updated>2020-09-06T07:32:06.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇来谈谈状态模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>状态模式属于行为型模式，在这个模式中类的行为是根据类的状态发生改变的。在类中维护一个状态变量，当其改变时类的行为就发生改变，看上去就跟改变了类本身一样。<br>那状态模式涉及的角色有：  </p><ul><li>环境(context)：上下文，通常定义客户端可用的接口，内部维护一个状态实例，根据这个状态做出不一样的行为。</li><li>抽象状态(state)：一个接口，用于封装环境(context)对象的状态</li><li>具体状态(concreteState)：实现抽象状态。</li></ul><p>那这个模式常见的场景就是可以替代条件语句，if，switch等等，避免语句过长。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这个模式还是比较简单的，我们就写写上面提到的几个角色<br>我们先定义state接口：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>然后是具体的state</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateA</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对应StateA的操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateB</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对应StateB的操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>然后定义环境，用于客户端的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用户需要的接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state.handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>最后编写客户端调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        State stateA = <span class="keyword">new</span> ConcreteStateA();</span><br><span class="line">        State stateB = <span class="keyword">new</span> ConcreteStateB();</span><br><span class="line"></span><br><span class="line">        context.setState(stateA);</span><br><span class="line">        context.request();</span><br><span class="line"></span><br><span class="line">        context.setState(stateB);</span><br><span class="line">        context.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>可以发现，通过设置context的状态可以实现不同的操作。看上去就像context对象本身发生改变一样。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>最后来讲讲优缺点。<br>状态模式的优点有，把实现的细节隐藏，客户端只需要设置状态，无需关心内部的实现，并且可以去除大量的逻辑判断语句，可读性更高。<br>而缺点在于当状态增多时，类的数量会增加，并且当增加新的状态类时，context可能会做出修改，不符合开闭原则。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇来谈谈状态模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之解释器模式</title>
    <link href="https://re0.top/2020/09/05/interpreter_pattern/"/>
    <id>https://re0.top/2020/09/05/interpreter_pattern/</id>
    <published>2020-09-05T08:00:00.000Z</published>
    <updated>2020-09-05T08:49:42.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接下来讲讲解释器模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>解释器模式属于行为型模式。它实现了一个表达式的接口，用于解释上下文。比如正则表达式解析，SQL解析等等。<br>这种模式应用上较少，那在框架上用的还是比较多的，比如上文提到了正则表达式，还有XML解析，SQL解析等等都有着应用。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>那我们就用一个简单的例子来实现这个模式。<br>先来讲讲解释器模式中的几个角色：  </p><ul><li>抽象表达式(AbstractExpression)：是所有终结符表达式和非终结符表达式的公共父类。</li><li>终结符表达式(TerminalExpression)：指的是与终结符相关的表达式。</li><li>非终结符表达式(NonterminalExpression)：即没有终结符的表达式，通常一个解释器模式中，由少数几个终结符表达式与非终结符表达式构成。</li><li>Context：上下文，一般是存储需要解释的语句。  </li></ul><p>比如我要实现一个简易的计算器。<br>那我们先定义抽象表达式接口Interpreter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interpreter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>然后定义非终结符表达式，这里就是解析数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberInterpreter</span> <span class="keyword">implements</span> <span class="title">Interpreter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberInterpreter</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberInterpreter</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = Integer.parseInt(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>然后是终结符表达式，这里就是运算符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddInterpreter</span> <span class="keyword">implements</span> <span class="title">Interpreter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Interpreter first,second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddInterpreter</span><span class="params">(Interpreter first, Interpreter second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;+&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first.interpret() + second.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>我们直接写一个客户端调用一下试试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String express = <span class="string">&quot;2 + 3&quot;</span>;</span><br><span class="line">        String[] keyWords = express.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        String operator = <span class="string">&quot;+&quot;</span>;</span><br><span class="line">        Interpreter[] nums = <span class="keyword">new</span> Interpreter[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String keyword : keyWords)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = Integer.parseInt(keyword);</span><br><span class="line">                nums[index++] = <span class="keyword">new</span> NumberInterpreter(tmp);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                operator = keyword;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (operator.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">            Interpreter add = <span class="keyword">new</span> AddInterpreter(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">            System.out.println(add.interpret());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>我们就简单实现了加法运算，那值得注意的有以下几点：</p><ul><li>在main方法中的解析应该转移到工具类当中，客户端应该直接调用工具类。</li><li>既然符号是终结符表达式，那么以上的express应该改为后缀表达式”2 3 +”，然后通过栈来求整个表达式的值。</li></ul><p>那么以上几点就是我的修改建议，感兴趣的朋友可以接着写下去，实现其他运算，加上工具类的封装。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>解释器模式的优点在于可扩展性良好，并且十分灵活，当我们新增一个表达式时，原有代码无需修改。<br>那缺点在于如果语法过于复杂，解析起来会十分麻烦，类的数量会急剧增加，导致难以维护。其次由于解释器模式使用了大量的循环和递归，当面对较复杂语句时执行速度会受到影响。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解释器模式为语言的设计和实现提供了一种解决方案，通过定义表达式来解析语言中的语句，在项目中的使用频率不是很高，但如要实现一门语言或者解析语句，那这个模式就应用的很广泛。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;接下来讲讲解释器模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之责任链模式</title>
    <link href="https://re0.top/2020/09/05/chain_of_responsibility_pattern/"/>
    <id>https://re0.top/2020/09/05/chain_of_responsibility_pattern/</id>
    <published>2020-09-05T07:00:00.000Z</published>
    <updated>2020-09-05T07:41:39.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文来谈谈责任链模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>责任链模式属于行为型模式。正如名字所说一样，对象是一个链式的结构，当请求到达对象时，如果第一个对象不能处理这个请求，则将请求传递给下一个对象，以此类推。<br>责任链可以是直线型，也可以是环形，又或者是树形。那这种设计模式简化了请求传递的复杂度，请求只要传递给责任链上，并且无需关心如何处理请求，所以责任链模式将请求者与接受者解耦了。<br>那我们常见的场景有：</p><ul><li>js中的事件冒泡，事件会依次向上传递。</li><li>jvm中的类加载机制也是责任链模式，但会一直指派到最顶级的类加载。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>责任链模式中有两个角色：</p><ul><li>抽象处理者(Handler)：抽象对象或者接口。定义一个处理请求的接口。</li><li>具体处理者(ConcreteHandler)：具体的请求处理者，接收请求后选择是否处理请求，如不处理，则传递给下一位。  </li></ul><p>我们先用简单的例子：<br>首先创建handler：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下一个处理者</span></span><br><span class="line">    <span class="keyword">protected</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getNextHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextHandler</span><span class="params">(Handler nextHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handlerRequest</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>随后我们创建具体的处理者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandlerA</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRequest</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;handler A 处理请求&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getNextHandler() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;handler A 无法处理请求，转交给下一个handler&quot;</span>);</span><br><span class="line">            getNextHandler().handlerRequest(name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有handler都无法处理请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandlerB</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRequest</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;handler B 处理请求&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getNextHandler() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;handler B 无法处理请求，转交给下一个handler&quot;</span>);</span><br><span class="line">            getNextHandler().handlerRequest(name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有handler都无法处理请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>这里我们重写handlerRequest方法，当这个具体处理者可以处理请求时，直接处理请求，不能处理时，我们传给责任链中下一个处理者，如果没有下一个处理者就退出。<br>最后是客户端，其中客户端中我们需要显式地构建责任链。我们编写客户端试试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Handler handlerA = <span class="keyword">new</span> ConcreteHandlerA();</span><br><span class="line">        Handler handlerB = <span class="keyword">new</span> ConcreteHandlerB();</span><br><span class="line"></span><br><span class="line">        handlerA.setNextHandler(handlerB);</span><br><span class="line"></span><br><span class="line">        handlerA.handlerRequest(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>这里我们将handlerA 的下一个责任链对象设置为handlerB，这样所有的handler形成了一个链表，我们只需将所有请求发送给handlerA，就无需关心请求是如何进行处理是谁处理的。  </p><h2 id="常见需求场景"><a href="#常见需求场景" class="headerlink" title="常见需求场景"></a>常见需求场景</h2><p>所以责任链模式适用于一级一级传递的需求当中。比如日志管理，那我们常见的日志级别就是一级一级的，有debug，info，warning，error等等的级别，当日志级别设为较低一级时，它以上的日志都会打印。<br>又比如权限的管理，比如操作的级别有很多级，对服务器越危险的操作就必须有更高权限的人来确认操作，那根据操作的级别，把请求传递给责任链，权限不足就交给上一级，直到这个操作进行确认。<br>这里感兴趣的同学可以动手写写简单的实现代码。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>那责任链模式能一定程序上降低请求的发送者与处理者之间的耦合，不用关心请求发送给哪个处理者。其次对于指派处理者较为灵活，可以改变链中的顺序和成员，动态增加和删除。<br>那缺点在于不能保证请求一定被接收，其次就是环的解决，如果处理不当，有可能导致循环调用。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文来谈谈责任链模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之桥接模式</title>
    <link href="https://re0.top/2020/09/04/bridge_patterns/"/>
    <id>https://re0.top/2020/09/04/bridge_patterns/</id>
    <published>2020-09-04T07:00:00.000Z</published>
    <updated>2020-09-04T09:00:20.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>桥接模式其实是很少在项目中使用的设计模式，难度可以说是很大的。但是理解桥接模式能更深入的理解面向对象编程。<br>那这篇就来讲讲这个模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们先来看看维基百科上的定义：  </p><blockquote><p>桥接模式是软件设计模式中最复杂的模式之一，它把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。  </p></blockquote><p>听起来就很复杂，而且竟然说是最复杂的设计模式。<br>桥的作用就是连接河的两岸，那么桥接是不是也有关系呢？是的，桥接就是为了连接两个独立结构，而这两个独立结构可以独立的发生变化。<br>那这个设计模式的目的就是为了将抽象部分与实现部分分离，使他们可以独立的变化，这个抽象与实现部分就是我们上面所说的两个独立结构。<br>总结一下，这个设计模式解决的有以下几点： </p><ul><li>如果系统需要在抽象化和具体化之间更加灵活的转换，避免了两个层次之间建立静态的继承关系，此时通过桥接模式能是他们建立联系。</li><li>当使用多层次继承时，会导致系统类的增多导致类爆炸，那使用桥接模式是不错的选择。</li><li>当一个类可能有多个变化的方向时，并且这几个变化方向都各自独自，那桥接模式就排上用场了。  </li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>由于图床实在是不方便，所以我没有放UML图，我这里还是简单实现个小例子吧。<br>首先桥接模式涉及到的角色有以下几个：  </p><ul><li>Abstraction：抽象接口</li><li>RefinedAbstraction：拓展Abstraction</li><li>Implementor：具体的实现接口，它和RefinedAbstraction中的接口不一定相同</li><li>ConcreteImplementor：实现Implementor接口 </li></ul><p>一个简单小例子，比如乘坐交通工具出门旅游，可能有多个目的地的变化，比如杭州，上海等，然后出门的交通工具也可以不同，比如小轿车自驾，或者做飞机。<br>那以上代码如何去实现桥接呢？<br>首先我们定义Implementor，那对应到这个例子就是交通工具。为啥先定义具体接口呢？原因是因为在Abstraction会将Implementor作为对象注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ride</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>接下来是具体的交通工具(ConcreteImplementor)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ride</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;乘坐小轿车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirPlane</span> <span class="keyword">implements</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ride</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;乘坐飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>那接下来就是抽象对象接口(Abstraction)，这例子中就是我们的目的地。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Vehicle vehicle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">City</span><span class="params">(Vehicle vehicle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vehicle = vehicle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>具体的目的地</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HangZhou</span> <span class="keyword">extends</span> <span class="title">City</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HangZhou</span><span class="params">(Vehicle vehicle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(vehicle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.vehicle.ride();</span><br><span class="line">        System.out.println(<span class="string">&quot;到杭州旅游&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShangHai</span> <span class="keyword">extends</span> <span class="title">City</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShangHai</span><span class="params">(Vehicle vehicle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(vehicle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.vehicle.ride();</span><br><span class="line">        System.out.println(<span class="string">&quot;到上海旅游&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <p>我们写个测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        City city = <span class="keyword">new</span> ShangHai(<span class="keyword">new</span> AirPlane());</span><br><span class="line">        city.visit();</span><br><span class="line"></span><br><span class="line">        City city1 = <span class="keyword">new</span> HangZhou(<span class="keyword">new</span> Car());</span><br><span class="line">        city1.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>如此我们便将抽象部分与实现部分相分离，比如当类发生改变时，两者互不影响。比如交通工具增多，那对于City是没什么影响的，反过来，City增多也不影响交通工具。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点很明显，就是抽象与实现的分离，并且扩展性强，而且具体的实现对调用者是透明的。<br>而缺点就是这个模式理解起来有难度，对于维护可能会加重，并且由于建立在抽象编程上，开发者需要深入面向对象编程才能理解。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那简单总结一下</p><ul><li>如果抽象和实现部分不想耦合性那么强，那么可以采用桥接模式，将两个部分分开来。</li><li>如果两个部分都需要单独的扩展，可以使用桥接模式，两部分都可以独立的变化，并且互不影响。</li><li>当修改实现类时，不希望对调用方产生影响，那可以采用桥接模式，因为调用方是面向接口的，如果具体的实现类修改时，调用方不受影响，可以说是对调用方是透明的。</li><li>当我们采用继承时，可能会有很多子类，比如C继承B，B继承A，多级继承时，那采用桥接模式可以减少子类的数目。</li></ul><p>那以上就是这篇文章的内容，全文写下来觉得这个模式虽然很晦涩，但只要多写写代码就能理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;桥接模式其实是很少在项目中使用的设计模式，难度可以说是很大的。但是理解桥接模式能更深入的理解面向对象编程。&lt;br&gt;那这篇就来讲讲这个模式。 
      
    
    </summary>
    
    
      <category term="编程" scheme="https://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
