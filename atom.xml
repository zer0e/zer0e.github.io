<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zer0&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://re0.top/"/>
  <updated>2020-12-13T09:41:54.263Z</updated>
  <id>http://re0.top/</id>
  
  <author>
    <name>Zer0</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈Spring Boot自动配置</title>
    <link href="http://re0.top/2020/12/13/autoConfiguration/"/>
    <id>http://re0.top/2020/12/13/autoConfiguration/</id>
    <published>2020-12-13T06:10:00.000Z</published>
    <updated>2020-12-13T09:41:54.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久没写技术性文章了，今天就来谈谈SpringBoot中最常见但是却很少人去了解的知识，那就是SpringBoot是如何让你免去如此多的xml配置的。<br>本人技术有限，文章如有错误请谅解。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>用过SpringBoot的人都很清楚，它很方便，不用配置xml，开箱即用，那你是否想过SpringBoot是如何实现自动配置的呢？我也很好奇，那本文就深入源码看看SpringBoot都做了些什么来自动配置的吧。  </p><h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>那我们当然是新建一个项目啦，我们很清楚，springboot项目都用一个以@SpringBootApplication为注解的主类，这是我们项目的入口点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FirstDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>那通过上面的导入，我们知道@SpringBootApplication来自autoconfigure包中，看名字就知道这是我们需要的自动配置相关的包。那我们跟进这个注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), <span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  </p><p>这个注解里面使用@AliasFor将多个注解组合，简单解释就是将它上面的注解合并成当前注解，即SpringBootApplication。换句话来说，@SpringBootApplication就相当于@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解一起作用。<br>那其中@ComponentScan是我们比较熟悉的，用于扫描bean组件装配到ioc容器中，这里我们便不展开。<br>然后是@SpringBootConfiguration，跟进后我们发现其实就是@Configuration中的一种，也就是配置类，这里我们也不多讲。<br>本文的主角就是@EnableAutoConfiguration。</p><h2 id="深入-EnableAutoConfiguration"><a href="#深入-EnableAutoConfiguration" class="headerlink" title="深入@EnableAutoConfiguration"></a>深入@EnableAutoConfiguration</h2><p>我们跟进@EnableAutoConfiguration。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>有两个主要注解，@AutoConfigurationPackage和@Import({AutoConfigurationImportSelector.class})。<br>我们先来看看@AutoConfigurationPackage。</p><h3 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;Registrar.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>这里提一下，import注解是spring提供的，它的作用是将某个类实例化后加入ioc容器中。<br>那么我们就可以知道@AutoConfigurationPackage其实就是将Registrar.class实例化后加入ioc容器当中。继续跟进Registrar类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line">    Registrar() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        AutoConfigurationPackages.register(registry, (String[])(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>我们发现是一个静态内部类，其中有两个方法registerBeanDefinitions和determineImports。我们分别在两个方法中加入断点，调试下。其中<code>(String[])(new AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(new String[0])</code>返回的是@SpringBootApplication注解所在的类的包名，在这个项目中就是<code>com.example.first_demo</code>。<br>然后就是determineImports，在项目中没有触发断点，我们通过无敌的google大法知道返回的是一组代表要导入项的对象。这对本文的主题无多大关系，因此就略过。<br><strong>至此，@AutoConfigurationPackage的作用就是将主配置类所在的包及子包中的所有组件扫描到ioc容器当中。</strong></p><h3 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h3><p>重新回到@EnableAutoConfiguration，发现它将AutoConfigurationImportSelector添加到容器中。这应该就是自动配置的核心所在，我们跟进这个类。这个类中的方法很多，我们挑一些重要的来讲。<br>像getAutoConfigurationEntry方法，源码中还特意添加了注释。这个方法用于获取需要自动装配的类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the &#123;<span class="doctag">@link</span> AutoConfigurationEntry&#125; based on the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125;</span></span><br><span class="line"><span class="comment"> * of the importing &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotationMetadata the annotation metadata of the configuration class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the auto-configurations that should be imported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>在这个方法中又有一个比较重要的方法，getCandidateConfigurations。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the auto-configuration class names that should be considered. By default</span></span><br><span class="line"><span class="comment"> * this method will load candidates using &#123;<span class="doctag">@link</span> SpringFactoriesLoader&#125; with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #getSpringFactoriesLoaderFactoryClass()&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> metadata the source metadata</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> attributes the &#123;<span class="doctag">@link</span> #getAttributes(AnnotationMetadata) annotation</span></span><br><span class="line"><span class="comment"> * attributes&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a list of candidate configurations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">            getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">            + <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>这个方法返回所有候选配置类，即包括需要加载的和用户指定排除的。<br>在这个方法中使用了SpringFactoriesLoader.loadFactoryNames，SpringFactoriesLoader是Spring框架的一个内部工具类，用于加载类。继续跟进方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the fully qualified class names of factory implementations of the</span></span><br><span class="line"><span class="comment"> * given type from &#123;<span class="doctag">@value</span> #FACTORIES_RESOURCE_LOCATION&#125;, using the given</span></span><br><span class="line"><span class="comment"> * class loader.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As of Spring Framework 5.3, if a particular implementation class name</span></span><br><span class="line"><span class="comment"> * is discovered more than once for the given factory type, duplicates will</span></span><br><span class="line"><span class="comment"> * be ignored.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factoryType the interface or abstract class representing the factory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader the ClassLoader to use for loading resources; can be</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125; to use the default</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if an error occurs while loading factory names</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadFactories</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    ClassLoader classLoaderToUse = classLoader;</span><br><span class="line">    <span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    String factoryTypeName = factoryType.getName();</span><br><span class="line">    <span class="keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>这个方法返回加载类的全名，通过loadSpringFactories私用方法，我们详细来看这个。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line">                String[] factoryImplementationNames =</span><br><span class="line">                        StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line">                <span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">                    result.computeIfAbsent(factoryTypeName, key -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;())</span><br><span class="line">                            .add(factoryImplementationName.trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Replace all lists with unmodifiable lists containing unique elements</span></span><br><span class="line">        result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()</span><br><span class="line">                .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));</span><br><span class="line">cache.put(classLoader, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location ["</span> +</span><br><span class="line">FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>那么简单看下源码我们可以得知，该方法就是读取每个类中的META-INF/spring.factories文件中设置的所有xxxAutoConfiguration类，并使用PropertiesLoaderUtils.loadProperties获取其所有属性值，将这些值作为自动配置类添加到ioc容器当中，相当于完成了配置，以前需要手动配置的东西，自动配置帮我们添加了默认值。<br>我们可以看看spring-boot-autoconfigure中的spring.factories。这些都是默认自动装配的。<br>简单贴一些。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br></pre></td></tr></table></figure>  </p><p>比如我们看看AopAutoConfiguration<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"auto"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(Advice.class)</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">        <span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">false</span>)</span><br><span class="line">        <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"false"</span>,</span><br><span class="line">                matchIfMissing = <span class="keyword">false</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">        <span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">true</span>)</span><br><span class="line">        <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"true"</span>,</span><br><span class="line">                matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">    <span class="meta">@ConditionalOnMissingClass</span>(<span class="string">"org.aspectj.weaver.Advice"</span>)</span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"true"</span>,</span><br><span class="line">            matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassProxyingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassProxyingConfiguration(BeanFactory beanFactory) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">                BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">                AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>可以清楚地看到，springboot提供了默认配置类，并通过条件注解来加载配置到容器中。</p><h2 id="第三方jar自动配置"><a href="#第三方jar自动配置" class="headerlink" title="第三方jar自动配置"></a>第三方jar自动配置</h2><p>从上面我们已经可以知道springboot会扫描所有类的spring.factories，并从中读取自动配置类。就比如常用的mybatis，我们在项目中导入mybatis，并查看它的依赖。<br>一般来说，我们在springboot项目中都是使用mybatis-spring-boot-starter导入到pom文件中，我们查看这个包的依赖，其实就是导入mybatis，jdbc，还有mybatis-spring-boot-autoconfigure，看到autoconfigure，我们知道肯定就是这个包完成自动配置。<br>我们查看这个包的资源文件，果然发现了spring.factories文件。里面就几行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span><br></pre></td></tr></table></figure>  </p><p>这里默认配置类我就不贴了，就是通过条件注解将默认配置添加到spring中。</p><h2 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h2><p>上文提到了条件注解，它作用在类上就是满足一定条件时类才会进行装配，其中条件注解有：</p><ul><li>ConditionalOnBean 容器中存在某个bean时生效</li><li>ConditionalOnClass classpath中存在某类时生效</li><li>ConditionalOnCloudPlatform 当指定的云平台处于活动状态时生效</li><li>ConditionalOnExpression SpEL表达式结果为true时生效</li><li>ConditionalOnJava 指定的Java版本存在时生效</li><li>ConditionalOnJndi 指定的JNDI存在时生效</li><li>ConditionalOnMissingBean 容器中不存在某个bean时生效</li><li>ConditionalOnMissingClass classpath中不存在某类时生效</li><li>ConditionalOnNotWebApplication 非Web应用环境下生效</li><li>ConditionalOnProperty 参数设置或者值一致时生效</li><li>ConditionalOnResource 指定的文件存在时生效</li><li>ConditionalOnSingleCandidate 容器中该类型Bean只有一个或@Primary的只有一个时生效</li><li>ConditionalOnWarDeployment 使用WAR部署时生效</li><li>ConditionalOnWebApplication Web应用环境下生效</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那本文简单从源码入手，讲解了springboot是如何自动配置的，@SpringBootApplication注解中包含了@EnableAutoConfiguration，这个注解帮助我们自动配置。<br>首先springboot在启动时扫描同一个包类的所有的组件，并检查各个jar包中是否存在META-INF/spring.factories 文件，然后如果第三方jar中存在这个文件，会根据文件中设置的自动装配类进行加载，使之生效。如此便实现了自动配置。<br>不过话说回来，说是自动配置，其实就是源码和第三方包中帮你把配置的功夫省下来了，节约不少时间，也能防止很多bug的出现。<br>那本文也留下很多没提到的，比如springboot怎么开始自动配置的，我们知道它如何装配，但是我们却不知道如何开始。这个也是个有趣的点，之后会写一写springboot的生命周期相关的文章。</p><h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><p>那本文写到这里就结束了，2020年马上也要过去了，时间是真的快，有空的话也会写写2020年的总结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;好久没写技术性文章了，今天就来谈谈SpringBoot中最常见但是却很少人去了解的知识，那就是SpringBoot是如何让你免去如此多的xm
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://re0.top/tags/Java/"/>
    
      <category term="Spring" scheme="http://re0.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>回顾数据库事务隔离级别</title>
    <link href="http://re0.top/2020/11/01/transaction_isolation/"/>
    <id>http://re0.top/2020/11/01/transaction_isolation/</id>
    <published>2020-11-01T06:10:00.000Z</published>
    <updated>2020-11-02T07:24:22.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于数据库隔离级别，前前后后可能复习了好多遍，但是很经常就忘记，今天就简单整理下概念和实例，方便以后回顾。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>首先我们先明确事务是什么？为什么要有事务？<br>事务(Transaction)，其实就是一个操作序列，我们知道，操作数据库是什么一条条SQL语句来实现的，那么事务就是包含这些SQL操作的清单。<br>至于为什么要有事务，是因为事务是为了解决并发情况下如何保持数据一致性的问题。通过事务，我们能在并发情况下保持数据的一致性。    </p><h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><p>事务的四大特性简称ACID，分别为原子性(Atomicity)，一致性(Consistency)，隔离性(Isolation)，持久性(Durability)。<br>所谓原子性，是指事务中包含的所有操作必须全部成功或者全部失败。<br>一致性，是指事务执行前后，数据的状态是一致的。一般来说，就是指数据不会凭空产生或消失。就拿库存和订单来说，商品的订单增加必定伴随着库存的减少，两者涉及的商品总量是一致的。<br>隔离性，是指多个事务并发执行时，彼此之间要相互隔离，简单来说就是事务感受不到其他事务的存在。这就是我之后要讲的隔离级别。<br>持久性，是指事务一旦提交，那么对于数据库中数据的改变是永久性的。  </p><h2 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h2><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p>通常情况下，对mysql命令行的所有语句都是自动提交的，可以简单理解成每条SQL语句都是一个独立的事务，在我们写SQL之前就开启了事务，当我们回车之后自动帮我们提交给数据库。<br>那这只是单条SQL语句，如果在命令行中要执行多条SQL语句的事务，需要使用begin和commit命令来显示开启事务。在事务提交之前，所有的修改都不会应用到数据上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | abc  |</span><br><span class="line">|  2 | asd  |</span><br><span class="line">+----+------+</span><br><span class="line">2 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into user values (3,&quot;aaa&quot;);</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | abc  |</span><br><span class="line">|  2 | asd  |</span><br><span class="line">|  3 | aaa  |</span><br><span class="line">+----+------+</span><br><span class="line">3 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected</span><br></pre></td></tr></table></figure></p><p>如果我们在commit之前打开另一个命令行进行查询，我们可以发现新插入的数据并没有在数据库中。  </p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>那在Spring中我们要使用事务，简单来说就是使用@Transactional注解来实现，即在方法上标注注解就可以实现。简单写下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDAO userDAO;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = userDAO.insert(user);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"显式抛出异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们在addUser方法中手动抛出异常，如果@Transactional注解指定了触发回滚的异常类型，那么如果抛出了该种异常，就会自动回滚(rollback)，数据不会插入到数据库中。<br>那么关于spring中的事务管理与深入学习，就留到之后的文章再讨论吧。  </p><h2 id="并发事务所出现的问题"><a href="#并发事务所出现的问题" class="headerlink" title="并发事务所出现的问题"></a>并发事务所出现的问题</h2><p>前面提到在并发事务时，事务是相互隔离的，但是隔离有性能代价的，隔离越彻底，那么性能就越差，所以数据库会提供不同级别的隔离策略，开发者需要考虑事务并发的安全性与性能上的差异，来选择合适的隔离级别。<br>那么事务并发会引发哪些数据上的不安全性呢？  </p><h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p>丢失更新分为两类，一般称为第一类丢失更新和第二类丢失更新。<br>第一类丢失更新是指，在A事务回滚后，把已经提交的B事务的数据给覆盖掉了。例如A事务是扣款100元，而B事务是增加100元，在A事务已经修改余额但是还未提交或回滚时，B事务已经增加了100元。这时候A事务回滚，变为原来的钱，此时B事务增加的100元就消失了。<br>第二类丢失更新，是指在A事务提交后，把已经提交的B事务的数据给覆盖掉了。与第一类丢失更新类似，区别在于第一类是回滚，而第二类是提交。<br>丢失更新本质上和<strong>可重复读</strong>是同一类并发的问题，多个数据查询同一数据，都是基于自己的查询来更新数据，会造成最后一个提交或回滚的事务覆盖掉其他已经提交的事务。  </p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读的定义是读到未提交的数据。<br>这个好理解，假设原来有100元，现在A事务增加100元，余额变成200元，但此时还未提交，这时B事务读取到了事务A修改后的数据，即读取到余额为200元，然后把200元扣款成0元，并提交了数据。但最后A事务却进行了回滚，把余额重新变为100元。这样就相当于无缘无故增加了200块钱。<br>在默认隔离级别下，避免了脏读操作。  </p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读是指读到了已经提交的更新数据，即一个事务中两次相同查询却返回了不同的<strong>更新数据</strong>。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>幻读与不可重复读类似。幻读是指在一个事务中的两次相同查询却查到了另一个事务已提交的<strong>新插入数据</strong>。<br>两者区别是不可重复读是由数据修改产生的，而幻读是数据插入或者删除产生的。  </p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>那么为了解决上述的事务并发问题，Mysql中定义了四种隔离级别，分别是读未提交，读已提交，可重复读，可串行化。  </p><h3 id="读未提交-READ-UNCOMMITTED"><a href="#读未提交-READ-UNCOMMITTED" class="headerlink" title="读未提交(READ UNCOMMITTED)"></a>读未提交(READ UNCOMMITTED)</h3><p>在这种隔离级别下，事务A能读取到事务B修改但是未提交的数据，那么就会导致脏读，不可重复读和幻读问题。  </p><h3 id="读已提交-READ-COMMITTED"><a href="#读已提交-READ-COMMITTED" class="headerlink" title="读已提交(READ COMMITTED)"></a>读已提交(READ COMMITTED)</h3><p>这种隔离级别下，事务A只能在事务B修改并且提交之后才能读取到修改后的数据。<br>它解决了脏读问题，但是会发生不可重复读和幻读问题。  </p><h3 id="可重复读-REPEATABLE-READ"><a href="#可重复读-REPEATABLE-READ" class="headerlink" title="可重复读(REPEATABLE READ)"></a>可重复读(REPEATABLE READ)</h3><p>在这种隔离级别下，当事务B做出修改并提交后，只有事务A<strong>提交之后</strong>才能读到事务B修改的数据。<br>那可重复读解决了脏读和不可重复读问题，但是仍可能会发生幻读问题。<br>Q：Mysql中在update的时候会锁住当前行，但是为什么其他事务还能读到数据呢？<br>A：因为Mysql的innoDB有MVCC机制，可以使用快照读取数据，而不阻塞。那后面我会讲讲这个机制。  </p><h3 id="可串行化-SERIALIZABLE"><a href="#可串行化-SERIALIZABLE" class="headerlink" title="可串行化(SERIALIZABLE)"></a>可串行化(SERIALIZABLE)</h3><p>在这种隔离级别下，如果两个事务都是对数据进行修改，那么事务将以串行化的方式顺序执行，保证数据的安全。以下分四种情况讨论，假设事务A先于事务B：  </p><ul><li>如果事务A与事务B都是读取同一个数据，那这种情况下事务不会阻塞。因为没有读数据进行修改。</li><li>如果事务A先读取数据，这时事务B要修改这行数据，那么事务B会阻塞直到事务A提交。</li><li>如果事务A先修改数据，事务B要读取数据，那么事务B会阻塞直到事务A提交。  </li><li>如果事务A先修改数据，而事务B也要修改这行数据，那么事务B会等到事务A提交过后再进行修改。  </li></ul><p>那么综上所述，可串行化就是根据事务的先后顺序，来决定读取和修改数据的先后。可以简单理解成当前一个事务结束，后一个事务才开始，但是要注意的是，后一个事务其实早就开始了，只是被阻塞而已。<br>可串行化下，读取会获得<strong>表级的共享锁</strong>，因此读写相互就会阻塞。<br>那么在可串行化下，解决了脏读，不可重复读还有幻读问题，避免了并发事务中的读取与修改问题。  </p><h3 id="查看和修改事务隔离级别"><a href="#查看和修改事务隔离级别" class="headerlink" title="查看和修改事务隔离级别"></a>查看和修改事务隔离级别</h3><p>分别为系统隔离级别和会话隔离级别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@global.tx_isolation,@@tx_isolation;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| @@global.tx_isolation | @@tx_isolation  |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| REPEATABLE-READ       | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">1 row in set</span><br><span class="line"></span><br><span class="line">mysql&gt; set global transaction isolation level Repeatable Read;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; set session transaction isolation level Repeatable Read;</span><br><span class="line">Query OK, 0 rows affected</span><br></pre></td></tr></table></figure></p><h2 id="mysql如何实现隔离级别"><a href="#mysql如何实现隔离级别" class="headerlink" title="mysql如何实现隔离级别"></a>mysql如何实现隔离级别</h2><h3 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h3><p>首先我们要明白数据库遵循的是两段锁协议，即事务分为两个阶段，加锁和解锁。<br>加锁阶段，就是在相应的操作前要申请对应的锁。如在读操作前要申请S锁(share共享锁)，此时其他事务可以继续添加S锁，但不能添加X锁；又如在写操作前要申请X锁(排他锁)，此时其他事务不能添加任何锁。如果加锁不成功那么事务会等待直到加锁成功。<br>解锁阶段，一般在事务的提交时，会同时释放这个事务所申请的所有锁。<br>那么两段锁协议无法避免死锁，但是能保证事务并发调度是串行化的(注意不是隔离级别)，在数据备份与恢复时十分重要。 </p><h3 id="读已提交与可重复读的加锁方式"><a href="#读已提交与可重复读的加锁方式" class="headerlink" title="读已提交与可重复读的加锁方式"></a>读已提交与可重复读的加锁方式</h3><p>前面有提到过，mysql当中有表锁和行锁，表锁锁住的是整张表，例如可串行化下就是使用表锁，而行锁则是锁住有限的数据行。  </p><h4 id="读已提交-RC"><a href="#读已提交-RC" class="headerlink" title="读已提交(RC)"></a>读已提交(RC)</h4><p>在读已提交这个隔离级别中，假设事务A与事务B都要修改同一条数据，但是事务A先于事务B，那么根据前面我们知道，读已提交就是事务B只能读到事务A已经修改的数据。那么当事务A修改数据后，但是并未提交时，根据两段锁协议，事务A会在修改之前申请X锁，在提交之后释放，那么事务A一直不commit，则会导致事务B一直拿不到锁，直到超时。  </p><p>那么这里有一个值得注意的地方。那就是mysql如何确定要获取哪个行的行级锁呢？答案就是索引。假设id为索引，那么<code>update user set name = &quot;123&quot; where id = 1;</code>这条语句会根据id来找到相应的行，并获取这个行的行级锁。如果SQL语句的条件不是根据索引，那么此时mysql会给整个表的行加行级锁。<br>那么更有意思的出现了，mysql锁住所有行之后，会再次进行过滤，发现条件不满足时，会直接将该行的行级锁给释放，这违反了二段锁协议。这样确定了最后只有满足条件的行上加了锁。（详情见《高性能Mysql》）  </p><h4 id="可重复读-RR"><a href="#可重复读-RR" class="headerlink" title="可重复读(RR)"></a>可重复读(RR)</h4><p>这个是Mysql中innodb默认的隔离级别。我们知道这个级别下，同一个事务中的相同查询只会查到相同的数据。假设事务A做了两次查询，但是事务B和事务C同时在两次查询中间修改了数据，但是却返回了相同的数据。<br>如果使用锁来实现，又是如何实现呢？很简单，既然不可重复读的重点是update和delete，那么我在读取数据时直接加X锁，其他事务无法修改这些数据，那么就可以实现可重复读了。但是幻读又是怎么解决的呢？前面也简单提到过，可串行化的隔离级别，本质上就是通过读锁和写锁实现，只不过读写锁互斥，这就解决了幻读问题。<br>上面所讲的，就是使用<strong>悲观锁</strong>来实现隔离级别的，但是mysql出于性能考虑，RR级别下是采用乐观锁为基础的MVCC协议来实现。  </p><h3 id="MVCC协议"><a href="#MVCC协议" class="headerlink" title="MVCC协议"></a>MVCC协议</h3><h4 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h4><p>在谈这个协议之前，我们先来讲讲悲观锁和乐观锁。<br>前面的文章我也提到过，悲观锁是指认为所有数据随时都可能被修改，而乐观锁则是认为数据并不是随时会更新，所以它只会在更新时判断数据是否已经进行了更新。<br>那么乐观锁大多数是基于版本号来实现的。即在数据行中添加一个新的数据段version，通过这个version来判断读取的数据和当前数据库中的数据是否是同一个，也就是是否已经被修改过。  </p><h4 id="innoDB中MVCC的实现"><a href="#innoDB中MVCC的实现" class="headerlink" title="innoDB中MVCC的实现"></a>innoDB中MVCC的实现</h4><p>MVCC，全称为Multi-Version Concurrency Control，即多版本并发控制。MVCC没有固定的规范，所以每个数据库的实现可能会不同，这里讲讲innoDB中的实现。<br>在innoDB当中，每行记录都会由两个隐藏的列，一个是创建版本号，另一个是删除版本号。创建版本号是指创建一个数据行的事务版本号(事务版本号：事务开始时的系统版本号；系统版本号：每开始一个事务，系统版本号就会递增)。(ps.搁着套娃呢)<br>删除版本号则是delete操作时的版本号。<br>在RR级别下，各种操作如下：</p><ul><li>insert操作时，记录当前事务版本号为当前行的创建版本号。</li><li>delete操作时，记录当前事务版本号到删除版本号。</li><li>update操作时，先记录当前事务版本号到删除版本号，再增加一条记录，保存当前事务版本号为创建版本号。  </li><li>select操作时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或者&gt;当前事务版本号。即创建操作早于当前事务，删除操作晚于当前事务。</li></ul><p>那么通过MVCC协议，虽然会增加额外的存储空间，但是可以减少锁的使用，读取数据时不用加锁。<br>那这里又有一个有趣的点，那就是不管从书上还是网上，基本上是说RR级别解决了不可重复读，无法解决幻读。但是在mysql当中却是另一种情况。<br>假设事务A两次读取中间我们使用事务B增加一条数据，理论上来说事务A第二次读会读取到事务B中增加的行。<br>那么实验出结果，先是事务A读取一次数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | abc  |</span><br><span class="line">|  2 | asd  |</span><br><span class="line">|  3 | aaa  |</span><br><span class="line">+----+------+</span><br><span class="line">3 rows in set</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>好，我们读取到三条数据。此时打开另一个命令行添加一条数据进去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into user values (4,&quot;aaa&quot;);</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | abc  |</span><br><span class="line">|  2 | asd  |</span><br><span class="line">|  3 | aaa  |</span><br><span class="line">|  4 | aaa  |</span><br><span class="line">+----+------+</span><br><span class="line">4 rows in set</span><br></pre></td></tr></table></figure></p><p>由于是自动提交，我没有开启新事务，这不要紧。接着我们返回事务A再次查询数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | abc  |</span><br><span class="line">|  2 | asd  |</span><br><span class="line">|  3 | aaa  |</span><br><span class="line">+----+------+</span><br><span class="line">3 rows in set</span><br></pre></td></tr></table></figure></p><p>发现依旧是三条数据。那么就很神奇了，mysql的RR级别似乎真的解决了幻读问题？？<br>那么我们就继续实验，我们知道目前数据库中存在四条数据，但是事务A读取的确实三条，那么此时我在事务A中修改新添加的数据行应该是失败的。那么我们就将事务A中的所有数据行修改下，看看它是否会影响到第四条数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update user set name = &quot;zer0e&quot;;</span><br><span class="line">Database changed</span><br><span class="line">Rows matched: 4  Changed: 4  Warnings: 0</span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">+----+-------+</span><br><span class="line">4 rows in set</span><br></pre></td></tr></table></figure>  </p><p>那么很明显，mysql直接提示有四条数据被修改，之后再读取就变成了四条数据，很显然幻读问题并没有真正解决。  </p><h4 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h4><p>那么到底为什么会出现上述情况？查阅资料后发现在RR级别下，通过MVCC协议，我们读取的数据变为可重复读，但是它可能是一个历史数据，那么我们称它为快照读，而读取到数据库最新数据的方式，我们称它为当前读。<br>select操作默认都是快照读，之后select都会返回这次快照读，因此实现了可重复读。<br>而对数据的更新操作(update,insert,delete)都是当前读，执行这几个操作会读取最新的记录，在事务中执行修改操作后会导致快照读变更。也就是我们所测试的那样。<br>如果我们要让select读取到当前读，我们可以手动进行加锁。<br>事务A先读取数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">+----+-------+</span><br><span class="line">4 rows in set</span><br></pre></td></tr></table></figure> </p><p>此时事务B新增一条记录(5,”aaa”)，这里我就不写了，我们来看看事务A再次读取的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">+----+-------+</span><br><span class="line">4 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user lock in share mode;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">|  5 | aaa   |</span><br><span class="line">+----+-------+</span><br><span class="line">5 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user for update;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">|  5 | aaa   |</span><br><span class="line">+----+-------+</span><br><span class="line">5 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | zer0e |</span><br><span class="line">|  2 | zer0e |</span><br><span class="line">|  3 | zer0e |</span><br><span class="line">|  4 | zer0e |</span><br><span class="line">+----+-------+</span><br><span class="line">4 rows in set</span><br></pre></td></tr></table></figure>   </p><p>我们可以发现使用<code>for update</code>或者<code>lock in share mode</code>都可以获取到当前读。<br>所以综上，在RR级别下，幻读并未真正解决，而是因为快照读所以无法读取到最新数据。  </p><h3 id="解决幻读"><a href="#解决幻读" class="headerlink" title="解决幻读"></a>解决幻读</h3><p>那么在RR级别下innodb到底有没有解决幻读问题？通过什么解决？<br>答案是解决了，通过Next-Key锁来实现。</p><h4 id="Next-Key锁"><a href="#Next-Key锁" class="headerlink" title="Next-Key锁"></a>Next-Key锁</h4><p>Next-Key锁是行锁和间隙锁的合并，所谓间隙锁，就是在锁住当前行时，同时锁住当前索引的上下范围。<br>下面进行几项实验：  </p><h5 id="无主键表"><a href="#无主键表" class="headerlink" title="无主键表"></a>无主键表</h5><p>首先隔离级别定为RR，创建表t1，并插入几条间隔数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t1(id int,key id(id))engine=innodb;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1 values(1),(3),(5);</span><br><span class="line">Query OK, 3 rows affected</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  1 |</span><br><span class="line">|  3 |</span><br><span class="line">|  5 |</span><br><span class="line">+----+</span><br><span class="line">3 rows in set</span><br></pre></td></tr></table></figure>   </p><p>事务A通过for update锁住id=5的数据行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 where id=5 for update;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  5 |</span><br><span class="line">+----+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure>   </p><p>此时开启事务B，添加一个数据行在id=5前后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t1 values(2);</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1 values(4);</span><br><span class="line">1049 - Unknown database &apos;ate user set name = &quot;aaa&quot; where id = 5&apos;</span><br><span class="line">terminated by user</span><br><span class="line">mysql&gt; use test;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; insert into t1 values(6);</span><br><span class="line"></span><br></pre></td></tr></table></figure> </p><p>我们会发现事务B会等待，直到事务A提交过后，事务B才插入成功。<br>那么Next-Key锁锁住的到底是多少行？其实它锁住的是它上下的一个范围。例如上述表中，对id=5的行进行加锁，那么innodb会把数据分为几个段，分别为(negative infinity,3]，(3,5]，(5,positive infinity]，都是左闭右开区间，那么对id=5的行添加行锁，同时会对(3,5]，(5,positive infinity]这两个区间添加gap锁(即间隙锁)，导致其他事务无法在这个区间进行更新操作。  </p><h5 id="有主键表"><a href="#有主键表" class="headerlink" title="有主键表"></a>有主键表</h5><p>上面的例子中没有主键，只是有一个普通索引而已。我们再来试一下有主键的例子。<br>创建表并插入几条数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t2(id int primary key)engine = innodb;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t2 values(1),(3),(5);</span><br><span class="line">Query OK, 3 rows affected</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure> </p><p>开启事务A并对id=5的行进行锁定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t2 where id = 5 for update;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  5 |</span><br><span class="line">+----+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure> </p><p>然后尝试在事务B中插入数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t2 values(4);</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t2 values(6);</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t2 where id = 5 for update;</span><br><span class="line">....</span><br></pre></td></tr></table></figure> </p><p>我们发现innodb并没有使用gap锁，而是只锁定了当前行。<br>那其实在innodb当中，<strong>行级锁是通过给索引上的索引项加锁来实现的，当查询的索引含有唯一属性时（主键索引，唯一索引），那么innodb会对next-key锁进行优化，使它降级为行级锁，锁住的不再是范围。</strong><br>所以如果把id不设置成主键，而是设置成唯一索引，也能达到相应的效果。  </p><h5 id="使用无索引字段"><a href="#使用无索引字段" class="headerlink" title="使用无索引字段"></a>使用无索引字段</h5><p>最后我们尝试下使用无索引字段来加锁会如何。<br>先创建表，并插入数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t3(id int,name varchar(10),key id(id))engine=innodb;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t3 values (1,&quot;a&quot;),(3,&quot;b&quot;),(5,&quot;c&quot;);</span><br><span class="line">Query OK, 3 rows affected</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure> </p><p>开启事务A对name=”c”的行加锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t3 where name = &quot;c&quot; for update;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  5 | c    |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set</span><br><span class="line"></span><br></pre></td></tr></table></figure> </p><p>在事务B中尝试加锁其他行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t3 where name = &quot;a&quot; for update;</span><br><span class="line">...</span><br><span class="line">mysql&gt; select * from t3 where name = &quot;b&quot; for update;</span><br><span class="line">...</span><br><span class="line">mysql&gt; insert into t3 values (4,&quot;d&quot;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure> </p><p>可以发现innodb其实对其他行都添加了锁，无法进行更新操作。那通过之前的结论，我们知道行级锁是通过索引加锁，条件中的列没有索引，因此innodb会给全表加上间隙锁。除非事务A提交，否则其他事务无法进行更新操作。  </p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>那之所以<a href="/2020/11/01/transaction_isolation/#innoDB中MVCC的实现">前一个实验</a>“没有”解决幻读，原因在于快照读没有通过行级锁锁住当前行，表中也没有索引，条件语句中没有增加索引条件。我们可以通过添加索引并使用索引的当前读，来解决幻读问题。<br>所以在innodb当中，行级锁防止别的事务对当前行进行修改和删除，间隙锁防止其他事务新增数据，行级锁和间隙锁形成的next-key锁共同解决了RR级别下写的幻读问题。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那本篇的大致内容就写到这里了，本来只计划整理下基础知识，没想到越写越多，多整理了一个mysql中隔离级别的实现。这部分知识我之前是不太了解的，通过自己做下实验后，有种柳暗花明的感觉。也许这就是学习技术所带来的乐趣吧。  </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">mysql参考手册</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对于数据库隔离级别，前前后后可能复习了好多遍，但是很经常就忘记，今天就简单整理下概念和实例，方便以后回顾。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://re0.top/tags/Java/"/>
    
      <category term="Mysql" scheme="http://re0.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>浅谈雪花算法</title>
    <link href="http://re0.top/2020/10/09/snowflake/"/>
    <id>http://re0.top/2020/10/09/snowflake/</id>
    <published>2020-10-09T06:40:00.000Z</published>
    <updated>2020-10-09T07:54:27.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近学习也有点陷入迷茫状态，不知道学些什么，也不知道写点什么。那就想起什么就写点啥，就当是重新学习。<br>今天要来讲的是分布式系统中常用的一种算法，雪花算法。 </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="什么是雪花算法"><a href="#什么是雪花算法" class="headerlink" title="什么是雪花算法"></a>什么是雪花算法</h2><p>雪花算法(snowflake)，它是Twitter公司使用的在分布式系统中生成唯一ID的一个算法，在2014年开源。<br>雪花算法是在高并发环境下生成为ID的算法，它能保证分布式环境下ID不重复，且基本有序递增，并且不依赖与其他的第三方库。  </p><h2 id="雪花算法的原理"><a href="#雪花算法的原理" class="headerlink" title="雪花算法的原理"></a>雪花算法的原理</h2><p>雪花算法的原理十分简单，它生成的ID由64bit组成，其中包括：</p><ul><li>1bit的标志位，由于二进制中最高为1的都是负数，并且生成的id一般都是整数，所以这一位通常为0.</li><li>41bit的时间戳，可以存储69年的时间，一般来说起始时间戳为系统上线的时间戳。</li><li>10bit的机器id，可以部署1024个节点。</li><li>12bit序列号，用来表示同一时间戳下生成的不同id，在同一个时间戳下可以表示4095个序列号。  </li></ul><p>因为刚好是64bit，所以在Java中刚好由long类型来存储。倒不如说是这个算法可能一开始就想好使用long类型来存储。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>当然最重要的还是如何生成ID啦，那生成的算法网上有很多，我就依照可能大家看的最多的代码，来讲讲自己的理解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowFlake</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务上线时间 2020-10-09 00:00:00</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> startTimestamp = <span class="number">1602172800L</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 机器id所占位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">10L</span>;</span><br><span class="line">    <span class="comment">// 支持的最大机器id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = ~(-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    <span class="comment">//序列号占用的位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line">    <span class="comment">//最大序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = ~(-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 机器ID向左移12位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line">    <span class="comment">// 时间截向左移22位(10+12)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//机器id，通过构造器传入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId;</span><br><span class="line">    <span class="comment">//序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">//上一次生成id的时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnowFlake</span><span class="params">(<span class="keyword">long</span> workerId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先机器id不能小于0或大于2^workerIdBits - 1</span></span><br><span class="line">        <span class="keyword">if</span> (workerId &lt; <span class="number">0</span> || workerId &gt; maxWorkerId)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"机器id不正确"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法必须是线程安全的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//如果当前时间小于上一次生成id的时间，说明系统时钟被回退过，需要抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"系统时间被回退"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前时间戳与上次生成id的时间戳相等，则增加序列</span></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp)&#123;</span><br><span class="line">            <span class="comment">// 这里是为了避免超出sequenceBits，即超出后会变成0</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="comment">//如果等于0说明溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 重新获取时间戳</span></span><br><span class="line">                timestamp = getNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不等于上次生成id的时间则序列号直接为0</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line">        <span class="comment">//通过位运算将三个部分进行拼接</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - startTimestamp) &lt;&lt; timestampLeftShift)</span><br><span class="line">                | (workerId &lt;&lt; workerIdShift)</span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞到下一个毫秒，直到获取新的时间戳</span></span><br><span class="line">    <span class="comment">// 由于获取下一个时间戳前进行了时钟回滚判断，所以这里不会长时间阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp)&#123;</span><br><span class="line">            timestamp = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>在代码中都有相应的注释。其中需要理解的可能是生成最大值的位运算，比如<code>maxWorkerId = ~(-1L &lt;&lt; workerIdBits);</code>。<br>首先负数在计算机中是使用补码进行表示，补码是负数绝对值的原码，取反码再加一。-1的绝对值是1，1的原码就是最后一位是1，取反码，就是0变1,1变0，再加1，就得到了全是1的二进制。<br>然后左移workerIdBits位，也就是12位，然后再取反，就得到了最大值，即1023。<br>那其实取最大值有两种写法，一种是<code>maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);</code>还有一种就是上面的写法，一种是异或一种是取反，得到的结果都是相同的。我个人也不确定哪种比较好，idea中提示我使用取反操作，那就当取反操作可能更好一些。当然这只是idea的建议，真正要区分的话还得看两种方法的底层速度比较，我对位运算不熟悉，希望有大佬能比较一下。  </p><h1 id="后续一些思考"><a href="#后续一些思考" class="headerlink" title="后续一些思考"></a>后续一些思考</h1><p>那雪花算法并不算难，通常情况下我们可以对雪花算法进行魔改。比如我可能不需要用到1024个节点啊，那么就把workIdBit减少，然后时间戳增加或者序列号增加。<br>又或者我这个系统可能用不到69年，那就可以适当减少时间戳比特位。<br>那还有就是workid的问题，即workid该怎么决定？那我们可以通过JVM传参，即-D选项，那如果是通过容器化部署的话，可能没办法传入不同参数，那可以通过某些规则来计算workid，比如可以通过该台机器的ip地址或者mac地址来计算workid，但是需要保证workid不重复，否则即使在并发不高的情况下，id也可能重复，至于实现，这里便不再展开，感兴趣的可以自己写写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;最近学习也有点陷入迷茫状态，不知道学些什么，也不知道写点什么。那就想起什么就写点啥，就当是重新学习。&lt;br&gt;今天要来讲的是分
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="http://re0.top/tags/Java/"/>
    
      <category term="分布式" scheme="http://re0.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>谈谈设计模式</title>
    <link href="http://re0.top/2020/09/17/design_patterns/"/>
    <id>http://re0.top/2020/09/17/design_patterns/</id>
    <published>2020-09-17T08:40:00.000Z</published>
    <updated>2020-09-17T08:35:45.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设计模式是提高代码可读性的途径之一，面对不同的场景选择不同的设计模式，可以提高代码可读性，提高代码的可重用性还有可扩展性。接下来就讲讲什么是设计模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="何为设计模式"><a href="#何为设计模式" class="headerlink" title="何为设计模式"></a>何为设计模式</h2><p>设计模式是在面向对象语言中，思想都是一致的，而在面向过程语言，函数式编程的语言中讨论设计模式是没有意义的。所谓的设计模式，就是前面提到的，在面向对象编程中的一些”套路”，在面对不同需求场景时，可以选择不同的设计模式，来提高代码的可读性，重用性与扩展性。   </p><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>在GoF设计模式书籍中，共有23种设计模式。<br>而这23种设计模式又可以分为三大类型:  </p><ul><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>这一类设计模式的目的是为了创建对象。其中包括：  </p><ol><li><a href="/2020/08/13/abstract_factory_pattern/">抽象工厂模式</a></li><li><a href="/2020/08/12/factory_pattern/">工厂方法模式</a></li><li><a href="/2020/08/07/singleton/">单例模式</a></li><li><a href="/2020/09/02/prototype_pattern/">原型模式</a></li><li><a href="/2020/09/14/builder_pattern/">构建模式</a></li></ol><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>这一类设计模式是为了优化不同类，对象，接口之间的结构关系。其中包括：  </p><ol><li><a href="/2020/08/10/proxy_pattern/">代理模式</a></li><li><a href="/2020/08/17/decorator_pattern/">装饰器模式</a></li><li><a href="/2020/09/17/composite_pattern/">组合模式</a></li><li><a href="/2020/09/04/bridge_patterns/">桥接模式</a></li><li><a href="/2020/08/22/adapter_pattern">适配器模式</a></li><li><a href="/2020/08/16/facade_pattern/">外观模式</a></li><li><a href="/2020/09/17/flyweight_pattern/">享元模式</a></li></ol><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>这一类设计模式的目的是更好地实现类与类之间的交互还有算法的执行。包括：  </p><ol><li><a href="/2020/08/27/strategy_pattern/">策略模式</a></li><li><a href="/2020/08/17/command_pattern/">命令模式</a></li><li><a href="/2020/09/06/state_pattern/">状态模式</a></li><li><a href="/2020/09/05/chain_of_responsibility_pattern/">责任链模式</a></li><li><a href="/2020/09/05/interpreter_pattern">解释器模式</a></li><li><a href="/2020/08/08/observer/">观察者模式</a></li><li><a href="/2020/09/06/memento_pattern">备忘录模式</a></li><li><a href="/2020/08/27/iterator_pattern/">迭代器模式</a></li><li><a href="/2020/09/08/template_method_pattern/">模板方法模式</a></li><li><a href="/2020/09/08/visitor_pattern/">访问者模式</a></li><li><a href="/2020/08/12/mediator_pattern/">中介者模式</a></li></ol><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>以上就是全部设计的种类。因为随着不断进步，设计模式远不止这一些，但掌握这些设计模式在日常编程中就可以有效保证代码的健康。<br>算是挖了一个新的大坑吧，之后会陆陆续续写写这23种设计模式的理解与实现。<br>2020.08.07 单例模式<br>2020.08.08 观察者模式<br>2020.08.10 代理模式<br>2020.08.12 工厂方法模式,中介者模式<br>2020.08.13 抽象工厂模式<br>2020.08.16 外观模式<br>2020.08.17 命令模式,装饰器模式<br>2020.08.22 适配器模式<br>2020.08.27 策略模式,迭代器模式<br>2020.09.02 原型模式<br>2020.09.04 桥接模式<br>2020.09.05 责任链模式,解释器模式<br>2020.09.06 状态模式,备忘录模式<br>2020.09.08 模板方法模式,访问者模式<br>2020.09.14 构建模式<br>2020.09.17 享元模式,组合模式  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;设计模式是提高代码可读性的途径之一，面对不同的场景选择不同的设计模式，可以提高代码可读性，提高代码的可重用性还有可扩展性。接下来就讲讲什么是
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之组合模式</title>
    <link href="http://re0.top/2020/09/17/composite_pattern/"/>
    <id>http://re0.top/2020/09/17/composite_pattern/</id>
    <published>2020-09-17T08:00:00.000Z</published>
    <updated>2020-09-17T08:34:07.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇是23种设计模式的最后一篇了，不知不觉整理了一个月，其实应该快点整理完，每天一到两篇文章虽然量不多，但是写的时候其实挺累人。言归正传，本文来讲最后一种设计模式，组合模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>组合模式又称部分整体模式，它属于结构型模式，通常适用于有结构的系统，用于表示部分与整体层次。顺带一提，这里的有结构一般是树形结构。<br>那这个模式他模糊了简单元素与复杂元素的概念，可以统一使用同一个对象来进行操作。<br>那常见的场景有，上下级关系的构建，或者是文件系统的构建。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>那我们就来简单实现一个文件系统，我们知道一般文件系统包括普通文件和文件夹，但是学过操作系统后我们知道，文件夹其实是一种特殊的文件，在标志处不一样而已。那我们就来实现这个系统。<br>首先我们创建抽象类File<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>这里的display方法如果是文件夹是显示它所有文件，如果是文件则打印文件名。<br>接着我们创建Folder。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Folder</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;File&gt; fileList;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Folder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        fileList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (File file : fileList)&#123;</span><br><span class="line">            file.display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        fileList.add(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        fileList.remove(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>接着我们创建两种类型的文件，文本文件和图片文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFile</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"文本文件，文件名为："</span> + <span class="keyword">super</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageFile</span> <span class="keyword">extends</span> <span class="title">File</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"图片文件，文件名为："</span> + <span class="keyword">super</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>最后我们创建客户端调用试试，我们创建一个这样的文件系统，有一个文件夹all，包含1.txt，1.jpg，还有一个文件夹1；然后文件夹1中还有2.txt和2.jpg。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Folder all = <span class="keyword">new</span> Folder(<span class="string">"all"</span>);</span><br><span class="line">        File txt1 = <span class="keyword">new</span> TextFile(<span class="string">"1.txt"</span>);</span><br><span class="line">        File txt2 = <span class="keyword">new</span> TextFile(<span class="string">"2.txt"</span>);</span><br><span class="line"></span><br><span class="line">        File jpg1 = <span class="keyword">new</span> ImageFile(<span class="string">"1.jpg"</span>);</span><br><span class="line">        File jpg2 = <span class="keyword">new</span> ImageFile(<span class="string">"2.jpg"</span>);</span><br><span class="line"></span><br><span class="line">        Folder folder1 = <span class="keyword">new</span> Folder(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        all.add(txt1);</span><br><span class="line">        all.add(jpg1);</span><br><span class="line">        all.add(folder1);</span><br><span class="line"></span><br><span class="line">        folder1.add(txt2);</span><br><span class="line">        folder1.add(jpg2);</span><br><span class="line"></span><br><span class="line">        all.display();</span><br><span class="line">        folder1.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  </p><p>那这里就有个问题，就是总文件夹中打印文件名时，会把子文件夹中的一并打印出来，那么这时候我们可以在抽象类中设置一个type属性，依照参数，比如-r表示是否递归，来判断是否递归打印。通过判断type来实现，这里就不实现了，感兴趣的可以自行实现。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>那组合模式的优点是可以定义一些分层次的对象，添加组件也很简单。其次就是客户端调用简单。最后就是符合开闭原则，添加新的组件不用修改原有代码。<br>那缺点在于整个系统会变得抽象，维护成本增加，其次就是违反依赖导致原则，就像上文的例子一样，客户端要创建文件夹时，需要依赖的是Folder实现类，而不是File抽象类。  </p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>那设计模式这个系列到这里基本上是告一段落了，前前后后整理这个系列花了一个多月的时间，那接下来可能还是会写一些自己感兴趣的话题或者技术，有时间的话博客还是会坚持写下去的。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这篇是23种设计模式的最后一篇了，不知不觉整理了一个月，其实应该快点整理完，每天一到两篇文章虽然量不多，但是写的时候其实挺累人。言归正传，本
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之享元模式</title>
    <link href="http://re0.top/2020/09/17/flyweight_pattern/"/>
    <id>http://re0.top/2020/09/17/flyweight_pattern/</id>
    <published>2020-09-17T07:00:00.000Z</published>
    <updated>2020-09-17T07:42:35.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文谈谈享元模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>享元模式属于结构型模式，它主要是缓存重复的对象，以减少内存的消耗，这些相同的对象往往需要重复的使用，如果不对其进行缓存，可能会导致内存溢出。那享元模式一般配合工厂模式一起使用。<br>常见的应用场景有Java中的String，在创建String时判断缓存池里是否有这个字符串，有的话直接返回，没有才进行创建。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>享元模式中有以下几个角色：</p><ul><li>抽象享元类（Flyweight）：接口或者抽象类，声明公共方法。</li><li>具体享元类（ConcreteFlyweight）：实现抽象享元类，结合单例模式提供唯一的对象。 </li><li>享元工厂类（FlyweightFactory）：用来创建及管理享元对象，可以参考工厂模式。  </li></ul><p>这里我们举个简单例子，一般商店里的物品不止一样，那么我们可以把同一个名称的商品作为共享的。<br>我们创建抽象接口FlyWeight<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyWeight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>接着我们可以创建商品类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">implements</span> <span class="title">FlyWeight</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"卖出一件商品: "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>创建工厂类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWeightFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Item&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">getItem</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        Item item = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(name))&#123;</span><br><span class="line">            item = map.get(name);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            item = <span class="keyword">new</span> Item(name);</span><br><span class="line">            map.put(name,item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>那么客户端调用也很简单，商品从工厂类中获取即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FlyWeightFactory flyWeightFactory = <span class="keyword">new</span> FlyWeightFactory();</span><br><span class="line">        Item milk1 = flyWeightFactory.getItem(<span class="string">"牛奶"</span>);</span><br><span class="line">        Item milk2 = flyWeightFactory.getItem(<span class="string">"牛奶"</span>);</span><br><span class="line">        System.out.println(milk1 == milk2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        milk1.sell();</span><br><span class="line">        milk2.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>那以上例子还可以继续细化，比如Item类作为抽象类，而具体商品则继承它，那具体商品就可以有更多的属性，比如价格，批次等等。那在工厂类添加的时候可能需要根据传入名称来创建类，具体可以使用反射机制，这里就不再展开。<br>总而言之，享元模式中共享的对象是同一个，实现这个模式常常结合工厂模式，单例模式来使用，需要注意的是在多线程中需要使用线程安全的容器来存储对象。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>享元模式优点很明显，可以减少重复对象的创建，减低内存使用率。<br>那缺点可能就是需要区分外部状态与内部状态，内部状态不随环境改变，可共享，外部状态岁环境改变，不能共享。也就是上文例子中name作为外部状态可改变，如果再添加一个无法更改的属性比如价格，那么就是内部状态，无法被更改。<br>所以享元模式一定程度上增加了系统的复杂性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文谈谈享元模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之构建模式</title>
    <link href="http://re0.top/2020/09/14/builder_pattern/"/>
    <id>http://re0.top/2020/09/14/builder_pattern/</id>
    <published>2020-09-14T07:00:00.000Z</published>
    <updated>2020-09-14T08:29:53.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>构建模式又称建造模式，建造者模式等等。<br>本篇来简单谈谈这种设计模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>构建模式(Builder Pattern)，由于存在多种叫法，为了统一名称，统一写作Builder模式。它属于创建型模式，是使用一个个对象构建复杂对象的设计模式。<br>它的意图在于拆分复杂对象，使得可以由子对象生成，子对象相对稳定，通过组合子对象来构造复杂对象。<br>那使用的场景通常是对象的内部结构较为复杂或者内部属性相互依赖。<br>那Java中常见的就是各种Builder，例如StringBuilder。<br>那项目中何时使用这种设计模式呢？通常来说，当类的构造函数非常多时(大于4个)可以改用Builder模式来创建对象。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>先来讲讲Builder模式中的几个角色：</p><ul><li>Builder角色：一个接口，规范产品对象中各个子对象的构建。</li><li>ConcreteBuilder：具体的实现类，提供产品的实例。</li><li>Director：负责调用具体的ConcreteBuilder来创建对象。</li><li>Product：即我们需要构建的复杂对象。  </li></ul><p>我们就用这几个角色来写写基础的Builder模式。<br>首先我们定义我们的Product对象中，有两个string担任它的子对象。那我们可以写出代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>首先这个类并没有构造器，而是采用javabean的方式来设置对象，这有利于我们使用builder来创建这个对象。<br>接着我们写抽象的Builder接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildId</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>这个接口中有两个方法用来创建product对象中的子对象。而第三个方法则是来获取一个创建完成的product对象。<br>接着是ConcreteBuilder<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setId(<span class="string">"01"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setName(<span class="string">"产品1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着是导演类，用来引导ConcreteBuilder创建对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        builder.buildId();</span><br><span class="line">        builder.buildName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>我们通过把builder传递给导演类，然后调用导演类的construct方法，就可以创建一个product对象到builder对象中，获取就可以得到这个product对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        director.construct();</span><br><span class="line">        Product product = builder.getProduct();</span><br><span class="line"></span><br><span class="line">        System.out.println(product.getId());</span><br><span class="line">        System.out.println(product.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>如此我们便简单实现了Builder模式。<br>那实际场景中哪里使用到了Builder模式呢？<br>MyBatis中就大量使用了这个模式。原生的mybatis(不整合spring)在SqlSessionFactory中使用了XMLConfigBuilder，得益于builder模式，mybatis隐藏了解析XML文件的细节，我们只需要少量的基本参数(比如地址，账号密码等)，就可以使用。其他参数根据用户是否提供，如果没有就使用默认参数。因此mybatis使用成本大大降低。</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>所以当我们在编写复杂类，或者是一个大型框架时，可以采用Builder模式，将大量参数通过这个模式来创建对象，而不是使用构造函数来创建。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>那Builder模式的优点在于可以精确控制产品的创建，开发者可以根据需要创建出想要的对象。其次，客户端可以不知道产品内部实现细节，结果与过程解耦。最后添加新的Builder无需修改原有代码，Director是针对Builder进行编程的，所以方便系统扩展，符合开闭原则。<br>那缺点就是产品之间需要有共同点，有所限制。其次就是如果内部复杂，会导致Builder过多，系统臃肿。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;构建模式又称建造模式，建造者模式等等。&lt;br&gt;本篇来简单谈谈这种设计模式。  &lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; 
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList扩容之后内存地址会发生改变吗？</title>
    <link href="http://re0.top/2020/09/13/arraylist_resize/"/>
    <id>http://re0.top/2020/09/13/arraylist_resize/</id>
    <published>2020-09-13T06:20:00.000Z</published>
    <updated>2020-09-13T08:01:20.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>那标题的这个内容，是我在面试时候的一道问题。那这篇文章我们来讲讲ArrayList的扩充机制以及扩容之后会发生什么样的改变。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>首先使用过Java的基本上都用过ArrayList，那它是一个数组队列，其实现了List接口，那ArrayList的底层是一个动态数组。我们来看看默认的构造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><p>这里的源码基于JDK1.8，那其他的源码这里就不贴了，我直接进行总结：</p><ul><li>ArrayList内部有一个数组，使用默认的构造函数时，默认容量为0。而在1.6以前，默认容量为10.</li><li>当第一次插入元素时，容量分配10，之后会以1.5倍的增长。</li></ul><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>还是简单写写ArrayList的扩容机制。首先默认的构造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><p>我们可以知道默认的容量是0。那扩容机制一定会发生在add操作中，我们查看add方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><p>ensureCapacityInternal是确保内部容量，也就是确保数组容量应该是现有数据数量加上1。接着跟进<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><p>那这里就很明朗，calculateCapacity通过传入的需要容量与当前数组容量，计算出需要的最小容量，其中如果数组为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，那么就返回DEFAULT_CAPACITY与需要容量的最大值，DEFAULT_CAPACITY为10。<br>因此当第一次扩容时，容量被设置为10，其余情况最小容量都为传入的所需容量。<br>接着是ensureExplicitCapacity方法，当最小容量大于当前数组长度时，进行扩容操作，即grow方法，我们接着跟进：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><p>首先新容量的计算方式为oldCapacity + (oldCapacity &gt;&gt; 1)，那么相当于oldCapacity + 0.5 * oldCapacity，即1.5倍的原容量，而采用位运算则更快。其次这里判断了元素的最大个数，源码里的注释解释道，原因是因为jvm允许数组的最大大小为Integer.MAX_VALUE - 8，超过这个值会OutOfMemory，因此MAX_ARRAY_SIZE设置为Integer.MAX_VALUE - 8避免溢出。<br>最后是调用Arrays.copyOf方法来获得一个新的数组，而copyOf方法是调用System.arraycopy方法，这个方法是个native方法，就不是我们所关心的内容了。<br>至此，扩容的机制就是如果是默认构造器初始化，则设置当前容量为10，当所需容量大于10时，会进行1.5倍的扩容，以此类推。</p><h2 id="ArrayList对象分配在哪"><a href="#ArrayList对象分配在哪" class="headerlink" title="ArrayList对象分配在哪?"></a>ArrayList对象分配在哪?</h2><p>首先ArrayList是new出来的，那么毫无疑问，它存放在堆中，而变量存放在栈中，指向堆中的对象。就比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure> </p><p>其中list变量在栈中，指向堆中的某个ArrayList实例对象。<br>那数组也不例外，因为数组也是个对象，所以内部的elementData也存放在堆当中。  </p><h2 id="那扩容之后的地址改变吗"><a href="#那扩容之后的地址改变吗" class="headerlink" title="那扩容之后的地址改变吗?"></a>那扩容之后的地址改变吗?</h2><p>这就是标题所提到的问题，先说结论，肯定是不变的。我们先来做个试验：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>通过对add下断点，我们可以发现list的id是不变的，因此内存当中的地址是不改变的。通过步入调试，可以发现elementData的id发生了改变，因为我们可以得出结论，ArrayList扩容之后地址不会发生改变，发生改变的是内部数组的内存地址。<br>那为什么不变呢？根本原因在于list变量所指向的对象是同一个，很好理解，尽管实例内部的elementData一直在改变，但实例中只是某个变量的指向不断在改变而已，并没有重新分配内存，只有当内部方法重新new本类时，list所指向的内存地址才会发生改变。<br>因此，<strong>大部分通过内部变量引用机制进行扩容的容器并不会改变自身的内存地址</strong>。<br>但一些基础容器，例如数组，通过Arrays.copyOf方法进行扩容时，因为数组内存是有序的，所以需要重新分配内存，导致地址发生改变。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇谈了谈ArrayList的扩容机制以及扩容之后地址的改变情况。那相似的问题，比如hashmap扩容等等我们都知道了，因为其内部有引用，所以只是内部变量的地址发生改变，其本身的内存地址不发生改变，对象还是同一个。<br>那以上就是这篇文章的内容，如有问题，望指出。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;那标题的这个内容，是我在面试时候的一道问题。那这篇文章我们来讲讲ArrayList的扩充机制以及扩容之后会发生什么样的改变。&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://re0.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java内存模型</title>
    <link href="http://re0.top/2020/09/13/jmm/"/>
    <id>http://re0.top/2020/09/13/jmm/</id>
    <published>2020-09-13T05:00:00.000Z</published>
    <updated>2020-09-13T06:25:32.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想写一篇文章，由于涉及到Java内存的知识，就先来写写前置知识。那本篇就来说说JVM的基础，Java内存区域与Java内存模式（JMM）。<br>ps. 本篇基本上想到哪里说到哪里，并无什么先后顺序。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p>那我相信学习过JVM的同学基本上都知道JVM将运行时内存划分为几个区域。总体上可以分为两类：线程共享区域与线程私有区域。<br>其中线程共享区域分为方法区和堆。线程私有区域有虚拟机栈，本地方法栈还有程序计数器。</p><h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>方法区中主要用于存储已经被虚拟机加载的类信息，常量还有一些静态变量。注意，方法区中有一个运行时常量池，用于存储编译器生成的各种字面量与符号引用，加载过后存放在此。</p><h3 id="堆（Java-Heap）"><a href="#堆（Java-Heap）" class="headerlink" title="堆（Java Heap）"></a>堆（Java Heap）</h3><p>这个区域是我们常见的区域，主要是存放对象实例，几乎所有的对象实例都在这里分配内存，也是GC的主要区域。</p><h3 id="虚拟机栈（JVM-Stacks）"><a href="#虚拟机栈（JVM-Stacks）" class="headerlink" title="虚拟机栈（JVM Stacks）"></a>虚拟机栈（JVM Stacks）</h3><p>是线程私有的区域，与线程同时创建，每一个方法执行的时候都会创建一个叫做栈帧的东西来存储方法的变量表，动态链接方法，返回值等等信息，并存放在栈中，调用方法就是入栈，而调用结束就是出栈操作。 </p><h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><p>在操作系统中我们也学习过这个概念。主要是代表当前线程所执行的字节码行号的指示器。运行代码时，通过改变计数器的值来选取下一条需要执行的字节码指令。</p><h3 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h3><p>主要是用到的Native方法相关的信息，一般来说无需关心。</p><h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p>那由于JVM运行程序是以线程为单位，所以每个线程创建的时候JVM会为其创建一个工作内存，用于存储变量私有的数据，而JMM规定所有变量都存储在主内存，主内存是共享的，所有线程都能访问，因此对变量的操作是这样的，首先从主内存中拷贝变量到工作内存中，修改变量完成后再写回主内存中。所以线程共享的变量必须通过主内存来完成。  </p><h2 id="Java内存区域与JMM"><a href="#Java内存区域与JMM" class="headerlink" title="Java内存区域与JMM"></a>Java内存区域与JMM</h2><p>这两个是不同的概念，JMM是一组规则，控制程序中各个变量在共享区域与私有区域的访问方式。他们的相似点在于都存在共享区域与私有区域，JMM中主内存属于共享区域，从内存模型来讲应该包括了方法区与堆，私有区域同理。</p><h2 id="JMM如何保证原子性，可见性，有序性"><a href="#JMM如何保证原子性，可见性，有序性" class="headerlink" title="JMM如何保证原子性，可见性，有序性"></a>JMM如何保证原子性，可见性，有序性</h2><p>那在Java当中我们要保证原子性可以使用锁来实现，工作内存与主内存的可见性可以使用synchronized关键字或者volatile关键字，而因为指令重排导致的有序性问题可以使用volatile关键字。<br>那仅靠synchronized和volatile关键字会使得代码变得十分繁琐。因此JMM还提供一个叫做happens-before的原则来保证三性。规则的内容如下：</p><ul><li>程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</li><li>锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。</li><li>volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。</li><li>线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见</li><li>传递性 A先于B ，B先于C 那么A必然先于C</li><li>线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。</li><li>线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</li><li>对象终结规则 对象的构造函数执行，结束先于finalize()方法</li></ul><p>以上八条原则使得某些情况下需要任何同步就可达到预期效果。</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>被volatile所修饰的变量对所有线程都是可见的，即对该变量的写操作都能立即反应到其他工作内存中。但这个关键字并不保证操作的原子性。因为对变量的修改往往需要两个步骤，读与更新，如果不能保证这个两个操作是同时进行，那么线程就是不安全的。<br>那volatile关键字的工作原理又是什么？其实就是线程在写一个volatile变量时，会把线程所对应的工作内存设置为无效的，那该线程只能从主内存中重新读取变量。其次就是禁止指令重排，之前在写单例模式的时候也提到过，对实例的赋值其实并不是我们预想的那样，例如<code>instance = new A();</code>，我们期待是先分配内存，然后初始化对象，最后进行赋值，那JVM可能会将该代码指令进行重排序，即先分配空间，然后赋值，最后再初始化对象。<br>那在单线程中是完全ok的，没什么影响，那在多线程中就可能出现一致性问题，也就是出现了线程安全问题。那禁止指令的重排，我们就可以使用volatile关键字来解决。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇主要是简单讲讲Java的内存区域与内存模型(JMM)，其中我们需要知道JMM其实就是一组规则，意图是解决并发编程中出现的线程安全问题，它提供了happen-before原则，并且我们还可以使用synchronized或volatile，来帮助我们实现多线程环境下的原子性，可见性，有序性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;想写一篇文章，由于涉及到Java内存的知识，就先来写写前置知识。那本篇就来说说JVM的基础，Java内存区域与Java内存模式（JMM）。&lt;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://re0.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之访问者模式</title>
    <link href="http://re0.top/2020/09/08/visitor_pattern/"/>
    <id>http://re0.top/2020/09/08/visitor_pattern/</id>
    <published>2020-09-08T07:00:00.000Z</published>
    <updated>2020-09-08T08:02:10.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇来讲讲行为型模式的最后一篇，访问者模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>访问者模式，我们使用一个访问者类来访问数据对象，通常是为了不污染数据对象类，而实现的关键是在数据对象类中提供一个接待访问者的接口。<br>那这种设计模式了除了不污染原类，很大一部分原因是为了将数据结构与操作相分离。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>由于这种设计模式在开发中很少用，一般是在框架或者源码中才会使用到。所以这里我就简单实现一下概念。<br>首先访问者模式中有几个角色：</p><ul><li>Visitor（抽象访问者）：抽象类或接口，对每一种具体元素类ConcreteElement声明一个操作方法，由具体访问者去实现。  </li><li>ConcreteVisitor（具体访问者）：实现抽象访问者的方法。</li><li>Element（抽象元素）：一般会定义一个Accept方法，接受一个visitor对象作为参数。</li><li>ConcreteElement（具体元素）：具体实现抽象元素。</li><li>ObjectStructure（对象结构）：可以是任意一种数据结构，能枚举它包含的元素，并提供一个接口，允许visitor进行访问。  </li></ul><p>下面我将简单写写代码实现。<br>首先我们先定义抽象访问者吧。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>然后是具体访问者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorA</span> <span class="keyword">implements</span> <span class="title">Visitor</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问 ElementA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问 ElementB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着定义抽象元素，有一个accept方法接收一个visitor对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>然后是具体元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title">Element</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>我们定义一个对象结构来存放所有的元素，并且定义accept方法来逐个访问元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Element element: elements)&#123;</span><br><span class="line">            element.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(Element element)</span></span>&#123;</span><br><span class="line">        elements.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(Element element)</span></span>&#123;</span><br><span class="line">        elements.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>我们编写客户端调用试试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义元素及访问者</span></span><br><span class="line">        Element elementA = <span class="keyword">new</span> ConcreteElementA();</span><br><span class="line">        Element elementB = <span class="keyword">new</span> ConcreteElementB();</span><br><span class="line">        Visitor visitor = <span class="keyword">new</span> ConcreteVisitorA();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单个元素访问</span></span><br><span class="line">        elementA.accept(visitor);</span><br><span class="line">        elementB.accept(visitor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多个元素访问</span></span><br><span class="line">        ObjectStructure objectStructure = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line">        objectStructure.addElement(elementA);</span><br><span class="line">        objectStructure.addElement(elementB);</span><br><span class="line">        objectStructure.accept(visitor);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>那所以是否定义ObjectStructure取决于你是否需要同时访问多个元素。<br>书写代码之后，我第一感觉就是耦合较高，访问者与元素之间相互依赖极高。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>访问者模式的优点在于添加新的访问操作较为方便，无需修改元素类，修改抽象访问者及其具体访问者即可，并且类的职责更加清晰，元素类负责数据，而访问者负责访问，符合单一职责原则。<br>而缺点就是添加元素类就十分麻烦，添加一个元素类后，需要修改每个访问者的代码，违背了开闭原则。并且在依赖上，具体访问者依赖于具体元素类，没有依赖抽象对象。最后，为了供访问者访问，有时候元素类不得不暴露己类的某些细节，封装性被破坏。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇来讲讲行为型模式的最后一篇，访问者模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之模板方法模式</title>
    <link href="http://re0.top/2020/09/08/template_method_pattern/"/>
    <id>http://re0.top/2020/09/08/template_method_pattern/</id>
    <published>2020-09-08T06:00:00.000Z</published>
    <updated>2020-09-08T08:03:08.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇聊聊模板方法模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>模板方法模式属于行为型模式，它定义一个模板结构，然后让其子类去实现。其主要作用是提高代码的复用性，并且在不改变模板的情况下子类能重写方法。<br>那这种设计模式就十分常见了，在父类中定义执行顺序，子类再去具体的去实现，这就是模板方法模式。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>举个例子，比如我们平常去超市买东西，基本上分为几个步骤，拿购物车或篮子，挑选商品，结算。那就用这个例子来写写代码。  </p><h2 id="未使用模板方法模式"><a href="#未使用模板方法模式" class="headerlink" title="未使用模板方法模式"></a>未使用模板方法模式</h2><p>首先我们一般来说我们是先定义一个父类，然后子类再去实现父类方法。也就是<strong>没使用模板方法模式</strong>时，我们可能会这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿购物车</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getShoppingCart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挑选商品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">selectGoods</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全流程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>那在子类当中，我们可能这么写<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingByOnlinePay</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getShoppingCart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取购物车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectGoods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"挑选商品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用网上支付"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getShoppingCart();</span><br><span class="line">        selectGoods();</span><br><span class="line">        pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>那这样写就是在抽象类中不写任何逻辑，所有的实现都在子类中实现，如果后续有问题也较好发现，但我们可以发现，其实shopping方法是固定的，也就是流程固定，那么我们这些代码是不是可以移动到抽象类中呢？是的，可以，这就是模板方法模式。</p><h2 id="使用模板方法"><a href="#使用模板方法" class="headerlink" title="使用模板方法"></a>使用模板方法</h2><p>我们重写下抽象类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿购物车</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getShoppingCart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挑选商品</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">selectGoods</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结算</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全流程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">shopping</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getShoppingCart();</span><br><span class="line">        <span class="keyword">this</span>.selectGoods();</span><br><span class="line">        <span class="keyword">this</span>.pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>我们将子类需要重写的方法定义为protected，因为这些方法不需要暴露给其他类，只需要子类自己实现即可，然后我们把购物流程在抽象类中以final修饰，因为流程固定不需要修改。<br>我们接着写现金付款和网上支付两种结算方式的类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingByOnlinePay</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">getShoppingCart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取购物车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">selectGoods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"挑选商品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用网上支付"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingByCash</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">getShoppingCart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"获取购物车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">selectGoods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"挑选商品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用现金结算"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>那这里调用就很简单，我就不写了，直接调用shopping方法即可。<br>如此，我们就使用模板方法模式实现了这个简单的例子。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>模板方法模式具有良好的封装性，即把一成不变的代码封装在父类当中，而子类去实现基本方法的逻辑，并且扩展性良好，符合开闭原则和单一职责原则。那最重要的还是复用了重复代码。<br>那缺点嘛，可能就是实现类都需要单独的子类去实现，可能会增加类的数量，但我个人认为这个其实严格来说不能说是缺点，除非是实现的种类存在几十种上百种。当然，仁者见仁智者见智，算不算缺点只有在用到的时候才能知道。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇聊聊模板方法模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之备忘录模式</title>
    <link href="http://re0.top/2020/09/06/memento_pattern/"/>
    <id>http://re0.top/2020/09/06/memento_pattern/</id>
    <published>2020-09-06T07:00:00.000Z</published>
    <updated>2020-09-06T07:58:33.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇来谈谈备忘录模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>备忘录模式保存对象的某个状态，以便当需要时恢复这个状态，它属于行为型模式。<br>它又称快照模式或token模式。它的意图是在不破坏封装的条件下，将对象的状态保存下来，并存储，并且可以在未来的某个时刻恢复。<br>这个模式涉及三个角色：</p><ul><li>备忘录(Memento)：将发起人对象的内部状态存储起来，并且可以保护不被发起人以外的对象所读取。</li><li>发起人(Originator)：创建一个含有内部状态的备忘录对象，并存储自己的内部状态。</li><li>负责人(Caretaker)：负责保存备忘录对象，不检查备忘录对象的内容。 </li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们先创建备忘录(Memento)，这里对象的内部状态我们使用string来表示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>创建发起人(Originator)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">savaStateToMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>创建负责人(Caretaker)，负责保存备忘录对象，这里用list存储一系列状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">retrieveMemento</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveMemento</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        mementoList.add(memento);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>创建客户端，并设置一下状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">        Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line"></span><br><span class="line">        originator.setState(<span class="string">"state 1"</span>);</span><br><span class="line">        caretaker.saveMemento(originator.savaStateToMemento());</span><br><span class="line"></span><br><span class="line">        originator.setState(<span class="string">"state 2"</span>);</span><br><span class="line">        caretaker.saveMemento(originator.savaStateToMemento());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        originator.getStateFromMemento(caretaker.retrieveMemento(<span class="number">0</span>));</span><br><span class="line">        System.out.println(originator.getState());</span><br><span class="line"></span><br><span class="line">        originator.getStateFromMemento(caretaker.retrieveMemento(<span class="number">1</span>));</span><br><span class="line">        System.out.println(originator.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>这里我们设置两个状态，并拍摄快照，最后依次恢复快照查看状态。  </p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>上文也提过，这个模式适合拍摄快照，例如游戏存档，可以将玩家的某个状态存储，并适时的时候恢复。还有就是提供可回滚的操作，等等。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>那备忘录模式的优点是给用户提供了一种可恢复的机制，可以较为方便地回到某个时间点。其次就是调用者无需关心如何保存状态。<br>那缺点也很明显，就是占用内存或空间，如果类的状态和变量过多，则会消耗一定的资源。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇来谈谈备忘录模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之状态模式</title>
    <link href="http://re0.top/2020/09/06/state_pattern/"/>
    <id>http://re0.top/2020/09/06/state_pattern/</id>
    <published>2020-09-06T07:00:00.000Z</published>
    <updated>2020-09-06T07:32:06.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇来谈谈状态模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>状态模式属于行为型模式，在这个模式中类的行为是根据类的状态发生改变的。在类中维护一个状态变量，当其改变时类的行为就发生改变，看上去就跟改变了类本身一样。<br>那状态模式涉及的角色有：  </p><ul><li>环境(context)：上下文，通常定义客户端可用的接口，内部维护一个状态实例，根据这个状态做出不一样的行为。</li><li>抽象状态(state)：一个接口，用于封装环境(context)对象的状态</li><li>具体状态(concreteState)：实现抽象状态。</li></ul><p>那这个模式常见的场景就是可以替代条件语句，if，switch等等，避免语句过长。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这个模式还是比较简单的，我们就写写上面提到的几个角色<br>我们先定义state接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>然后是具体的state<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateA</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对应StateA的操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateB</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对应StateB的操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>然后定义环境，用于客户端的调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用户需要的接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state.handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>最后编写客户端调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        State stateA = <span class="keyword">new</span> ConcreteStateA();</span><br><span class="line">        State stateB = <span class="keyword">new</span> ConcreteStateB();</span><br><span class="line"></span><br><span class="line">        context.setState(stateA);</span><br><span class="line">        context.request();</span><br><span class="line"></span><br><span class="line">        context.setState(stateB);</span><br><span class="line">        context.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>可以发现，通过设置context的状态可以实现不同的操作。看上去就像context对象本身发生改变一样。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>最后来讲讲优缺点。<br>状态模式的优点有，把实现的细节隐藏，客户端只需要设置状态，无需关心内部的实现，并且可以去除大量的逻辑判断语句，可读性更高。<br>而缺点在于当状态增多时，类的数量会增加，并且当增加新的状态类时，context可能会做出修改，不符合开闭原则。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇来谈谈状态模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之解释器模式</title>
    <link href="http://re0.top/2020/09/05/interpreter_pattern/"/>
    <id>http://re0.top/2020/09/05/interpreter_pattern/</id>
    <published>2020-09-05T08:00:00.000Z</published>
    <updated>2020-09-05T08:49:42.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接下来讲讲解释器模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>解释器模式属于行为型模式。它实现了一个表达式的接口，用于解释上下文。比如正则表达式解析，SQL解析等等。<br>这种模式应用上较少，那在框架上用的还是比较多的，比如上文提到了正则表达式，还有XML解析，SQL解析等等都有着应用。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>那我们就用一个简单的例子来实现这个模式。<br>先来讲讲解释器模式中的几个角色：  </p><ul><li>抽象表达式(AbstractExpression)：是所有终结符表达式和非终结符表达式的公共父类。</li><li>终结符表达式(TerminalExpression)：指的是与终结符相关的表达式。</li><li>非终结符表达式(NonterminalExpression)：即没有终结符的表达式，通常一个解释器模式中，由少数几个终结符表达式与非终结符表达式构成。</li><li>Context：上下文，一般是存储需要解释的语句。  </li></ul><p>比如我要实现一个简易的计算器。<br>那我们先定义抽象表达式接口Interpreter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interpreter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>然后定义非终结符表达式，这里就是解析数字<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberInterpreter</span> <span class="keyword">implements</span> <span class="title">Interpreter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberInterpreter</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberInterpreter</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = Integer.parseInt(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>然后是终结符表达式，这里就是运算符<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddInterpreter</span> <span class="keyword">implements</span> <span class="title">Interpreter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Interpreter first,second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddInterpreter</span><span class="params">(Interpreter first, Interpreter second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"+"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first.interpret() + second.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>我们直接写一个客户端调用一下试试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String express = <span class="string">"2 + 3"</span>;</span><br><span class="line">        String[] keyWords = express.split(<span class="string">" "</span>);</span><br><span class="line">        String operator = <span class="string">"+"</span>;</span><br><span class="line">        Interpreter[] nums = <span class="keyword">new</span> Interpreter[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String keyword : keyWords)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = Integer.parseInt(keyword);</span><br><span class="line">                nums[index++] = <span class="keyword">new</span> NumberInterpreter(tmp);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                operator = keyword;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (operator.equals(<span class="string">"+"</span>))&#123;</span><br><span class="line">            Interpreter add = <span class="keyword">new</span> AddInterpreter(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">            System.out.println(add.interpret());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>我们就简单实现了加法运算，那值得注意的有以下几点：</p><ul><li>在main方法中的解析应该转移到工具类当中，客户端应该直接调用工具类。</li><li>既然符号是终结符表达式，那么以上的express应该改为后缀表达式”2 3 +”，然后通过栈来求整个表达式的值。</li></ul><p>那么以上几点就是我的修改建议，感兴趣的朋友可以接着写下去，实现其他运算，加上工具类的封装。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>解释器模式的优点在于可扩展性良好，并且十分灵活，当我们新增一个表达式时，原有代码无需修改。<br>那缺点在于如果语法过于复杂，解析起来会十分麻烦，类的数量会急剧增加，导致难以维护。其次由于解释器模式使用了大量的循环和递归，当面对较复杂语句时执行速度会受到影响。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解释器模式为语言的设计和实现提供了一种解决方案，通过定义表达式来解析语言中的语句，在项目中的使用频率不是很高，但如要实现一门语言或者解析语句，那这个模式就应用的很广泛。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;接下来讲讲解释器模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之责任链模式</title>
    <link href="http://re0.top/2020/09/05/chain_of_responsibility_pattern/"/>
    <id>http://re0.top/2020/09/05/chain_of_responsibility_pattern/</id>
    <published>2020-09-05T07:00:00.000Z</published>
    <updated>2020-09-05T07:41:39.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文来谈谈责任链模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>责任链模式属于行为型模式。正如名字所说一样，对象是一个链式的结构，当请求到达对象时，如果第一个对象不能处理这个请求，则将请求传递给下一个对象，以此类推。<br>责任链可以是直线型，也可以是环形，又或者是树形。那这种设计模式简化了请求传递的复杂度，请求只要传递给责任链上，并且无需关心如何处理请求，所以责任链模式将请求者与接受者解耦了。<br>那我们常见的场景有：</p><ul><li>js中的事件冒泡，事件会依次向上传递。</li><li>jvm中的类加载机制也是责任链模式，但会一直指派到最顶级的类加载。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>责任链模式中有两个角色：</p><ul><li>抽象处理者(Handler)：抽象对象或者接口。定义一个处理请求的接口。</li><li>具体处理者(ConcreteHandler)：具体的请求处理者，接收请求后选择是否处理请求，如不处理，则传递给下一位。  </li></ul><p>我们先用简单的例子：<br>首先创建handler：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下一个处理者</span></span><br><span class="line">    <span class="keyword">protected</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getNextHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextHandler</span><span class="params">(Handler nextHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handlerRequest</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>随后我们创建具体的处理者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandlerA</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRequest</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"A"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"handler A 处理请求"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getNextHandler() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"handler A 无法处理请求，转交给下一个handler"</span>);</span><br><span class="line">            getNextHandler().handlerRequest(name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"所有handler都无法处理请求"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandlerB</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRequest</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"B"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"handler B 处理请求"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getNextHandler() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"handler B 无法处理请求，转交给下一个handler"</span>);</span><br><span class="line">            getNextHandler().handlerRequest(name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"所有handler都无法处理请求"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>这里我们重写handlerRequest方法，当这个具体处理者可以处理请求时，直接处理请求，不能处理时，我们传给责任链中下一个处理者，如果没有下一个处理者就退出。<br>最后是客户端，其中客户端中我们需要显式地构建责任链。我们编写客户端试试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Handler handlerA = <span class="keyword">new</span> ConcreteHandlerA();</span><br><span class="line">        Handler handlerB = <span class="keyword">new</span> ConcreteHandlerB();</span><br><span class="line"></span><br><span class="line">        handlerA.setNextHandler(handlerB);</span><br><span class="line"></span><br><span class="line">        handlerA.handlerRequest(<span class="string">"C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>这里我们将handlerA 的下一个责任链对象设置为handlerB，这样所有的handler形成了一个链表，我们只需将所有请求发送给handlerA，就无需关心请求是如何进行处理是谁处理的。  </p><h2 id="常见需求场景"><a href="#常见需求场景" class="headerlink" title="常见需求场景"></a>常见需求场景</h2><p>所以责任链模式适用于一级一级传递的需求当中。比如日志管理，那我们常见的日志级别就是一级一级的，有debug，info，warning，error等等的级别，当日志级别设为较低一级时，它以上的日志都会打印。<br>又比如权限的管理，比如操作的级别有很多级，对服务器越危险的操作就必须有更高权限的人来确认操作，那根据操作的级别，把请求传递给责任链，权限不足就交给上一级，直到这个操作进行确认。<br>这里感兴趣的同学可以动手写写简单的实现代码。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>那责任链模式能一定程序上降低请求的发送者与处理者之间的耦合，不用关心请求发送给哪个处理者。其次对于指派处理者较为灵活，可以改变链中的顺序和成员，动态增加和删除。<br>那缺点在于不能保证请求一定被接收，其次就是环的解决，如果处理不当，有可能导致循环调用。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文来谈谈责任链模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之桥接模式</title>
    <link href="http://re0.top/2020/09/04/bridge_patterns/"/>
    <id>http://re0.top/2020/09/04/bridge_patterns/</id>
    <published>2020-09-04T07:00:00.000Z</published>
    <updated>2020-09-04T09:00:20.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>桥接模式其实是很少在项目中使用的设计模式，难度可以说是很大的。但是理解桥接模式能更深入的理解面向对象编程。<br>那这篇就来讲讲这个模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们先来看看维基百科上的定义：  </p><blockquote><p>桥接模式是软件设计模式中最复杂的模式之一，它把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。  </p></blockquote><p>听起来就很复杂，而且竟然说是最复杂的设计模式。<br>桥的作用就是连接河的两岸，那么桥接是不是也有关系呢？是的，桥接就是为了连接两个独立结构，而这两个独立结构可以独立的发生变化。<br>那这个设计模式的目的就是为了将抽象部分与实现部分分离，使他们可以独立的变化，这个抽象与实现部分就是我们上面所说的两个独立结构。<br>总结一下，这个设计模式解决的有以下几点： </p><ul><li>如果系统需要在抽象化和具体化之间更加灵活的转换，避免了两个层次之间建立静态的继承关系，此时通过桥接模式能是他们建立联系。</li><li>当使用多层次继承时，会导致系统类的增多导致类爆炸，那使用桥接模式是不错的选择。</li><li>当一个类可能有多个变化的方向时，并且这几个变化方向都各自独自，那桥接模式就排上用场了。  </li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>由于图床实在是不方便，所以我没有放UML图，我这里还是简单实现个小例子吧。<br>首先桥接模式涉及到的角色有以下几个：  </p><ul><li>Abstraction：抽象接口</li><li>RefinedAbstraction：拓展Abstraction</li><li>Implementor：具体的实现接口，它和RefinedAbstraction中的接口不一定相同</li><li>ConcreteImplementor：实现Implementor接口 </li></ul><p>一个简单小例子，比如乘坐交通工具出门旅游，可能有多个目的地的变化，比如杭州，上海等，然后出门的交通工具也可以不同，比如小轿车自驾，或者做飞机。<br>那以上代码如何去实现桥接呢？<br>首先我们定义Implementor，那对应到这个例子就是交通工具。为啥先定义具体接口呢？原因是因为在Abstraction会将Implementor作为对象注入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ride</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接下来是具体的交通工具(ConcreteImplementor)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ride</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"乘坐小轿车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirPlane</span> <span class="keyword">implements</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ride</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"乘坐飞机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>那接下来就是抽象对象接口(Abstraction)，这例子中就是我们的目的地。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Vehicle vehicle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">City</span><span class="params">(Vehicle vehicle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vehicle = vehicle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>具体的目的地<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HangZhou</span> <span class="keyword">extends</span> <span class="title">City</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HangZhou</span><span class="params">(Vehicle vehicle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(vehicle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.vehicle.ride();</span><br><span class="line">        System.out.println(<span class="string">"到杭州旅游"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShangHai</span> <span class="keyword">extends</span> <span class="title">City</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShangHai</span><span class="params">(Vehicle vehicle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(vehicle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.vehicle.ride();</span><br><span class="line">        System.out.println(<span class="string">"到上海旅游"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  </p><p>我们写个测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        City city = <span class="keyword">new</span> ShangHai(<span class="keyword">new</span> AirPlane());</span><br><span class="line">        city.visit();</span><br><span class="line"></span><br><span class="line">        City city1 = <span class="keyword">new</span> HangZhou(<span class="keyword">new</span> Car());</span><br><span class="line">        city1.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>如此我们便将抽象部分与实现部分相分离，比如当类发生改变时，两者互不影响。比如交通工具增多，那对于City是没什么影响的，反过来，City增多也不影响交通工具。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点很明显，就是抽象与实现的分离，并且扩展性强，而且具体的实现对调用者是透明的。<br>而缺点就是这个模式理解起来有难度，对于维护可能会加重，并且由于建立在抽象编程上，开发者需要深入面向对象编程才能理解。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那简单总结一下</p><ul><li>如果抽象和实现部分不想耦合性那么强，那么可以采用桥接模式，将两个部分分开来。</li><li>如果两个部分都需要单独的扩展，可以使用桥接模式，两部分都可以独立的变化，并且互不影响。</li><li>当修改实现类时，不希望对调用方产生影响，那可以采用桥接模式，因为调用方是面向接口的，如果具体的实现类修改时，调用方不受影响，可以说是对调用方是透明的。</li><li>当我们采用继承时，可能会有很多子类，比如C继承B，B继承A，多级继承时，那采用桥接模式可以减少子类的数目。</li></ul><p>那以上就是这篇文章的内容，全文写下来觉得这个模式虽然很晦涩，但只要多写写代码就能理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;桥接模式其实是很少在项目中使用的设计模式，难度可以说是很大的。但是理解桥接模式能更深入的理解面向对象编程。&lt;br&gt;那这篇就来讲讲这个模式。 
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之原型模式</title>
    <link href="http://re0.top/2020/09/02/prototype_pattern/"/>
    <id>http://re0.top/2020/09/02/prototype_pattern/</id>
    <published>2020-09-02T07:00:00.000Z</published>
    <updated>2020-09-02T07:33:21.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇来讲讲原型模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>原型模式属于创建型模式，通常被用来创建重复的对象，通过原型来克隆对象，来获取相同的对象。<br>一般来说是创建对象的代价比较大时，比如对象的属性，设置较多，不方便重新创建，而是从原有对象进行拷贝。<br>这个模式实现的关键就是clone方法。<br>原型模式在实际项目中很少单独出现，通常是与工厂模式一起出现，由clone方法创建对象然后由工厂提供给调用者。 </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们依然用简单例子来讲讲这个模式。<br>首先创建的是抽象接口或者类。这里我采用是抽象类加实现Cloneable接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object clone = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clone = <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (CloneNotSupportedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>然后是具体的原型类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype1</span> <span class="keyword">extends</span> <span class="title">Prototype</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototype1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        id = <span class="string">"1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"id: "</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype2</span> <span class="keyword">extends</span> <span class="title">Prototype</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototype2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        id = <span class="string">"2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"id: "</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着我们创建一个管理类，帮助我们获取原型的克隆，相当于工厂模式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String,Prototype&gt; map = <span class="keyword">new</span></span><br><span class="line">            HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Prototype <span class="title">getPrototype</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        Prototype prototype = map.get(id);</span><br><span class="line">        <span class="keyword">return</span> (Prototype) prototype.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ConcretePrototype1 concretePrototype1 = <span class="keyword">new</span> ConcretePrototype1();</span><br><span class="line">        map.put(concretePrototype1.getId(),concretePrototype1);</span><br><span class="line"></span><br><span class="line">        ConcretePrototype2 concretePrototype2 = <span class="keyword">new</span> ConcretePrototype2();</span><br><span class="line">        map.put(concretePrototype2.getId(), concretePrototype2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>最后我们实现一个客户端调用看看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrototypeManager.init();</span><br><span class="line"></span><br><span class="line">        Prototype clonePrototype1 = PrototypeManager.getPrototype(<span class="string">"1"</span>);</span><br><span class="line">        clonePrototype1.test();</span><br><span class="line"></span><br><span class="line">        Prototype clonePrototype1_ = PrototypeManager.getPrototype(<span class="string">"1"</span>);</span><br><span class="line">        clonePrototype1_.test();</span><br><span class="line"></span><br><span class="line">        System.out.println(clonePrototype1.hashCode() + <span class="string">"   "</span>  + clonePrototype1_.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>那最后一行输出是为了看两个对象是否相同，如果是同一个对象那么hashcode应该是相同的，那结果很明显是不同的，所以两个对象只是属性相同，而在内存中的引用不同。<br>如此我们就结合了原型模式和工厂模式。当然，对于原型管理器也就是PrototypeManager应该实现动态的添加和删除原型，即应该实例化这个对象，并且加上锁来实现并发，这里就不再实现了。   </p><h2 id="Java中的克隆"><a href="#Java中的克隆" class="headerlink" title="Java中的克隆"></a>Java中的克隆</h2><p>这里有一点要说的是，Cloneable接口只起一个作用，并没有实际的方法，它的目的只是告诉JVM可以在这个类上安全的使用clone方法，如果没有实现这个接口，则会抛出CloneNotSupportedException异常。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>最后我们依旧来讲讲这个模式的优缺点。<br>优点呢，在于性能高效，并且如果构造函数十分复杂的话还可以不用理会，因为可以直接克隆。<br>那缺点也十分明显，需要实现cloneable接口，其次就是每个类都必须有一个克隆方法，因为不是所有的类都可以直接使用父类clone方法来进行克隆，复杂的类也许需要手动重新clone方法。然后还有就是在进行拷贝的时候，有可能会出现循环引用的场景，导致栈溢出也是有可能的，因此clone方法并不一定好用。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于原型模式的内容。感觉容量不大，但是需要手动写写代码才能更好的理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这篇来讲讲原型模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>由lambda表达式引发的思考</title>
    <link href="http://re0.top/2020/08/29/lambda/"/>
    <id>http://re0.top/2020/08/29/lambda/</id>
    <published>2020-08-29T07:00:00.000Z</published>
    <updated>2020-08-29T08:04:15.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>lambda表达式不能说常用吧，但偶尔还是需要用到的。关于lambda表达式，是我学python的时候接触到的概念，仔细想想也有两年了。前段时间的面试有提到java中的lambda表达式，当时自己的回答还是比较笼统的，比如作为类似语法糖的存在，通常在比较器里面写，可以免写匿名类等等。我个人感觉回答的不是很好，那这篇文章就来讲讲我们一直在用的lambda表达式吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>lambda表达式在很多语言中都有，那我个人比较熟悉的python与java中的lambda。那lambda表达式究竟是啥呢？根据百度百科的定义：  </p><blockquote><p>lambda表达式是一个<strong>匿名函数</strong>，基于数学中的λ演算得名，可以表示闭包。</p></blockquote><p>这么说谁听得懂哦？没错，没有实践的概念都是天书。<br>那我们先来讲讲啥是匿名函数。  </p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>所谓匿名函数，正如字面所讲，就是没有名字的函数，正常我们在定义函数时，会定义它的名称，其他地方调用时直接用它的名称进行调用即可。<br>那如果我们只需要使用一次这个函数，并且不想给他取名，那这时我们就要用到匿名函数了。<br><strong>所谓的lambda表达式就是匿名函数的一种表示方式。</strong></p><h2 id="python中的lambda表达式"><a href="#python中的lambda表达式" class="headerlink" title="python中的lambda表达式"></a>python中的lambda表达式</h2><p>正常我们在定义函数时会这么定义：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + x</span><br></pre></td></tr></table></figure> </p><p>以上我们定义了一个有名称的函数，而如果使用lambda表达式的话<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = <span class="keyword">lambda</span> x : x + x</span><br></pre></td></tr></table></figure> </p><p>那这两种定义函数的方式的功能都是一样的，那通常情况下我们不会把lambda表达式赋值给任何变量，这相当于可以使用这个变量调用匿名函数，就已经不符合匿名函数的定义。<br>那在python中使用到lambda表达式的场景有哪些呢？  </p><ul><li>最常见的当然就是一些python中的内置函数，比如作为比较器的时候，如sorted函数，<code>sorted([1,2,3],key=lambda x : -x)</code>，又比如map函数，<code>map(lambda x: x+1, [1,2,3])</code>。</li><li>那还有就是函数的返回可以是一个匿名函数，例如<code>return lambda x,y : x*y</code>，这个我比较少用。</li><li>还有就是可以通过lambda表达式将某个函数屏蔽，例如前端可以通过<code>console.log = ()=&gt;{}</code>来屏蔽log输出，原因是把log函数给替换成了没有功能的函数，那python中也可以，比如<code>time.sleep = lambda x : None</code>，就可以屏蔽sleep函数。  </li></ul><h2 id="Java中的lambda表达式"><a href="#Java中的lambda表达式" class="headerlink" title="Java中的lambda表达式"></a>Java中的lambda表达式</h2><p>Java 8中支持了lambda表达式，那么带来的结果就是代码更加简洁。它的亮点就是可以替代匿名内部类。<br>java中的lambda表达式的语法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure>  </p><p>在java 8之前假设要新建一个线程，在之前的<a href="/2020/07/24/java_thread_pool/">文章</a>我有写过，通常我们需要这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>   </p><p>那在java 8之后我们可以通过lambda表达式省去这个匿名runnable对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">    () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>   </p><p>当然，我们最常见的还是传入比较器的时候，例如在java 8之前，我们需要匿名内部类来重写比较器的compare方法。例如使用优先级队列需要建立堆时，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>   </p><p>那这边ieda就会提示我是否转换为lambda表达式，我们转换一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br></pre></td></tr></table></figure>   </p><p>我们代码更加直观了。当然这得益于jvm自动帮助我们判断参数类型。<br>那为什么可以简写呢？其实我们可以直接跟进源码看看，首先是new Thread，我们可以发现Thread有个构造函数可以传入Runnable对象，而Runnable是一个接口；接着我们看PriorityQueue，也可以发现有个构造函数可以传入Comparator对象，而Comparator也是个接口。<br>所以不难猜测，其实能使用lambda表达式是因为有相应的构造函数与接口的存在。那书写后编译时，自动帮我们匹配进相应的构造函数，自动判断类型，等等。这就是lambda表达式所帮我们做的。  </p><h2 id="Java-lambda表达式深入"><a href="#Java-lambda表达式深入" class="headerlink" title="Java lambda表达式深入"></a>Java lambda表达式深入</h2><p>那通过以上我们可以知道，lambda表达式其实作为的是一种类似语法糖的存在，可以更直观的书写代码。lambda表达式似乎与匿名内部类可以相互替换。但事实并非如此。<br>当我们书写一个匿名内部类时，在编译阶段我们可以发现发现多出了一个class文件，但我们使用lambda表达式后，只有一个class文件。<br>继续查看使用lambda表达式后编译的class文件，我们可以发现lambda表达式其实是被封装成主类的一个私有静态方法。<br>还有一点是this的使用，在匿名内部类中，this指向的是自己，而lambda表达式中，this指向的是外部类。</p><h2 id="Java-lambda表达式的性能问题"><a href="#Java-lambda表达式的性能问题" class="headerlink" title="Java lambda表达式的性能问题"></a>Java lambda表达式的性能问题</h2><p>这个问题其实困扰了我很久，在网上找了许多文章，有说性能有损失，有说没差多少。那在我测试后发现，lambda表达式确确实实有一点性能上的损失，但是并不大。那在我做LeetCode的其中一道题目中使用到的优先级队列，那使用匿名内部类与使用lambda表达式的时间分别是40-60ms与600-700ms(大概)，所以也就是说在某些用例上面，lambda确实是慢于匿名内部类的。<br>那关于这个问题，如果之后还有遇到会单独写写文章还有测试方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章讲了什么是lambda表达式以及在python和java中的常用方法。那在python中，由于这门语言本身就追求简洁与方便，所以在大部分函数中传入lambda表达式本身就是十分省事的存在，并且不会把函数定义写入整个文件中，从而污染环境。<br>在java中，其实我个人倾向于把lambda表达式看做是一种语法糖，减少书写量，因为它能做到大部分匿名内部类的所能做的事，从代码简洁性来看肯定是更好的。<br>那函数式编程越加火热的今天，lambda表达式作为函数式编程的一份子，肯定是会有越来越多语言支持，甚至当成主要书写方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;lambda表达式不能说常用吧，但偶尔还是需要用到的。关于lambda表达式，是我学python的时候接触到的概念，仔细想想也有两年了。前段
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://re0.top/tags/Java/"/>
    
      <category term="Python" scheme="http://re0.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之迭代器模式</title>
    <link href="http://re0.top/2020/08/27/iterator_pattern/"/>
    <id>http://re0.top/2020/08/27/iterator_pattern/</id>
    <published>2020-08-27T08:00:00.000Z</published>
    <updated>2020-08-27T09:32:01.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇来讲讲迭代器模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>迭代器模式属于行为型模式，这种模式用于顺序访问集合对象中的元素，但是没有暴露内部的表示。例如java中的iterator。<br>一般来讲迭代器模式中有以下几个角色：</p><ul><li>迭代器(Iterator)：抽象接口，一般来说有几个方法，next()取得下一个元素，hasNext()判断是否有下一个元素，remove()移除元素。</li><li>具体迭代器，即实现迭代器接口的具体类</li><li>容器角色(Aggregate/Container)：也是个接口，一般有一个iterator()提供迭代器，java中有Collection，list，set等接口。</li><li>具体容器角色：即容器角色的实现类，如java中实现list的ArrayList等。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们来实现一个简单的迭代器。<br>先定义简单迭代器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>之后定义容器接口，里面有一个getIterator获取迭代器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>之后实现具体容器，使用内部类定义具体迭代器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">keyRepository</span> <span class="keyword">implements</span> <span class="title">Container</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] keys = &#123;<span class="string">"101"</span>,<span class="string">"102"</span>,<span class="string">"103"</span>&#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &lt; keys.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasNext())&#123;</span><br><span class="line">                <span class="keyword">return</span> keys[index++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>最后测试一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        keyRepository keyRepository = <span class="keyword">new</span> keyRepository();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Iterator iterator = keyRepository.getIterator(); iterator.hasNext();)&#123;</span><br><span class="line">            System.out.println(<span class="string">"key is "</span> + iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>   </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>迭代器模式的优点在于简化了遍历的方式，对于数组或者列表我们还可以通过下标来获取对象，而如果对于一些无法通过下标获取对象的存储类型，我们就需要迭代器来顺序获取对象。其次我们可以实现多种遍历方式，如正序或者逆序。再者我们增加新的迭代器时无修修改原有的代码。<br>而缺点在于由于迭代器模式存储与遍历数据的方法是分开的，因此需要增加新的容器时就需要添加对应的迭代器类，增加复杂性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>迭代器模式与容器是相互作用的，一般来说实现一个容器就要实现这个容器的迭代器，在java中的collection，list，set，map等都有它自己的迭代器。我们可以使用增强型for循环再配合迭代器进行遍历，十分方便。所以迭代器模式就是当我们需要实现一个新的容器时，就需要引入这个模式，来给这个容器提供一个迭代器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇来讲讲迭代器模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之策略模式</title>
    <link href="http://re0.top/2020/08/27/strategy_pattern/"/>
    <id>http://re0.top/2020/08/27/strategy_pattern/</id>
    <published>2020-08-27T07:00:00.000Z</published>
    <updated>2020-08-27T07:18:13.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>几天没写文章，今天来讲讲策略模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>策略模式，属于行为型模式。它是把算法封装到类中，让这些算法可以相互替换，并且不影响到客户端，简单来说，就是把算法进行封装，客户端可以通过条件不同来选择不同的策略。<br>常见的实例有：</p><ul><li>客户端需要选择几种算法中的一种，例如某些工具类的封装</li><li>选择不同实现的方式，例如实现出行可以步行可以公交等等。</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>那策略模式的实现关键在于所有的策略需要实现同一个接口。<br>我们举个例子，例如出门的选择上，假设有三种选择，步行，公交，驾车。我们用这个例子实现策略模式。<br>首先定义Strategy接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着实现几种策略<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"选择步行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"选择公交"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyC</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"选择驾车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着我们创建context对象，这个类是为了让客户端选择合适策略，即连接客户端与策略的中间者。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setStrategy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> r = random.nextInt(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>)&#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> StrategyA();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">1</span>)&#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> StrategyB();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> StrategyC();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        strategy.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>这里我们使用随机法选择策略，那实现的方式有很多，比如客户端直接传入策略的对象，又比如客户端传入关键字让context选择策略等等。   </p><p>最后我们创建客户端调用看看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context test_context = <span class="keyword">new</span> Context();</span><br><span class="line">        test_context.selectFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>如此我们便实现了一个简单的策略模式。这里有一点，常见的策略模式是由客户端决定使用什么策略，所以严格来说上文并不是一个严谨的策略模式。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>策略模式的优点在于策略可以灵活的切换，因为他们实现了同一个接口。其次就是便于拓展，在增加新的策略时，只需要添加一个具体类并加入Context类中就可以，符合”开闭原则”。<br>那缺点在于客户端必须知道所有的策略，需要自行决定使用策略，即需要暴露所有策略类。其次就是策略类会随着系统扩展而变多，而不利于维护。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文对策略模式进行了大概介绍。如果系统中需要选择其中一种算法时或者类的区别在于不同的行为时，又或者一个对象有多个行为，当这些情况时，可以使用策略模式对策略进行封装到context中，并使用context进行调用。就是这么简单~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;几天没写文章，今天来讲讲策略模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
