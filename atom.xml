<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zer0&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://re0.top/"/>
  <updated>2020-09-02T07:33:21.187Z</updated>
  <id>http://re0.top/</id>
  
  <author>
    <name>Zer0</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之原型模式</title>
    <link href="http://re0.top/2020/09/02/prototype_pattern/"/>
    <id>http://re0.top/2020/09/02/prototype_pattern/</id>
    <published>2020-09-02T07:00:00.000Z</published>
    <updated>2020-09-02T07:33:21.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇来讲讲原型模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>原型模式属于创建型模式，通常被用来创建重复的对象，通过原型来克隆对象，来获取相同的对象。<br>一般来说是创建对象的代价比较大时，比如对象的属性，设置较多，不方便重新创建，而是从原有对象进行拷贝。<br>这个模式实现的关键就是clone方法。<br>原型模式在实际项目中很少单独出现，通常是与工厂模式一起出现，由clone方法创建对象然后由工厂提供给调用者。 </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们依然用简单例子来讲讲这个模式。<br>首先创建的是抽象接口或者类。这里我采用是抽象类加实现Cloneable接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object clone = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clone = <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (CloneNotSupportedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>然后是具体的原型类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype1</span> <span class="keyword">extends</span> <span class="title">Prototype</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototype1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        id = <span class="string">"1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"id: "</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype2</span> <span class="keyword">extends</span> <span class="title">Prototype</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototype2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        id = <span class="string">"2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"id: "</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着我们创建一个管理类，帮助我们获取原型的克隆，相当于工厂模式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String,Prototype&gt; map = <span class="keyword">new</span></span><br><span class="line">            HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Prototype <span class="title">getPrototype</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        Prototype prototype = map.get(id);</span><br><span class="line">        <span class="keyword">return</span> (Prototype) prototype.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ConcretePrototype1 concretePrototype1 = <span class="keyword">new</span> ConcretePrototype1();</span><br><span class="line">        map.put(concretePrototype1.getId(),concretePrototype1);</span><br><span class="line"></span><br><span class="line">        ConcretePrototype2 concretePrototype2 = <span class="keyword">new</span> ConcretePrototype2();</span><br><span class="line">        map.put(concretePrototype2.getId(), concretePrototype2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>最后我们实现一个客户端调用看看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrototypeManager.init();</span><br><span class="line"></span><br><span class="line">        Prototype clonePrototype1 = PrototypeManager.getPrototype(<span class="string">"1"</span>);</span><br><span class="line">        clonePrototype1.test();</span><br><span class="line"></span><br><span class="line">        Prototype clonePrototype1_ = PrototypeManager.getPrototype(<span class="string">"1"</span>);</span><br><span class="line">        clonePrototype1_.test();</span><br><span class="line"></span><br><span class="line">        System.out.println(clonePrototype1.hashCode() + <span class="string">"   "</span>  + clonePrototype1_.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>那最后一行输出是为了看两个对象是否相同，如果是同一个对象那么hashcode应该是相同的，那结果很明显是不同的，所以两个对象只是属性相同，而在内存中的引用不同。<br>如此我们就结合了原型模式和工厂模式。当然，对于原型管理器也就是PrototypeManager应该实现动态的添加和删除原型，即应该实例化这个对象，并且加上锁来实现并发，这里就不再实现了。   </p><h2 id="Java中的克隆"><a href="#Java中的克隆" class="headerlink" title="Java中的克隆"></a>Java中的克隆</h2><p>这里有一点要说的是，Cloneable接口只起一个作用，并没有实际的方法，它的目的只是告诉JVM可以在这个类上安全的使用clone方法，如果没有实现这个接口，则会抛出CloneNotSupportedException异常。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>最后我们依旧来讲讲这个模式的优缺点。<br>优点呢，在于性能高效，并且如果构造函数十分复杂的话还可以不用理会，因为可以直接克隆。<br>那缺点也十分明显，需要实现cloneable接口，其次就是每个类都必须有一个克隆方法，因为不是所有的类都可以直接使用父类clone方法来进行克隆，复杂的类也许需要手动重新clone方法。然后还有就是在进行拷贝的时候，有可能会出现循环引用的场景，导致栈溢出也是有可能的，因此clone方法并不一定好用。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于原型模式的内容。感觉容量不大，但是需要手动写写代码才能更好的理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这篇来讲讲原型模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>由lambda表达式引发的思考</title>
    <link href="http://re0.top/2020/08/29/lambda/"/>
    <id>http://re0.top/2020/08/29/lambda/</id>
    <published>2020-08-29T07:00:00.000Z</published>
    <updated>2020-08-29T08:04:15.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>lambda表达式不能说常用吧，但偶尔还是需要用到的。关于lambda表达式，是我学python的时候接触到的概念，仔细想想也有两年了。前段时间的面试有提到java中的lambda表达式，当时自己的回答还是比较笼统的，比如作为类似语法糖的存在，通常在比较器里面写，可以免写匿名类等等。我个人感觉回答的不是很好，那这篇文章就来讲讲我们一直在用的lambda表达式吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>lambda表达式在很多语言中都有，那我个人比较熟悉的python与java中的lambda。那lambda表达式究竟是啥呢？根据百度百科的定义：  </p><blockquote><p>lambda表达式是一个<strong>匿名函数</strong>，基于数学中的λ演算得名，可以表示闭包。</p></blockquote><p>这么说谁听得懂哦？没错，没有实践的概念都是天书。<br>那我们先来讲讲啥是匿名函数。  </p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>所谓匿名函数，正如字面所讲，就是没有名字的函数，正常我们在定义函数时，会定义它的名称，其他地方调用时直接用它的名称进行调用即可。<br>那如果我们只需要使用一次这个函数，并且不想给他取名，那这时我们就要用到匿名函数了。<br><strong>所谓的lambda表达式就是匿名函数的一种表示方式。</strong></p><h2 id="python中的lambda表达式"><a href="#python中的lambda表达式" class="headerlink" title="python中的lambda表达式"></a>python中的lambda表达式</h2><p>正常我们在定义函数时会这么定义：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + x</span><br></pre></td></tr></table></figure> </p><p>以上我们定义了一个有名称的函数，而如果使用lambda表达式的话<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = <span class="keyword">lambda</span> x : x + x</span><br></pre></td></tr></table></figure> </p><p>那这两种定义函数的方式的功能都是一样的，那通常情况下我们不会把lambda表达式赋值给任何变量，这相当于可以使用这个变量调用匿名函数，就已经不符合匿名函数的定义。<br>那在python中使用到lambda表达式的场景有哪些呢？  </p><ul><li>最常见的当然就是一些python中的内置函数，比如作为比较器的时候，如sorted函数，<code>sorted([1,2,3],key=lambda x : -x)</code>，又比如map函数，<code>map(lambda x: x+1, [1,2,3])</code>。</li><li>那还有就是函数的返回可以是一个匿名函数，例如<code>return lambda x,y : x*y</code>，这个我比较少用。</li><li>还有就是可以通过lambda表达式将某个函数屏蔽，例如前端可以通过<code>console.log = ()=&gt;{}</code>来屏蔽log输出，原因是把log函数给替换成了没有功能的函数，那python中也可以，比如<code>time.sleep = lambda x : None</code>，就可以屏蔽sleep函数。  </li></ul><h2 id="Java中的lambda表达式"><a href="#Java中的lambda表达式" class="headerlink" title="Java中的lambda表达式"></a>Java中的lambda表达式</h2><p>Java 8中支持了lambda表达式，那么带来的结果就是代码更加简洁。它的亮点就是可以替代匿名内部类。<br>java中的lambda表达式的语法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure>  </p><p>在java 8之前假设要新建一个线程，在之前的<a href="/2020/07/24/java_thread_pool/">文章</a>我有写过，通常我们需要这么写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>   </p><p>那在java 8之后我们可以通过lambda表达式省去这个匿名runnable对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">    () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>   </p><p>当然，我们最常见的还是传入比较器的时候，例如在java 8之前，我们需要匿名内部类来重写比较器的compare方法。例如使用优先级队列需要建立堆时，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>   </p><p>那这边ieda就会提示我是否转换为lambda表达式，我们转换一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br></pre></td></tr></table></figure>   </p><p>我们代码更加直观了。当然这得益于jvm自动帮助我们判断参数类型。<br>那为什么可以简写呢？其实我们可以直接跟进源码看看，首先是new Thread，我们可以发现Thread有个构造函数可以传入Runnable对象，而Runnable是一个接口；接着我们看PriorityQueue，也可以发现有个构造函数可以传入Comparator对象，而Comparator也是个接口。<br>所以不难猜测，其实能使用lambda表达式是因为有相应的构造函数与接口的存在。那书写后编译时，自动帮我们匹配进相应的构造函数，自动判断类型，等等。这就是lambda表达式所帮我们做的。  </p><h2 id="Java-lambda表达式深入"><a href="#Java-lambda表达式深入" class="headerlink" title="Java lambda表达式深入"></a>Java lambda表达式深入</h2><p>那通过以上我们可以知道，lambda表达式其实作为的是一种类似语法糖的存在，可以更直观的书写代码。lambda表达式似乎与匿名内部类可以相互替换。但事实并非如此。<br>当我们书写一个匿名内部类时，在编译阶段我们可以发现发现多出了一个class文件，但我们使用lambda表达式后，只有一个class文件。<br>继续查看使用lambda表达式后编译的class文件，我们可以发现lambda表达式其实是被封装成主类的一个私有静态方法。<br>还有一点是this的使用，在匿名内部类中，this指向的是自己，而lambda表达式中，this指向的是外部类。</p><h2 id="Java-lambda表达式的性能问题"><a href="#Java-lambda表达式的性能问题" class="headerlink" title="Java lambda表达式的性能问题"></a>Java lambda表达式的性能问题</h2><p>这个问题其实困扰了我很久，在网上找了许多文章，有说性能有损失，有说没差多少。那在我测试后发现，lambda表达式确确实实有一点性能上的损失，但是并不大。那在我做LeetCode的其中一道题目中使用到的优先级队列，那使用匿名内部类与使用lambda表达式的时间分别是40-60ms与600-700ms(大概)，所以也就是说在某些用例上面，lambda确实是慢于匿名内部类的。<br>那关于这个问题，如果之后还有遇到会单独写写文章还有测试方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章讲了什么是lambda表达式以及在python和java中的常用方法。那在python中，由于这门语言本身就追求简洁与方便，所以在大部分函数中传入lambda表达式本身就是十分省事的存在，并且不会把函数定义写入整个文件中，从而污染环境。<br>在java中，其实我个人倾向于把lambda表达式看做是一种语法糖，减少书写量，因为它能做到大部分匿名内部类的所能做的事，从代码简洁性来看肯定是更好的。<br>那函数式编程越加火热的今天，lambda表达式作为函数式编程的一份子，肯定是会有越来越多语言支持，甚至当成主要书写方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;lambda表达式不能说常用吧，但偶尔还是需要用到的。关于lambda表达式，是我学python的时候接触到的概念，仔细想想也有两年了。前段
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://re0.top/tags/Java/"/>
    
      <category term="Python" scheme="http://re0.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之迭代器模式</title>
    <link href="http://re0.top/2020/08/27/iterator_pattern/"/>
    <id>http://re0.top/2020/08/27/iterator_pattern/</id>
    <published>2020-08-27T08:00:00.000Z</published>
    <updated>2020-08-27T09:32:01.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇来讲讲迭代器模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>迭代器模式属于行为型模式，这种模式用于顺序访问集合对象中的元素，但是没有暴露内部的表示。例如java中的iterator。<br>一般来讲迭代器模式中有以下几个角色：</p><ul><li>迭代器(Iterator)：抽象接口，一般来说有几个方法，next()取得下一个元素，hasNext()判断是否有下一个元素，remove()移除元素。</li><li>具体迭代器，即实现迭代器接口的具体类</li><li>容器角色(Aggregate/Container)：也是个接口，一般有一个iterator()提供迭代器，java中有Collection，list，set等接口。</li><li>具体容器角色：即容器角色的实现类，如java中实现list的ArrayList等。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们来实现一个简单的迭代器。<br>先定义简单迭代器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>之后定义容器接口，里面有一个getIterator获取迭代器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>之后实现具体容器，使用内部类定义具体迭代器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">keyRepository</span> <span class="keyword">implements</span> <span class="title">Container</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] keys = &#123;<span class="string">"101"</span>,<span class="string">"102"</span>,<span class="string">"103"</span>&#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &lt; keys.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasNext())&#123;</span><br><span class="line">                <span class="keyword">return</span> keys[index++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>最后测试一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        keyRepository keyRepository = <span class="keyword">new</span> keyRepository();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Iterator iterator = keyRepository.getIterator(); iterator.hasNext();)&#123;</span><br><span class="line">            System.out.println(<span class="string">"key is "</span> + iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>   </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>迭代器模式的优点在于简化了遍历的方式，对于数组或者列表我们还可以通过下标来获取对象，而如果对于一些无法通过下标获取对象的存储类型，我们就需要迭代器来顺序获取对象。其次我们可以实现多种遍历方式，如正序或者逆序。再者我们增加新的迭代器时无修修改原有的代码。<br>而缺点在于由于迭代器模式存储与遍历数据的方法是分开的，因此需要增加新的容器时就需要添加对应的迭代器类，增加复杂性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>迭代器模式与容器是相互作用的，一般来说实现一个容器就要实现这个容器的迭代器，在java中的collection，list，set，map等都有它自己的迭代器。我们可以使用增强型for循环再配合迭代器进行遍历，十分方便。所以迭代器模式就是当我们需要实现一个新的容器时，就需要引入这个模式，来给这个容器提供一个迭代器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇来讲讲迭代器模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之策略模式</title>
    <link href="http://re0.top/2020/08/27/strategy_pattern/"/>
    <id>http://re0.top/2020/08/27/strategy_pattern/</id>
    <published>2020-08-27T07:00:00.000Z</published>
    <updated>2020-08-27T07:18:13.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>几天没写文章，今天来讲讲策略模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>策略模式，属于行为型模式。它是把算法封装到类中，让这些算法可以相互替换，并且不影响到客户端，简单来说，就是把算法进行封装，客户端可以通过条件不同来选择不同的策略。<br>常见的实例有：</p><ul><li>客户端需要选择几种算法中的一种，例如某些工具类的封装</li><li>选择不同实现的方式，例如实现出行可以步行可以公交等等。</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>那策略模式的实现关键在于所有的策略需要实现同一个接口。<br>我们举个例子，例如出门的选择上，假设有三种选择，步行，公交，驾车。我们用这个例子实现策略模式。<br>首先定义Strategy接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着实现几种策略<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"选择步行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"选择公交"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyC</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"选择驾车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着我们创建context对象，这个类是为了让客户端选择合适策略，即连接客户端与策略的中间者。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setStrategy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> r = random.nextInt(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>)&#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> StrategyA();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">1</span>)&#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> StrategyB();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> StrategyC();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        strategy.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>这里我们使用随机法选择策略，那实现的方式有很多，比如客户端直接传入策略的对象，又比如客户端传入关键字让context选择策略等等。   </p><p>最后我们创建客户端调用看看。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context test_context = <span class="keyword">new</span> Context();</span><br><span class="line">        test_context.selectFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>如此我们便实现了一个简单的策略模式。这里有一点，常见的策略模式是由客户端决定使用什么策略，所以严格来说上文并不是一个严谨的策略模式。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>策略模式的优点在于策略可以灵活的切换，因为他们实现了同一个接口。其次就是便于拓展，在增加新的策略时，只需要添加一个具体类并加入Context类中就可以，符合”开闭原则”。<br>那缺点在于客户端必须知道所有的策略，需要自行决定使用策略，即需要暴露所有策略类。其次就是策略类会随着系统扩展而变多，而不利于维护。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文对策略模式进行了大概介绍。如果系统中需要选择其中一种算法时或者类的区别在于不同的行为时，又或者一个对象有多个行为，当这些情况时，可以使用策略模式对策略进行封装到context中，并使用context进行调用。就是这么简单~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;几天没写文章，今天来讲讲策略模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之适配器模式</title>
    <link href="http://re0.top/2020/08/22/adapter_pattern/"/>
    <id>http://re0.top/2020/08/22/adapter_pattern/</id>
    <published>2020-08-22T07:00:00.000Z</published>
    <updated>2020-08-22T08:55:22.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久没写这个系列，趁着休息时间今天来讲讲适配器模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>适配器模式属于结构型模式，这种设计模式解决的问题是原本由于接口不兼容而不能工作的类可以在一起工作。适配器模式与装饰模式很像，是定义一个包装类，来包装我们所需要适配的类，改变它的接口。但和装饰模式不同的是，包装类不改变原有类的功能，只是改变它的接口。<br>那运用的场景有：  </p><ul><li>电压问题，国外与国内的家用电电压不同，导致进口电器需要适配器转换电压。</li><li>在linux上运行windows程序，需要一个适配平台来实现。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>就用上面的第一个例子我们来讲讲这个模式。<br>首先我们创建原有的类，即国内都是220v的插座。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerSocket220V</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output_220v</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"输出220v"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着我们创建适配器继承于这个类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerAdapter220V</span> <span class="keyword">extends</span> <span class="title">PowerSocket220V</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert_110V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取220V的输入</span></span><br><span class="line">        <span class="keyword">this</span>.output_220v();</span><br><span class="line">        <span class="comment">//进行转换</span></span><br><span class="line">        System.out.println(<span class="string">"输出110V"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>以上就是一个简单例子，即我没有改变原有类的功能，只是改变原有类的接口，使得可以正常工作。<br>那具体来说适配模式需要以下几个类：<br>1.一个已存在并且要适配的类，即原类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adapteeRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"原类中的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>2.需要的目标接口，可以通过实现这个接口来增加接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>3.适配器类，继承于原类，并且实现了目标接口中的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        <span class="keyword">super</span>.adapteeRequest();</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>   </p><p>或者我们可以在适配器中实例化原类，不继承原类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        adaptee.adapteeRequest();</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>那适配器模式的优点呢，是原类与适配类解耦，无需改变原类的结构。并且增加了类的复用与透明度，怎么说呢，由于适配类中的封装对客户端是可见的，所以是透明的。至于类的复用，原类可能实现十分复杂无法直接修改，类似于祖传代码，但是使用复杂，有了适配器模式就可以对原有类进行适配，所以就提高了它的复用性。<br>那缺点在于如果一个大型系统使用了很多适配器，那会十分杂乱，例如明明调用的是A接口但是内部却是调用B接口来实现。其次是像Java这种语言，不支持多继承，所以一次只能适配一个适配者类。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上所述，这个模式的场景是需要使用的原有的类，但这些类的接口不太符合系统需求，或者说是调用条件过于繁琐。但当系统逐渐扩大，过多的适配器会导致维护成本增加，所以如果不是十分必要，可以直接进行重构，而不是使用适配器。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;好久没写这个系列，趁着休息时间今天来讲讲适配器模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>谈一道数据库更新的并发问题</title>
    <link href="http://re0.top/2020/08/19/sql_concurrent/"/>
    <id>http://re0.top/2020/08/19/sql_concurrent/</id>
    <published>2020-08-19T08:00:00.000Z</published>
    <updated>2020-08-19T09:19:47.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天进行了第一次面试，还是比较紧张的，面试官比较严肃，感觉面试官就是抓着一个点不断的问，问到你不会，这次面试算是很失败了，不仅前面的问题很多都不清楚，而且最后的coding题都没写完成，明明知道怎么写，缺敲不动键盘，但是也知道了自己的不足，主要是数据库方面，然后还有代码方面需要加强一下。再努力吧。<br>那文章还是得继续写，今天聊聊面试中提到的一个关于数据库修改数据的问题。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><blockquote><p>有这么一个场景，假设user表的结构为id,user_data，其中这个user_data是个json数据，存放着用户的年龄，名字等等的数据，如果一个用户并发修改这个字段中的user_age与user_name会出现什么样的情况？<br>首先这个问题，先考虑单个字段修改的情况，即我修改其中的某一个数据该怎么改？<br>我在面试中的回答是先取出这个json数据存为对象，然后对这个对象进行修改。但其实mysql5.7.8开始，就提供了对json字段进行操作的函数，有JSON_SET(), JSON_INSERT()还有JSON_REPLACE()，其中JSON_REPLACE()是用来修改json数据的某个字段。那我个人是不太清楚这个，上网查找才知道如果需要对json字段进行update，那可以使用以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set user_data = json_replace(user_data,&apos;$.user_name&apos;,&apos;abc&apos;,&apos;$.user_age&apos;,18) where id = 1;</span><br></pre></td></tr></table></figure>  </p></blockquote><p>其实就是这么简单。<br>但我当时回答的是，先取出数据，再去修改。那问题来了，如果在读过后，被其他线程修改过了数据该怎么办？<br>例如原始数据为<code>1 {&#39;user_name&#39;:&#39;abc&#39;,&#39;user_age&#39;:10}</code>。<br>那么同时过来两个请求a,b：<br>其中a请求是把user_name改为aaa，而b请求是把user_age改为20。<br>那这时候如果请求时间十分接近，在a读取原始数据过后，还没来得及修改，b请求就已经将age改为20了，但此时a读取的数据就是旧的了，如果a继续写入，那age的值就会变为未修改前的。最终导致只有一个字段修改成功。  </p><p>这个问题就是数据库并发时会出现的问题，其实就是不可重复读的问题，即一个事务在一段时间内读取的数据不一致，那解决办法我个人认为使用事务加锁进行解决。</p><h2 id="排它锁与共享锁"><a href="#排它锁与共享锁" class="headerlink" title="排它锁与共享锁"></a>排它锁与共享锁</h2><p>mysql的innodb当中，有一种共享锁的存在，在读取数据前添加共享锁，其他事务只能添加共享锁。那排它锁就是在获取排它锁之后，其他事务不能添加任何锁。  </p><p>那问题在于添加了读的共享锁之后，再添加排它锁会导致死锁，两个事务都没法获得锁，没法更新。所以我们可以在读取的时候就添加排它锁，事务结束后再释放就可以了。<br>那还有一种解决方案就是直接把数据库的隔离级别设为可串行化，事务排队执行，但可能导致请求的阻塞。  </p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>以上就是这个问题的后续思考。<br>在写这篇文章时，没想到就收到了下一面的预约电话，感觉不可思议，明明表现不怎样。但学习永远都是停不下脚步的，就这样共勉吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天进行了第一次面试，还是比较紧张的，面试官比较严肃，感觉面试官就是抓着一个点不断的问，问到你不会，这次面试算是很失败了，不仅前面的问题很多
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="数据库" scheme="http://re0.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之装饰器模式</title>
    <link href="http://re0.top/2020/08/17/decorator_pattern/"/>
    <id>http://re0.top/2020/08/17/decorator_pattern/</id>
    <published>2020-08-17T09:00:00.000Z</published>
    <updated>2020-08-17T09:25:54.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>继续讲讲装饰器模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>装饰器模式就是向一个现有对象添加新的功能，又不改变原对象的结构。它属于结构型模式，因为是对现有类进行包装，所以称作装饰器模式。<br>这么一说，装饰器模式与代理模式有点类似？都可以拓展一个类的功能，又不改变原对象。他们之间的差别之后会说。<br>那这个模式具体的使用场景就是扩展类的功能，并且可以动态修改。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们来实现一个简单的装饰器模式。<br>这里我们先创建接口Component，规范具体实现类与装饰类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着是具体实现类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>创建抽象装饰类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.doAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>然后是具体装饰类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doAction();</span><br><span class="line">        <span class="comment">// 这里写其他功能，如记录</span></span><br><span class="line">        System.out.println(<span class="string">"执行额外功能"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>我们编写客户端调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component component = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        Decorator decorator = <span class="keyword">new</span> ConcreteDecorator(component);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通类执行</span></span><br><span class="line">        component.doAction();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 使用装饰类执行</span></span><br><span class="line">        decorator.doAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">执行操作</span></span><br><span class="line"><span class="comment">执行额外功能</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>  </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>装饰器模式中的抽象装饰器与具体被装饰的类都要实现同一个接口，客户端的请求通过装饰类，装饰类通过具体类来实现，层层传递。在装饰类中能扩展具体类的功能。  </p><h2 id="与代理模式的异同"><a href="#与代理模式的异同" class="headerlink" title="与代理模式的异同"></a>与代理模式的异同</h2><p>装饰器模式也是添加中间层，来实现扩展，但是与代理模式不同的是，代理模式可以隐藏具体类的实现，具体类对于客户端来说是不可见的。而装饰器模式中具体类是可以在客户端中生成的，并且装饰类必须传入具体类才能实现装饰。<br>这是两者的异同点。  </p><h2 id="半透明的装饰模式"><a href="#半透明的装饰模式" class="headerlink" title="半透明的装饰模式"></a>半透明的装饰模式</h2><p>在上面的装饰模式中，具体类，装饰类的接口与抽象接口类Component的接口完全一致。这种称作透明的装饰模式。而如果装饰类的接口与抽象接口类的接口不一致，那装饰器就会变成适配器模式。但这种装饰模式是可以接受的，称作半透明的装饰器模式。<br>即全透明的装饰器模式增强功能不改变接口，半透明的装饰器模式增强功能，改变接口，而适配器模式则是不改变功能，改变接口。<br>将在下一篇讲讲适配器模式。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>最后来讲讲优缺点，装饰器模式优点很明显，就是扩展类的功能，它是继承的一个替代方式，而缺点在于如果存在多层装饰就会十分繁琐，对问题的查找较为麻烦。  </p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>这篇文章讲了装饰器模式的概念与实现，下一篇大概会讲讲适配器模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;继续讲讲装饰器模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之命令模式</title>
    <link href="http://re0.top/2020/08/17/command_pattern/"/>
    <id>http://re0.top/2020/08/17/command_pattern/</id>
    <published>2020-08-17T07:00:00.000Z</published>
    <updated>2020-08-17T07:31:29.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天来讲讲命令模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>命令模式属于行为型设计模式，又称为行动模式或者交易模式，这个模式常常用在游戏开发设计中。命令模式把请求以命令的形式封装在对象中，并传给调用对象，然后调用对象寻找可以处理这个命令的对象，把命令传给相应的对象，执行命令。<br>常见的应用场景有游戏开发中命令角色执行操作，还有GUI开发中事件也属于命令模式中的一种。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>命令模式是把发出命令与执行命令的职责分隔开，委派给不同的对象，所以它允许请求与接收方相互独立，两方可以不知道对方的接口，甚至不需要知道命令是否被接收或者被执行。<br>命令模式中有几个角色：  </p><ul><li>命令(Command/Order)：可以是一个接口，声明命令的抽象接口</li><li>具体命令：实现命令的具体类，通常有execute()方法，用于调用接收者的操作。</li><li>请求者(Invoker)：负责调用命令对象去执行这个命令。</li><li>接收者(Receiver)：负责具体执行一个命令。 </li></ul><p>我们先简单实现一个命令模式demo。<br>先创建Receiver对象，设置action方法，即收到命令会执行什么。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行命令"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着我们创建command接口与它的具体实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里我们把具体接收者当作参数传给具体命令类</span></span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>然后是创建请求者，这里把命令当作参数传给请求者。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>最后是客户端调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建接收者</span></span><br><span class="line">        Receiver receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line">        <span class="comment">//创建具体命令，设置它的接收者</span></span><br><span class="line">        Command command = <span class="keyword">new</span> ConcreteCommand(receiver);</span><br><span class="line">        <span class="comment">//创建请求类，把命令传入</span></span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> Invoker(command);</span><br><span class="line">        invoker.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>这里invoker的值传入，是通过构造方法注入，但实际中，我们的invoker对象往往需要接收许多个命令，这时我们在invoker中就可以设置set方法，将command对象通过setCommand方法注入，实现一个invoker对象循环使用的目的。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>命令模式的优点就是调用者与接受者之间没有依赖关系，调用者实现功能只需要调用Command类中的execute方法就可以，不必关心接受者是谁，怎么接收。其次就是命令模式易扩展，实现command接口就可以实现新命令，在装配时，把具体的对象设置到命令中就可以使用这个命令，而invoker与Client已有代码不用发生改变。<br>缺点在于命令模式可能会导致具体命令类过多，不易维护。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天来讲讲命令模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之外观模式</title>
    <link href="http://re0.top/2020/08/16/facade_pattern/"/>
    <id>http://re0.top/2020/08/16/facade_pattern/</id>
    <published>2020-08-16T07:00:00.000Z</published>
    <updated>2020-08-16T09:02:36.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天继续谈谈设计模式中的一种——外观模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>外观模式属于结构型模式的一种，它向客户端提供了一个可访问的接口，来隐藏复杂的逻辑。即将某些接口进行整合，然后提供一个接口访问这些子接口，简化客户端的访问的复杂性，并且隐藏内部子系统。<br>这么说可能不够清楚，举个例子：<br>假设我开发了10个接口实现了不同功能，但是同学Q要实现业务A，那么它必须得先调用接口1，再调用3，得把接口进行整合；另一个同学W要实现业务B，那要先调用接口3，然后调用接口5，以后有很多业务都要调用接口的话都需要十分复杂的代码。<br>那怎么办？重构代码呗。最容易想到的就是我自己实现业务接口，比如我实现一个接口A，就是把原来的接口1和接口5整合进来，实现接口B，就是整合接口3和接口5。  </p><p>原本基础功能分为10个接口，本身符合单一职责原则。但是发现没有，两个接口中都用到了接口3的代码，强行合并底层代码，却失去了代码的可重用性。<br>那这时候就需要外观模式了，在调用方与底层接口之前增加中间层，中间层提供业务接口，来供客户端调用，即在底层接口不变的情况下，中间层组合了底层接口方便上一层进行调用。<br>这就是外观模式。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们来简单写一个demo。<br>就拿上面那个例子来说。我们先实现3个底层接口，分别是1,3,5.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoreSystem1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"core system 1 method1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoreSystem3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"core system 3 method3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoreSystem5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"core system 5 method5"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着我们创建Facade类，即外观模式中的中间层，来将底层功能整合。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CoreSystem1 coreSystem1 = <span class="keyword">new</span> CoreSystem1();</span><br><span class="line">        CoreSystem3 coreSystem3 = <span class="keyword">new</span> CoreSystem3();</span><br><span class="line">        coreSystem1.method1();</span><br><span class="line">        coreSystem3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CoreSystem3 coreSystem3 = <span class="keyword">new</span> CoreSystem3();</span><br><span class="line">        CoreSystem5 coreSystem5 = <span class="keyword">new</span> CoreSystem5();</span><br><span class="line">        coreSystem3.method3();</span><br><span class="line">        coreSystem5.method5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>最后我们创建一个客户端，调用试试。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        facade.methodA();</span><br><span class="line">        facade.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>外观模式可以减少系统之间的相互依赖，提高灵活性，并且隐藏了底层接口调用逻辑，一定程度上提高了安全性。而缺点在于如果底层改变了，那修改就会很麻烦。  但本身就是整合”祖传代码”，也说不上麻不麻烦。</p><h2 id="代理模式VS外观模式VS中介者模式"><a href="#代理模式VS外观模式VS中介者模式" class="headerlink" title="代理模式VS外观模式VS中介者模式"></a>代理模式VS外观模式VS中介者模式</h2><p>前面也讲过这几个模式，这几个模式是有相似点的，这里就统一说一下。<br>这三个模式都是通过增加中间层，来让客户端调用，隐藏内部逻辑。<br>其次代理模式和外观模式属于结构型模式，而中介者模式属于行为型模式。<br>首先先说代理模式，代理模式是使用代理类去代表另一个类的功能，不改变被代理类的功能。<br>其次是外观模式，它提供的是一个高层次的接口，整合低层次的接口，使得客户端更容易调用。即对外提供访问底层接口的接口。<br>最后是中介者模式，这个模式将多对多的关系，转换为一对多的关系，使用一个中介对象来封装一系列<strong>类似对象</strong>的行为。  </p><p>个人理解，代理模式强调的是一对一的关系，即代理类是原类的一个替身。<br>外观模式对内整合接口，一对多，对外提供一个访问的接口，一对一。<br>中介者模式则将原本多对多转化为一对多。<br>外观模式与中介者模式都能减少原来类与类之间的耦合。对原有系统进行封装，使得外部更容易调用。    </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文聊了聊外观模式，并讲了代理模式，外观模式，中介者模式三者的不同点。当然，以上仅是个人理解，如有错误希望指出。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天继续谈谈设计模式中的一种——外观模式。  &lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>谈谈锁的种类</title>
    <link href="http://re0.top/2020/08/14/lock_class/"/>
    <id>http://re0.top/2020/08/14/lock_class/</id>
    <published>2020-08-14T06:00:00.000Z</published>
    <updated>2020-08-14T10:15:22.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天不谈设计模式，本来想写一篇从源码看hashmap，但是不传图片光靠文字要讲解清楚确实有点困难。<br>那我们来聊聊常见的锁的种类，锁的思想在多线程开发中基本上都是互通的，而且在数据库中我们也会用到。那就开始这篇文章吧。    </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><p>乐观锁的乐观在于使用者认为每次读取数据别人都不会修改，所以不进行上锁操作，但是更新的时候会判断是否其他人已经更新过了这个数据，如果别人已经修改了，则重复读，再进行更新。一般情况下这种是通过版本号来实现，即来数据库中添加一个列为更新版本号，如果版本号与上一次一致，则数据没有变动，如果不一致，则重复读然后比较再写。<br>java中的乐观锁通过CAS操作实现，比较当前值与传入值是否一样，如果一样更新，不一样则失败。而SQL的乐观锁则是使用版本号或者更新时间的列来实现。<br>乐观锁适合读多写少的情况。  </p><p>悲观锁与乐观锁相反，认为每次读取数据时都是旧的，所以会在每次读取数据时都进行上锁操作。<br>java中常见的悲观锁就是Synchronized。  </p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁就是在等待其他线程释放资源的同时，不阻塞，即没有让出cpu，不切换，而是通过一个自旋的操作来不断使用cpu进行使用，减少了切换线程所需要的开销。<br>自旋操作就是不断消耗cpu，直到超时都没有获取到锁时，才进行阻塞。<br>自旋的优点在于减少了线程的阻塞，如果锁的竞争不激烈，那自旋锁对性能的提升是巨大的，因为线程之间的切换是有消耗的。缺点也很明显，就是如果锁竞争激烈，那自旋锁就会在获取锁之前占用cpu，而等待时间长则自旋的消耗可能会小于线程阻塞再唤醒的消耗，导致cpu的浪费。  </p><h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>这个概念比较好理解，就是根据锁提出获取请求的先后顺序来分配锁，如果按顺序，那就是公平锁，如果可以插队，那就是非公平锁。<br>synchronized是非公平锁，而ReentrantLock可以通过传入参数指定是否公平。<br>我们可以来看看ReentrantLock的构造函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>   </p><p>来看看公平锁与非公平锁的差别<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>可以发现公平锁多了一个!hasQueuedPredecessors()条件，跟进<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>就是判断当前线程是否是同步队列中对的第一个。</p><h2 id="可重入锁与非可重入锁"><a href="#可重入锁与非可重入锁" class="headerlink" title="可重入锁与非可重入锁"></a>可重入锁与非可重入锁</h2><p>这个概念就是指一个线程在外层方法获得锁时，内层方法是否自动获得锁(前提是锁是同一个)，在内层自动获得锁的就是可重入锁。<br>synchronized与ReentrantLock都是可重入锁。<br>可重入锁一定程度上可以避免死锁。即在循环调用时不会出现循环等待。<br>就拿synchronized举例，假设实例中有两个方法，方法都是synchronized修饰的，所以锁住的是实例对象，而方法A中调用了方法B，如果不是可重入锁，那么在A调用B时，B会出现等待A释放锁的情况，导致死锁。  </p><p>可重入锁的原理是维护了一个status变量，来计数重入次数。当线程尝试获取锁时，先获取status值，如果status==0，表示没有其他线程在执行同步代码，就将status置为1，如果status!=0，就判断当前线程是否已经获取了这个锁，是的话status+1，并且可以继续获得锁。<br>而释放时，先获取status值，如果当前线程持有锁，则status-1，如果status这时等于0，则表示该线程重复获取锁的次数已经为0，这时就会释放锁。  </p><p>不可重入锁则是status值要嘛为1要嘛为0，如果为1则其他获取锁的操作会失败，0的时候锁释放。  </p><h2 id="独享锁-排它锁-与共享锁"><a href="#独享锁-排它锁-与共享锁" class="headerlink" title="独享锁(排它锁)与共享锁"></a>独享锁(排它锁)与共享锁</h2><p>独享锁又称排它锁，指的是该锁只能被一个线程持有。<br>而共享锁指的是锁可以被多个线程持有。<br>Java中常见的共享锁有ReadWriteLock，即读写锁，允许多个读操作或者一个写操作。<br>而Mysql中则可以使用lock in share mode来添加共享锁，其他session可以查询数据，也可以再次添加共享锁。<br>使用for update来实现排它锁。  </p><h2 id="无锁-偏向锁-轻量级锁-重量级锁"><a href="#无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="无锁 偏向锁 轻量级锁 重量级锁"></a>无锁 偏向锁 轻量级锁 重量级锁</h2><p>这几个概念放在一起说，他们的区别在于在线程竞争同步资源时，获取锁的流程细节的差别。<br>无锁就是字面意思，不锁住资源，所有线程都能访问和修改同一个资源，但只有一个线程能成功。<br>偏向锁是指同一段同步代码一直被同一个线程访问，那么之后该线程在访问这段代码时，就会自动获取锁，减少获取锁的代价。<br>轻量级锁是指在偏向锁的情况下，有其他线程访问了同步代码，那偏向锁就会变成轻量级锁，当线程尝试获取锁时，不会阻塞，而是自旋。<br>重量级锁是指在轻量级锁时，如果等待的线程自旋次数过多，或者有第三个线程访问时，升级为重量级锁，所有等待的线程都会阻塞。<br>锁的状态只能升级不能降级。   </p><p>这几种锁的实现在于Java对象头中的标记字段。  </p><hr><table><thead><tr><th style="text-align:center">锁状态</th><th style="text-align:center">前30位</th><th style="text-align:center">后2位(锁标志位)</th></tr></thead><tbody><tr><td style="text-align:center">无锁</td><td style="text-align:center">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td style="text-align:center">01</td></tr><tr><td style="text-align:center">偏向锁</td><td style="text-align:center">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td style="text-align:center">01</td></tr><tr><td style="text-align:center">轻量级锁</td><td style="text-align:center">指向栈中锁记录的指针</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">重量级锁</td><td style="text-align:center">指向互斥量（重量级锁）的指针</td><td style="text-align:center">10</td></tr></tbody></table><hr><p>首先是偏向锁，当一个线程获取锁是，会在标记字段中存储当前线程id，在进入及退出同步代码时不通过cas操作来获取锁和解锁，而是检测标记字段中是否存储着与当前线程id一致的值，与是否是偏向锁的值。<br>当其他线程竞争时，持有偏向锁的线程才会释放偏向锁。  </p><p>然后是轻量级锁，在线程进入同步块时，如果是无锁状态，就拷贝标记字段到一个名为锁记录的空间。拷贝完成后，将标记字段更新为指向锁记录的指针，然后把锁记录中的owner指针指向标记字段。<br>操作成功后，那么线程就获得该对象的锁，如果标记字段中的锁标志位为”00”，表示正处于轻量级锁状态。<br>如果操作失败，则检查标记字段是否指向当前线程，如果是，则该线程已经获得了锁，否则进行竞争。  </p><p>重量级锁，在前30位中指向重量级锁monitor的指针，标记字段中锁标志位为”10”。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上讲解了常用的锁的分类，对其进行了简单介绍，有些地方从源码方式讲解实现原理，并给出了java用法，有些地方给出了mysql的用法。<br>其实从源码去分析是十分好的方法，从源码看问题能学到更多东西。  </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java“锁”事</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天不谈设计模式，本来想写一篇从源码看hashmap，但是不传图片光靠文字要讲解清楚确实有点困难。&lt;br&gt;那我们来聊聊常见的锁的种类，锁的思
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://re0.top/tags/Java/"/>
    
      <category term="Mysql" scheme="http://re0.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之抽象工厂模式</title>
    <link href="http://re0.top/2020/08/13/abstract_factory_pattern/"/>
    <id>http://re0.top/2020/08/13/abstract_factory_pattern/</id>
    <published>2020-08-13T06:00:00.000Z</published>
    <updated>2020-08-13T07:30:03.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说实话，就算是假期，每日一到两篇的更新还是有点累的，写一篇长一点的文章差不多一个下午就过去了，但是我个人觉得写文章比较适合我学习，变写的同时能知道哪些不懂，顺便再去复习一下，也算是个不错的方式吧。<br>今天就来聊聊抽象工厂模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>之前我们讲过工厂模式，工厂模式的特点是对象的创建交给工厂来实现，隐藏内部逻辑，但是工厂模式也有相应的缺点，那就是一个工厂只能生产一类产品，但往往一个工厂需要有创建多种商品的功能，而抽象工厂模式就是为了解决这个问题。<br>抽象工厂模式简单说就是一个大工厂下有几个小工厂，小工厂实现大工厂的所有产品。它解决的就是工厂模式下，每个工厂只能创建一类产品的缺点。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>就从上次的工厂模式的案例说起，现在一个工厂既可以生产游戏，又可以生产周边，我们就从这个例子来实现抽象工厂模式。<br>首先是游戏接口及其实体类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameA</span> <span class="keyword">implements</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is Game A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameB</span> <span class="keyword">implements</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is Game B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameC</span> <span class="keyword">implements</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is Game C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接下来创建周边接口及其实现类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hobby</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HobbyA</span> <span class="keyword">implements</span> <span class="title">Hobby</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is HobbyA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HobbyB</span> <span class="keyword">implements</span> <span class="title">Hobby</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is HobbyB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HobbyC</span> <span class="keyword">implements</span> <span class="title">Hobby</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is HobbyC"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接下来是创建一个抽象工厂<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Game <span class="title">getGame</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Hobby <span class="title">getHobby</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>创建两个工厂继承抽象工厂<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Game <span class="title">getGame</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">"GameA"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GameA();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">"GameB"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GameB();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">"GameC"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GameC();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hobby <span class="title">getHobby</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HobbyFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Game <span class="title">getGame</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hobby <span class="title">getHobby</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">"HobbyA"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HobbyA();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">"HobbyB"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HobbyB();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">"HobbyC"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HobbyC();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接下来是创建工厂生成器来获取相应的工厂<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(String factoryName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (factoryName.equalsIgnoreCase(<span class="string">"Game"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GameFactory();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (factoryName.equalsIgnoreCase(<span class="string">"Hobby"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HobbyFactory();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>创建客户端进行调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractFactory gameFactory = FactoryBuilder.getFactory(<span class="string">"Game"</span>);</span><br><span class="line">        AbstractFactory hobbyFactory = FactoryBuilder.getFactory(<span class="string">"Hobby"</span>);</span><br><span class="line"></span><br><span class="line">        Game game = gameFactory.getGame(<span class="string">"GameA"</span>);</span><br><span class="line">        game.test();</span><br><span class="line"></span><br><span class="line">        Hobby hobby = hobbyFactory.getHobby(<span class="string">"HobbyC"</span>);</span><br><span class="line">        hobby.test();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>以上我们就简单实现了抽象工厂模式，其实原理还是很简单的。  </p><h2 id="后续思考"><a href="#后续思考" class="headerlink" title="后续思考"></a>后续思考</h2><p>当抽象工厂模式中，产品只有一个的时候，抽象工厂模式就是工厂模式，反过来，当产品由一个变多个时，工厂模式变为抽象工厂模式。<br>那在抽象工厂模式中，添加一个工厂需要怎么操作呢？<br>很简单，我们只需要创建一个继承于AbstractFactory的工厂就可以了。<br>那添加一个新的产品呢？<br>首先当然需要添加一个新的接口与对应的实现类，其次抽象工厂中，需要添加该产品，导致所有继承于抽象类的工厂都必须添加这个产品，只是可以不生产而已，代码上的话，如果工厂很多，就需要添加这些工厂中的重写方法。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>抽象工厂模式的优点在于解决工厂模式中只能创建单一产品的缺点。并且拥有工厂模式的优点。<br>而缺点在于产品的扩展较为麻烦，上文提到，添加产品，需要修改抽象类，又需要在实现的工厂中增加代码。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文简单谈了谈抽象工厂模式，这个模式在开发中很少用到，对整体的架构不利于扩展，修改的话又十分麻烦。工厂模式对于框架的设计还是较为常用的，比如spring的getBean，又如java中的线程池(可以看看线程池的文章)，等等很多例子。总之这个工厂模式还是比较重要的。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;说实话，就算是假期，每日一到两篇的更新还是有点累的，写一篇长一点的文章差不多一个下午就过去了，但是我个人觉得写文章比较适合我学习，变写的同时
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之中介者模式</title>
    <link href="http://re0.top/2020/08/12/mediator_pattern/"/>
    <id>http://re0.top/2020/08/12/mediator_pattern/</id>
    <published>2020-08-12T12:00:00.000Z</published>
    <updated>2020-08-12T14:20:12.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍中介者模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>中介者模式属于行为型模式，是用在多个对象之间的通信，这种模式提供一个中介类，这个类处理不同类之间的通信，使代码松耦合易维护。<br>这个模式解决的问题是类与类之间关联性较大，系统呈网状结构，而这个模式就是将网状结构分离成星型结构，来减少类之间的依赖程度。<br>常用实例有：  </p><ul><li>网络通信，例如QQ群的通信。 </li><li>MVC框架中C(Controller)就是M(Model)和V(View)之间的中介者。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>就拿网络聊天来说，聊天室可以同时有多个人聊天，而这些聊天的人不必关心其他人是否能收到消息，而是只要将消息发往聊天室，而在线的人就可以从聊天室中看到其他人的消息。<br>我们就拿这个例子来看。<br>先创建一个聊天室类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRoom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showMsg</span><span class="params">(User user,String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(System.currentTimeMillis()) +</span><br><span class="line">                <span class="string">" \""</span> + user.getName() + <span class="string">"\" : "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>这里我们设为静态方法，接收一个User对象，以及消息msg，为了方便，我直接打印在控制台中。不然应该是发送到其他对象中。   </p><p>其次我们创建User类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        ChatRoom.showMsg(<span class="keyword">this</span>,msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>我们直接在本地调用试试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User alice = <span class="keyword">new</span> User(<span class="string">"alice"</span>);</span><br><span class="line">        User bob = <span class="keyword">new</span> User(<span class="string">"bob"</span>);</span><br><span class="line">        alice.sendMsg(<span class="string">"hello, bob"</span>);</span><br><span class="line">        bob.sendMsg(<span class="string">"hi, alice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2020-08-12 21:51:33 "alice" : hello, bob</span></span><br><span class="line"><span class="comment">2020-08-12 21:51:33 "bob" : hi, alice</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>   </p><p>如此我们实现了一个简单的中介者模式。</p><h2 id="后续思考"><a href="#后续思考" class="headerlink" title="后续思考"></a>后续思考</h2><p>那其实真正的聊天室并不是这样，这里我谈谈自己的见解吧，不一定对，只是我个人的思考。  </p><p>在服务端，我们需要初始化聊天室类，其中内部维护一个列表，列表中存放着在此聊天室的人员。<br>之后初始化用户后，加入这个聊天室，例如ChatRoom.join(user，roomId)，让这个用户加入这个聊天室。join方法可以是static的，因为需要网络通信，不可能在本地生成聊天室实例。之后返回是否成功加入，以及房间的具体信息。<br>加入之后调用user.sendMsg(msg,roomId)，然后通过ChatRoom类中的方法将消息发送到服务端，服务端接收到之后，将该条消息转发给除该用户以外的所有用户。<br>至于服务端实现，则可以设计一个总服务端，并维护一个map，map中存放所有存活的聊天室，然后不设计小服务端，而是收到消息后转发给聊天室实例，这种设计对服务端要求较高。<br>而另外一种服务端设计则是在加入房间时与总服务端通信，之后服务端返回聊天室的地址，转而向聊天室服务端进行通信，这种设计减少了中控的压力。<br>以上就是一个聊天室的流程，由于涉及网络io，这里就不写代码了，大概原理了解一下。<br>但不管如何，这个模型依旧是一个中介者模式的模型。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>中介者模式降低类与类之间的耦合程度，并且由一对多关系转换成一对一关系。<br>而缺点在于中介者会很庞大，不利于维护，当中介者失效后，所有类则无法工作。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了中介者模式，以及实现了一个简单例子，中介者模式与代理模式还有外观模式有点相似，其相同点与不同点就留到外观模式之后再讲吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文介绍中介者模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之工厂模式</title>
    <link href="http://re0.top/2020/08/12/factory_pattern/"/>
    <id>http://re0.top/2020/08/12/factory_pattern/</id>
    <published>2020-08-12T06:00:00.000Z</published>
    <updated>2020-08-12T07:30:06.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文讲讲工厂模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>工厂模式是Java中常用的一种设计模式，它属于创建型模式的一种，又称为工厂方法模式，这种模式提供了创建对象的一种方法，对客户端隐藏生成对象的逻辑，使用一个接口来指向新的对象。<br>常见的实例有：  </p><ul><li>工厂提供多种产品，你可以直接购买，无需关心如何制作。</li><li>日志管理，可以使用多种方式记录，并且可以记录到本地，远程等等。</li><li>数据库访问，不知道系统最后使用哪种数据库时，封装可用的数据库。</li></ul><p>当对象较为复杂时，使用工厂模式较为适合，如果对象十分简单，那直接使用new生成就可以了。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>下面我们用一个例子来实现工厂模式。<br>例如游戏公司要制作几个新的游戏。<br>我们将创建一个游戏Game接口，以及实现它的实体类，然后创建工厂去制作游戏。<br>我们先定义Game接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>接着定义几个游戏A,B,C<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameA</span> <span class="keyword">implements</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is Game A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameB</span> <span class="keyword">implements</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is Game B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameC</span> <span class="keyword">implements</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is Game C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>接着创建工厂，根据名称生成实体类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Game <span class="title">getGame</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">"GameA"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GameA();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">"GameB"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GameB();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">"GameC"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GameC();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着编写客户端进行调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GameFactory gameFactory = <span class="keyword">new</span> GameFactory();</span><br><span class="line"></span><br><span class="line">        Game game1 = gameFactory.getGame(<span class="string">"GameA"</span>);</span><br><span class="line">        game1.test();</span><br><span class="line"></span><br><span class="line">        Game game2 = gameFactory.getGame(<span class="string">"GameB"</span>);</span><br><span class="line">        game2.test();</span><br><span class="line"></span><br><span class="line">        Game game3 = gameFactory.getGame(<span class="string">"GameC"</span>);</span><br><span class="line">        game3.test();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">this is Game A</span></span><br><span class="line"><span class="comment">this is Game B</span></span><br><span class="line"><span class="comment">this is Game C</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>   </p><h2 id="后续思考"><a href="#后续思考" class="headerlink" title="后续思考"></a>后续思考</h2><p>以上我们就实现了一个简单的工程模式示例，当然从上述工厂的代码来看，肯定是不够优雅的，毕竟我们需要写很多的if else，或者case语句。<br>那我自己想到的点是，通过一个枚举类或者常量，提供所有可以创建对象的关键字，然后通过关键字所对应的值，来进行反射创建操作。<br>例如创建一个GameType类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String GameA = GameA.class.getName();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String GameB = GameB.class.getName();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String GameC = GameC.class.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>修改GameFactory<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Game <span class="title">getGame2</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Game) Class.forName(type).newInstance();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>对应client<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">Game game = gameFactory.getGame2(GameType.GameA);</span><br><span class="line">game.test();</span><br></pre></td></tr></table></figure>  </p><p>算是少些了一下冗余吧，当然也可以使用枚举类，这里就不再多写了。优化一下就少了许多if else。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>工厂模式的优点在于客户端只需知道名称就可以创建一个对象，并且拓展性较好，而且屏蔽了类的具体实现。<br>而缺点就是在增加一个产品之后，就需要添加具体类与修改工厂，增加系统的复杂性。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文总结了简单工厂模式，当然，从本文的例子看并不需要工厂模式去创建对象，但是当对象较为复杂时，例如对象依赖于其他对象，那在客户端中就没必要自己实现对象，而是交给工厂实现。而当客户端不知道需要创建对象的类时，也可以使用工厂模式来设计系统。<br>之后会讲讲工厂模式的进阶，抽象工厂模式，算是一个比较难的模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文讲讲工厂模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Spring AOP</title>
    <link href="http://re0.top/2020/08/10/spring_aop/"/>
    <id>http://re0.top/2020/08/10/spring_aop/</id>
    <published>2020-08-10T13:10:00.000Z</published>
    <updated>2020-08-11T08:05:47.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇提到Spring AOP中使用了代理模式。其实spring aop很早我就想写文章，因为它和ioc属于spring中最重要的两个概念之一。那这篇就好好讲讲spring aop。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><p>AOP(Aspect Oriented Programming)，中文翻译为面向切面编程，那啥是面向切面编程？我只听过面向对象编程啊？<br>其实AOP是OOP的延续，并不能完全替代OOP，他们的理念不一样，OOP是对对象进行封装，而AOP则是对某个业务进行切面提取，侧重点并不一样。<br>我们在编程时，如果有代码的重复，我们一般会将代码封装成对象或者方法，再去调用，这种抽取被称为纵向抽取，但当某个部分的逻辑分散在各个业务中时，我们往往无法进行纵向抽取，而AOP的目的就是将各个业务中相同的代码通过切割的方式抽取到一个独立逻辑中。然后将切割出来的代码再融入到其他业务中，完成与之前相同的功能。   </p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>按上面所讲，我们需要切割逻辑，并且完成与之前一样的功能，那我们就可以使用到之前提到的代理模式，通过增强对象，来实现对访问对象的改造或者增强，即在中间层加入相应逻辑。<br>要说aop原理，就不得不提代理，代理分为静态代理与动态代理，静态代理就是自己编写代理层，自己拦截需要拦截的方法并增强，可以见上一篇文章。<br>而spring aop的底层是动态代理。<br>那啥是动态代理？我们先看以下例子：<br>如果我们要实现一个接口，那一般情况下我们会编写实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">areYouOk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">areYouOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Are you ok?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>然后将HelloImpl实例化，调用。<br>那有没有可能我们不编写实现类，就直接在运行时创建接口的实例呢？答案是有，并且在Java标准库中提供了一种动态代理的机制，只需要预先知道接口，就可以在运行时动态生成实现类。而实现的方法就是reflect包中的Proxy.newProxyInstance()方法。<br>reflect包，诶？不就是反射操作的包吗？没错，动态代理也属于反射的一种。我们来看看怎么动态生成实现类。<br>首先newProxyInstance方法需要三个参数，第一个参数是类加载器ClassLoader，官方解释是loader the class loader to define the proxy class，其实就是定义由哪个classloader对生成的代理类进行加载。第二个参数是一个interface对象数组，也就是要我们需要实现哪些接口。第三个参数，一个InvocationHandler对象，代理的核心参数，当执行代理生成实现类时，会调用这个对象的invoke方法。可以在这个方法中处理逻辑。写一下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"areYouOk"</span>))&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Are you ok?"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Hello hello = (Hello) Proxy.newProxyInstance(Hello.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;Hello.class&#125;,</span><br><span class="line">                handler);</span><br><span class="line">        hello.areYouOk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>其中要简单说明下，invoke方法三个参数，第一参数是代理对象，第二个是调用方法，第三个是传入的参数。要注意在invoke中不能调用proxy参数，否则会导致永久递归，栈溢出。<br>动态代理本质上就是JDK在运行时动态创建class字节码并加载，这和之前谈过的反射一致。它只是帮我们编写了一个实现类，仅此而已。  </p><h3 id="JDK-Proxy-与-CGLib-Proxy"><a href="#JDK-Proxy-与-CGLib-Proxy" class="headerlink" title="JDK Proxy 与 CGLib Proxy"></a>JDK Proxy 与 CGLib Proxy</h3><p>在Java中，动态代理有两种，一种是JDK动态代理，另一种是CGlib动态代理。<br>JDK动态代理就是上文所讲的，需要实现一个类所使用的代理。而如果类没有实现接口，那就会使用CGLib代理。JDK动态代理本质上就是反射，但必须需要实现的接口。而CGLib动态代理是基于ASM机制，通过生成子类来作为代理类。<br>JDK动态代理的缺点就是只能基于接口。<br>CGLib是采用十分底层的字节码技术，原理是创建子类，拦截父类中的方法来实现代理，优点就是没有接口的类也能实现动态代理，而缺点则是实现相对较难。  </p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>动态代理相对于静态代理，是通过动态生成代理类来实现代理技术，拦截并增强方法，将原本相同逻辑的代码抽取出来，并注入到目标对象，实现与原来一致的功能。动态代理分为JDK动态代理与CGLib动态代理，Spring AOP中默认使用JDK动态代理，当类没有接口时，才使用CGLib代理。    </p><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="部分概念"><a href="#部分概念" class="headerlink" title="部分概念"></a>部分概念</h3><p>上文简单讲了动态代理的概念，那既然知道Spring AOP是使用动态代理了，那啥是Spring AOP呢？<br>首先我们需要了解几个AOP中常见的名词。  </p><ul><li>连接点(Join Point): 即需要拦截的地方。</li><li>切点(Poincut): 即具体定位的连接点。  </li><li>增强/通知(Advice): 表示需要添加到切点的逻辑，Spring AOP中有多种类型。  </li><li>切面(Aspect): 切面由切点和增强/通知组成，包括横切逻辑与连接点的定义。</li></ul><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>了解了上述的概念之后，我们继续讲怎么实现AOP。如今实现AOP已经不再使用手动实现接口的方法，而是使用更加简洁方便的@Aspect注解方式。<br>我们来简单实现一个记录日志的功能。来看看如何使用AOP。<br>我们需要先知道Spring中Advice的注解有哪些：  </p><hr><table><thead><tr><th style="text-align:center">注解</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">@Before</td><td style="text-align:center">前置通知，在连接点方法前调用</td></tr><tr><td style="text-align:center">@Around</td><td style="text-align:center">环绕通知，它将覆盖原有方法，但是允许你通过反射调用原有方法</td></tr><tr><td style="text-align:center">@After</td><td style="text-align:center">后置通知，在连接点方法后调用</td></tr><tr><td style="text-align:center">@AfterReturning</td><td style="text-align:center">返回通知，在连接点方法执行并正常返回后调用，要求连接点方法在执行过程中没有发生异常</td></tr><tr><td style="text-align:center">@AfterThrowing</td><td style="text-align:center">异常通知，当连接点方法异常时调用</td></tr></tbody></table><hr><p>这里Before和AfterThrowing很好理解，一个是方法调用之前，另一个是异常之后。而After和AfterReturning的区别在于After是无论是否发生异常都会触发，而AfterReturning只在正常返回后才会触发。至于Around，可以理解成Before和After结合，可以决定在目标的什么时候执行。或者直接阻止运行，功能十分强大。<br>接下来我们来看看具体实现<br>新建一个springboot项目，并写下一个controller：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">helloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>接下来我们先定义切点，spring中使用execution中的正则表达式来判断具体要拦截的类和方法，可以在上面这些注解里直接定义拦截的方法，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(public * com.example.aop_test.helloController.*(..))"</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>  </p><p>首先*表示任意返回值，接着跟类的全限定名，之后*(..)表示返回值为任意的全部方法，等价于*(*)。<br>但是这么写的话需要每个advice注解中都需要这么长的定义，我们可以通过对一个方法定义@Pointcut注解来避免书写多次execution。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebLogAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = Logger.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.example.aop_test.helloController.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webLog</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        logger.info(joinPoint.toString());</span><br><span class="line">        logger.info(<span class="string">"before"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(returning = <span class="string">"ret"</span>,pointcut = <span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(Object ret)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        logger.info(<span class="string">"RESPONSE : "</span> + ret);</span><br><span class="line">        logger.info(<span class="string">"after returning"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span>  Throwable</span>&#123;</span><br><span class="line">        logger.info(<span class="string">"after "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>@AfterReturning注解中可以定义returning参数，来获取切点的返回值。这里没什么问题，但如果我在controller中加入一段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"123"</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"ex"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>  </p><p>那这时候只有before和after生效，因为没有正常返回，所以afterreturning没有执行。<br>再来看看环绕通知@Around，这是spring aop中最强大的通知，这个方法传入一个ProceedingJoinPoint对象，在执行joinPoint.proceed()之前就是before通知，出现异常就是afterThrowing，之后就是after通知：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"webLog()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    Object res = <span class="keyword">null</span>;</span><br><span class="line">    logger.info(<span class="string">"before"</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        res = joinPoint.proceed();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable throwable)&#123;</span><br><span class="line">        logger.info(<span class="string">"ex"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">"after"</span>);</span><br><span class="line">    <span class="keyword">return</span> (res != <span class="keyword">null</span>)?res : <span class="string">"other"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>   </p><p>当然，如果不执行proceed方法就那就相当于阻止了当前方法。所以我们可以通过这个点来做权限管理。<br>我们先设置切点只在hello方法执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.example.aop_test.helloController.hello(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webLog</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>hello方法不变，创建一个新的方法来设置cookie<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam String name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/set"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">setCookie</span><span class="params">(HttpServletResponse response, @RequestParam String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>)&#123;</span><br><span class="line">        name = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"name"</span>,name);</span><br><span class="line">    response.addCookie(cookie);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>接着是@Around方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"webLog()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    Object res = <span class="keyword">null</span>;</span><br><span class="line">    ServletRequestAttributes attributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();</span><br><span class="line">    HttpServletRequest request = attributes.getRequest();</span><br><span class="line">    Cookie[] cookies =  request.getCookies();</span><br><span class="line">    Map&lt;String,Cookie&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cookies.length;i++)&#123;</span><br><span class="line">        map.put(cookies[i].getName(),cookies[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(<span class="string">"name"</span>))&#123;</span><br><span class="line">        String cookieName = map.get(<span class="string">"name"</span>).getValue();</span><br><span class="line">        <span class="keyword">if</span> (cookieName.equals(<span class="string">"admin"</span>))&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                res = joinPoint.proceed();</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Throwable throwable)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"not admin"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>这里通过RequestContextHolder来获取request，并获取所有cookie存放在map中，通过对比cookie值是否为admin来判断是否执行controller方法，做到权限管理。当然，项目中的比较需要去redis对比token值是否失效，然后对比权限才能真正做到登录与权限管理。这里只是写个思路而已。   </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>讲到这里，差不多把spring aop基础讲完了，从代理模式一直讲到aop，再到如何使用，一路下来我也复习了好多知识，包括动态代理与spring aop，这里有一点，spring aop只是帮我们实现代理模式而已，自动添加中间层来对访问对象的控制，开发中是十分好用的。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上篇提到Spring AOP中使用了代理模式。其实spring aop很早我就想写文章，因为它和ioc属于spring中最重要的两个概念之一
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="java" scheme="http://re0.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之代理模式</title>
    <link href="http://re0.top/2020/08/10/proxy_pattern/"/>
    <id>http://re0.top/2020/08/10/proxy_pattern/</id>
    <published>2020-08-10T08:00:00.000Z</published>
    <updated>2020-08-10T09:39:21.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天来讲讲结构型模式的一种——代理模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念与介绍"><a href="#概念与介绍" class="headerlink" title="概念与介绍"></a>概念与介绍</h2><p>代理模式其实在日常生活中的例子很多，比如买东西的时候，代售点就是代理模式的一种，再比如代理上网，这个对许多人并不陌生，这里就不再多说(小声)。<br>那代理模式的主要意图就是由于访问目标有种种困难或问题，或者说无法访问，只有通过另一个对象才能访问这个对象，那这种模式就称作代理模式。<br>代理模式常用的场景有：  </p><ul><li>无法直接访问对象</li><li>访问对象有困难</li><li>不想直接访问对象，想在中间做控制</li></ul><p>通常在这些需求下，通过代理模式，来间接访问对象。  </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们用实际例子来实现代理模式。<br><code>由于新发售的游戏只在日本本土上架，要购买这款游戏必须通过代购入手。</code><br>即<code>代购(代理对象)代替我(真实对象)去买游戏(间接访问的操作)</code>。<br>首先，我们创建对象接口(Subject)，不管是真实对象，还是代理对象都会实现这个接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyGameFromJapan</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>其次我们创建真实对象，即”我”:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyGameFromJapan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"买了一部游戏"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>创建代理对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyGameFromJapan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RealSubject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        realSubject.buyGameFromJapan();</span><br><span class="line">        <span class="keyword">this</span>.doOtherThing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOtherThing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 记录购买的时间</span></span><br><span class="line">        System.out.println(<span class="string">"购买时间为："</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(System.currentTimeMillis()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>最后客户端调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.buyGameFromJapan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">买了一部游戏</span></span><br><span class="line"><span class="comment">购买时间为：2020-08-10 16:13:31</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>   </p><p>以上我们通过一个例子实现了代理模式，代理模式与之前的观察者模式类似，对象在初始化时，可以选择隐式初始化，即我们在Proxy中初始化了一个RealSubject，又可以在客户端中初始化realSubject，传进Proxy。两种方式都可以。<br>那有些同学就好奇，这么做有啥意义，我直接在自己realSubject中自己写一个方法调用不就好了吗？其实不然，如果有许多的委托类，每个类的方法都不一样，那么就需要我去内部查看调用方法，而代理模式就是为了让客户端无需关心对象内部的具体实现内容，而是交给代理类去实现，从而屏蔽不同委托类之间的差异。<br>其实简单来说，就是让客户端只关心调用，而不关心怎么实现。  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>代理模式的优点前面也提到过，即协调了调用者和被调用者，有效地降低系统耦合度。其次，代理位于客户端与目标对象中间，可以保护对象，并增加具体操作。<br>缺点则是由于增加了一层代理，访问速度可能受到影响。其次是去实现代理模式可能会较为复杂。  </p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>代理模式应用场景很多，主要有：</p><ul><li>保护原始对象，根据用户不同提供不同权限。</li><li>降低对象大小，使用小对象代理大对象，减少系统开销。</li><li>访问远程对象，由于远程对象实现逻辑不同，需要代理来协商。</li><li>需要额外操作，在操作对象时，需要额外操作，例如记录日志等。  </li></ul><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>本文从一个例子讲解了代理模式的实现，以及代理模式常用场景，顺带一提，Spring AOP中也使用了代理模式，如果有时间的话，后续会继续谈谈Spring AOP中的代理。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天来讲讲结构型模式的一种——代理模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之观察者模式</title>
    <link href="http://re0.top/2020/08/08/observer/"/>
    <id>http://re0.top/2020/08/08/observer/</id>
    <published>2020-08-08T06:00:00.000Z</published>
    <updated>2020-08-08T09:09:06.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇谈谈观察者模式。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们在开发的时候，常常会有这样的需求场景：一个对象的某个状态更新了，与这个对象相关的所有对象都要跟着更新。但这些相关对象又不能直接写在类中，这时候我们就需要一个观察者帮助我们在一个对象更新后，通知其他对象跟着更新。<br>常见的场景有：发布订阅模型，例如公众号的发布就属于被观察者，而用户属于观察者。再比如游戏开发中，当角色触发某个机制时，对应通知相关的增益或者负增益，这些都可以使用观察者模式来解决。  </p><h2 id="初步"><a href="#初步" class="headerlink" title="初步"></a>初步</h2><p>最近在写的一个游戏脚本中，有这么一个场景：当角色进行攻击之后，附近如果有增益道具就会回复血量。<br>最简单的设计方法是设计一个事件循环，每隔一段时间判断角色是否攻击完成，并且是否判断道具是否在角色附近，但这个会形成空转，容易造成资源的浪费，并且无法进行实时的检测。<br>其次我还想到一种方法，那就是让把道具当作成员写进角色类，然后当角色攻击后，通知道具进行检测。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    Buff buff;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"角色攻击"</span>);</span><br><span class="line">        buff.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>那这个代码的问题在于Buff类本身就不属于Role，并且如果后续需要添加更多增益效果，那就必须修改Role类，导致类与类过于耦合。<br>这时候我们就需要观察者模式，减少代码之间的耦合。     </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在观察者模式中，有两个角色，观察者(Observer)与被观察者(Subject)，其中被观察者中有一个List，存放着所有注册的观察者们，当被观察者更新时，通知其他观察者相应进行更新。就按照上面这个例子，我来写写代码：<br>我们先创建抽象类Subject，即被观察者以及创建Observer接口，即观察者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">        observerList.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delObserver</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">        observerList.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observerList)&#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着我们创建增益类，实现观察者接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Buff</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inNear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断角色是否在附近，这里逻辑就不写了</span></span><br><span class="line">        <span class="comment">// 一般是判断半径几米</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inNear())&#123;</span><br><span class="line">            System.out.println(<span class="string">"角色获得Buff"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><p>然后创建角色类，继承抽象类被观察者Subject，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> <span class="keyword">extends</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"角色攻击"</span>);</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><p>接着我们需要Client类实现一个客户端，注册所有观察者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Role role = <span class="keyword">new</span> Role();</span><br><span class="line">        Buff buff = <span class="keyword">new</span> Buff();</span><br><span class="line">        <span class="comment">// 注册观察者</span></span><br><span class="line">        role.addObserver(buff);</span><br><span class="line">        role.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><p>我们运行查看输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">角色攻击</span><br><span class="line">角色获得Buff</span><br></pre></td></tr></table></figure>  </p><p>这里有一点，在被观察者注册事件中，我们既可以像上文一样显式进行注册，又可以在被观察者的构造函数中就进行注册，我们只需要把观察者对象传入被观察者中，然后进行注册就可以了，算是两种不同的写法吧，上文的写法更加清楚，并且依赖关系并没有那么强。<br>其次我们还可以实现更多的观察者，在client中进行注册，使得多个事件可以同时进行更新。例如我们可以添加掉落物品，附近怪物会被吸引等等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">monster</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isNear())&#123;</span><br><span class="line">            System.out.println(<span class="string">"附近怪物被吸引"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Treasure</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isNear())&#123;</span><br><span class="line">            System.out.println(<span class="string">"获得宝箱"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Role role = <span class="keyword">new</span> Role();</span><br><span class="line">        Buff buff = <span class="keyword">new</span> Buff();</span><br><span class="line">        Treasure treasure = <span class="keyword">new</span> Treasure();</span><br><span class="line">        Monster monster = <span class="keyword">new</span> Monster();</span><br><span class="line">        <span class="comment">// 注册观察者</span></span><br><span class="line">        role.addObserver(buff);</span><br><span class="line">        role.addObserver(treasure);</span><br><span class="line">        role.addObserver(monster);</span><br><span class="line">        role.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">System out：</span></span><br><span class="line"><span class="comment">角色攻击</span></span><br><span class="line"><span class="comment">角色获得Buff</span></span><br><span class="line"><span class="comment">获得宝箱</span></span><br><span class="line"><span class="comment">附近怪物被吸引</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure> </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>使用观察者模式的优点就是解耦，使对象之间的关系弱化，并且可以统一触发机制。<br>而缺点则是被观察者如果有许多观察者的话，通知所有的观察者可能需要花费很多时间。并且由于一个类既可以是观察者也可以是被观察者，如果有循环依赖的话，会导致不断调用。其次观察者模式只能知道目标发生了改变，但却无法知道怎么发生变化的。   </p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>本文总结了观察者模式，写这个模式是因为最近在写的一个脚本中出现了类似的需求，就先把这个模式整理重新学习了一遍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇谈谈观察者模式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="http://re0.top/2020/08/07/singleton/"/>
    <id>http://re0.top/2020/08/07/singleton/</id>
    <published>2020-08-07T06:00:00.000Z</published>
    <updated>2020-08-07T09:22:58.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天就来谈谈常见的设计模式——单例模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单例模式属于创建型模式，这个设计模式涉及到一个单一的类，这个类负责创建自己的对象，又确保只有单个对象被创建，提供了一个全局唯一的实例化对象。它的目的是为了控制实例的数目，又或者是实例是单一的情况下，例如一个设备同时只能有一个对象进行操作。<br>而实现单例模式的关键代码就是将构造函数设为私有，不允许外部创建实例。  </p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>实现的方法很简单，我直接给出代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleDemo instance = <span class="keyword">new</span> SingleDemo();</span><br><span class="line">    <span class="comment">// 构造函数设为私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleDemo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>这里需要注意的是，我们初始化instance是就直接new SingleDemo()，则此时在getInstance就无需判空处理，这种写法被称为饿汉模式。由于装载类时就已经初始化了instance对象，所以这种方法是线程安全的。    </p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉式则是初始将对象设置为null，等有需要时在进行new操作。饿汉式和懒汉式十分形象，饿汉主动找食物，而懒汉等着别人给。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleDemo instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleDemo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><h2 id="懒汉式线程安全"><a href="#懒汉式线程安全" class="headerlink" title="懒汉式线程安全"></a>懒汉式线程安全</h2><p>以上的懒汉式并不能保证线程安全，当两个线程同时判断instance == null时，同时通过了判断，导致new出了不同的对象。我们可以通过synchronized关键字锁住getInstance方法保证单例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleDemo instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleDemo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingleDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><p>但这种方法会较为影响效率，由于在静态方法上使用synchronized关键字，所以同时只有一个线程能够进入方法内部，导致效率问题。  </p><h2 id="双重校验锁-DCL"><a href="#双重校验锁-DCL" class="headerlink" title="双重校验锁(DCL)"></a>双重校验锁(DCL)</h2><p>先上代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleDemo instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleDemo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleDemo.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingleDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>   </p><p>这个方法就是为了解决上面的效率问题。之所以使用双重检测，是因为多线程情况下，由于方法并不是synchronized修饰的，会导致多个线程同时进入方法进行第一次判空，如果此时instance还未初始化，才会进入临界区域，锁住临界区后，再次进行判空，因为此时前一个线程有可能已经完成了对象创建，而后一个线程才刚刚好进入临界区，所以需要二次判空。<br>之所以效率比上一个方法高，是因为只有初始化对象时才会进行对象的创建，创建对象的时候才会出现同步的问题，其他情况下直接获取instance就可以了，所以不锁住方法的效率更高一些。  </p><h2 id="DCL改进"><a href="#DCL改进" class="headerlink" title="DCL改进"></a>DCL改进</h2><p>上面的DCL并不是完整的线程安全，原因是JVM在编译时有可能进行指令地重排。举个例子：<br>例如instance = new SingleDemo()，这一行代码在JVM中可能被分为三个步骤：  </p><ol><li>分配对象的内存</li><li>初始化对象</li><li>令instance指向刚才分配的内存</li></ol><p>但这个步骤并不是一成不变的，JVM或者CPU会通过优化，改变成以下顺序：  </p><ol><li>分配内存</li><li>令instance指向刚才分配的内存</li><li>初始化对象</li></ol><p>所以当A线程做完如上1,2步时，instance已经指向了刚才分配的内存了，但并没有初始化，而如果此时B线程才刚开始进行第一次判空时，由于instance已经不是null了，所以B线程直接返回了一个还未初始化的对象。<br>基于以上原因，我们需要使用volatile修饰instance对象，阻止指令重排，保证instance不会出现中间态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingleDemo instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleDemo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingleDemo.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingleDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   </p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>由于从外部无法访问静态内部类，所以只有在getInstance方法才能获得instance对象。<br>而静态内部类的加载并不是在外部类被加载时被加载，而是当需要使用时才进行加载，来保证懒加载的机制，由于使用的classloader的机制，所以是线程安全的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleDemo INSTANCE = <span class="keyword">new</span> SingleDemo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleDemo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>以上的方法虽然是私有的构造方法，但是依旧可以使用反射的方法来创建多个实例，关于反射，详见<a href="/2020/03/22/java-reflection/">这篇文章</a>。<br>而有没有什么方法来限制反射呢？答案就是枚举，代码很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当我们使用反射时获取对象时，会抛出NoSuchMethodException，阻止了反射。<br>而这种方法可以防止被多次实例化，是线程安全的，并且支持序列化机制，保证反序列化后返回的都是同一个对象，唯一缺点就是并非懒加载。<br>这种方法实际中使用较少。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天整理了几种单例模式，对单例模式重新复习了一下，在项目中，最常用的应该就是饿汉模式，其他模式用的较少，需要反序列化则可以使用枚举，或者实现readResolve()方法。<br>以上，愿好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天就来谈谈常见的设计模式——单例模式。  &lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>谈谈设计模式</title>
    <link href="http://re0.top/2020/08/06/design_patterns/"/>
    <id>http://re0.top/2020/08/06/design_patterns/</id>
    <published>2020-08-06T13:10:00.000Z</published>
    <updated>2020-09-02T07:34:18.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设计模式是提高代码可读性的途径之一，面对不同的场景选择不同的设计模式，可以提高代码可读性，提高代码的可重用性还有可扩展性。接下来就讲讲什么是设计模式。  </p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="何为设计模式"><a href="#何为设计模式" class="headerlink" title="何为设计模式"></a>何为设计模式</h2><p>设计模式是在面向对象语言中，思想都是一致的，而在面向过程语言，函数式编程的语言中讨论设计模式是没有意义的。所谓的设计模式，就是前面提到的，在面向对象编程中的一些”套路”，在面对不同需求场景时，可以选择不同的设计模式，来提高代码的可读性，重用性与扩展性。   </p><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>在GoF设计模式书籍中，共有23种设计模式。<br>而这23种设计模式又可以分为三大类型:  </p><ul><li>创建型模式</li><li>结构型模式</li><li>行为型模式</li></ul><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>这一类设计模式的目的是为了创建对象。其中包括：  </p><ol><li><a href="/2020/08/13/abstract_factory_pattern/">抽象工厂模式</a></li><li><a href="/2020/08/12/factory_pattern/">工厂方法模式</a></li><li><a href="/2020/08/07/singleton/">单例模式</a></li><li><a href="/2020/09/02/prototype_pattern/">原型模式</a></li><li>构建模式</li></ol><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>这一类设计模式是为了优化不同类，对象，接口之间的结构关系。其中包括：  </p><ol><li><a href="/2020/08/10/proxy_pattern/">代理模式</a></li><li><a href="/2020/08/17/decorator_pattern/">装饰器模式</a></li><li>组合模式</li><li>桥接模式</li><li><a href="/2020/08/22/adapter_pattern">适配器模式</a></li><li><a href="/2020/08/16/facade_pattern/">外观模式</a></li><li>享元模式</li></ol><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>这一类设计模式的目的是更好地实现类与类之间的交互还有算法的执行。包括：  </p><ol><li><a href="/2020/08/27/strategy_pattern/">策略模式</a></li><li><a href="/2020/08/17/command_pattern/">命令模式</a></li><li>状态模式</li><li>责任链模式</li><li>解释器模式</li><li><a href="/2020/08/08/observer/">观察者模式</a></li><li>备忘录模式</li><li><a href="/2020/08/27/iterator_pattern/">迭代器模式</a></li><li>模板方法模式</li><li>访问者模式</li><li><a href="/2020/08/12/mediator_pattern/">中介者模式</a></li></ol><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>以上就是全部设计的种类。因为随着不断进步，设计模式远不止这一些，但掌握这些设计模式在日常编程中就可以有效保证代码的健康。<br>算是挖了一个新的大坑吧，之后会陆陆续续写写这23种设计模式的理解与实现。<br>2020.08.07 单例模式<br>2020.08.08 观察者模式<br>2020.08.10 代理模式<br>2020.08.12 工厂方法模式,中介者模式<br>2020.08.13 抽象工厂模式<br>2020.08.16 外观模式<br>2020.08.17 命令模式,装饰器模式<br>2020.08.22 适配器模式<br>2020.08.27 策略模式,迭代器模式<br>2020.09.02 原型模式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;设计模式是提高代码可读性的途径之一，面对不同的场景选择不同的设计模式，可以提高代码可读性，提高代码的可重用性还有可扩展性。接下来就讲讲什么是
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://re0.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>谈谈Spring IoC</title>
    <link href="http://re0.top/2020/08/06/spring_ioc/"/>
    <id>http://re0.top/2020/08/06/spring_ioc/</id>
    <published>2020-08-06T05:10:00.000Z</published>
    <updated>2020-08-06T07:13:51.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>IoC本身来说并不是一种技术，而是一种思想。在spring开发中我们常常使用，但有时候想起来这个概念时，却不知道从何说起。本文就来谈谈spring中的核心概念——IoC。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="IoC概念"><a href="#IoC概念" class="headerlink" title="IoC概念"></a>IoC概念</h2><p>IoC(Inversion of Control)中文名“控制反转”，它是一种设计的思想。Ioc代表着你将对象交给容器来控制，而不是自己控制对象本身。为什么是反转呢？举个例子：<br>我们在传统的开发中，通常是通过new关键字在对象内部使用另一个对象，是我们主动去创建依赖的对象。而Ioc则是有一个专门的容器来创建这些对象。我们通过自己主动控制生成对象的方式也叫做正转，而使用容器控制创建对象并注入的方式，就称作反转。</p><h2 id="IoC的作用"><a href="#IoC的作用" class="headerlink" title="IoC的作用"></a>IoC的作用</h2><p>IoC常常被用在大型框架上，由IoC容器去创建去查找依赖的对象，由容器去注入对象，使得对象之间是松耦合的，方便测试与功能的复用，也利于维护，让整体架构更加灵活。  </p><h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><p>前面提到了注入，也就是DI(Dependency Injection)，即“依赖注入”，是指组件之间的依赖关系由容器在运行期决定，即容器动态地将某个依赖关系注入到组件中。通过依赖注入，我们只需完成业务逻辑，无需关心资源的来源于由谁决定，一切都由容器帮忙注入依赖。</p><h2 id="IoC的技术实现"><a href="#IoC的技术实现" class="headerlink" title="IoC的技术实现"></a>IoC的技术实现</h2><p>既然已经清楚IoC的概念，那IoC容器又是怎么完成依赖注入呢？常见的方式有两种，构造器方法注入与setter注入。<br>构造器注入是指在对象创建时，所依赖的对象便以参数形式传入该对象中。假设在A类中需要B类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而setter方法注入则是在需要的时候才执行注入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而无论是哪种方法，IoC容器都帮你执行了，你无需关心注入的过程。  </p><h2 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h2><p>这里就简单介绍下IoC容器。<br>Spring 提供了两种IoC容器，BeanFactory和ApplicationContext，而ApplicationContext是BeanFactory的子类。BeanFactory 和 ApplicationContext 的区别有：<br>BeanFactory：是Spring中最底层的接口，只提供了最简单的IoC功能,负责配置，创建和管理bean。<br>在应用中，一般不使用 BeanFactory，而推荐使用ApplicationContext（应用上下文），原因如下。<br>ApplicationContext：</p><ol><li>继承了 BeanFactory，拥有了基本的 IoC 功能；</li><li>除此之外，ApplicationContext 还提供了以下功能：</li></ol><ul><li>支持国际化；</li><li>支持消息机制；</li><li>支持统一的资源加载；</li><li>支持AOP功能；</li></ul><h2 id="IoC容器初始化与依赖注入"><a href="#IoC容器初始化与依赖注入" class="headerlink" title="IoC容器初始化与依赖注入"></a>IoC容器初始化与依赖注入</h2><p>我们知道，IoC容器负责管理对象，而spring中最基本的一个对象就是Bean。<br>Bean的定义与初始化是两大步骤，Bean在定义后，IoC容器才将其初始化并注入到其他对象中。<br>Bean的定义有3步：  </p><ol><li>Resource 定位<br>Spring IoC 容器先根据开发者的配置，进行资源的定位，在 Spring 的开发中，通过 XML 或者注解方式查找资源。  </li><li>BeanDefinition 的载入<br>这个时候只是将 Resource 定位到的信息，保存到 Bean 定义（BeanDefinition）中，此时并不会创建 Bean 的实例</li><li>BeanDefinition 的注册<br>这个过程就是将 BeanDefinition 的信息发布到 Spring IoC 容器中。   </li></ol><p>但此时Bean并没有被初始化，只是在容器中被定义了。在Spring Bean的配置中，有个配置选项lazy-init，指定是否初始化Bean，默认值为false，即自动初始化，而设置为true则只有当使用getBean方法获取Bean时，才会进行Bean的初始化，完成依赖注入。  </p><h2 id="如何实现IoC容器？"><a href="#如何实现IoC容器？" class="headerlink" title="如何实现IoC容器？"></a>如何实现IoC容器？</h2><p>实现一个IoC容器有以下几个步骤。  </p><ol><li>通过注解或者配置文件，查看A类的依赖对象是哪个类，获取类名。  </li><li>使用反射API，将类名实例化成对象实例。  </li><li>将实例化对象通过构造函数或者setter方法，传递给A类。  </li></ol><p>其实Spring就是基于以上几个步骤实现IoC，IoC就是工厂模式的升级版。  </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文基本上都是基础知识，重点讲了IoC的概念，并顺便谈了IoC的实现原理，之后有需要的话可能会深入spring源码了解更多IoC的细节，比如BeanFactory和ApplicationContext。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;IoC本身来说并不是一种技术，而是一种思想。在spring开发中我们常常使用，但有时候想起来这个概念时，却不知道从何说起。本文就来谈谈spr
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="java" scheme="http://re0.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java线程池</title>
    <link href="http://re0.top/2020/07/24/java_thread_pool/"/>
    <id>http://re0.top/2020/07/24/java_thread_pool/</id>
    <published>2020-07-24T05:10:00.000Z</published>
    <updated>2020-07-24T10:05:42.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇来讲讲Java中线程池的使用与分析。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>阿里巴巴Java开发手册中强调，线程资源必须通过线程池来提供，不允许显式创建线程。<br>首先我们讲讲普通的线程创建方式。  </p><h2 id="Java线程创建方式"><a href="#Java线程创建方式" class="headerlink" title="Java线程创建方式"></a>Java线程创建方式</h2><p>在Java语言中，我们通过两种方式创建一个新线程，分别是继承Thread类或者实现Runnable接口。</p><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>Thread类本质上是实现了Runnable接口的一个实例，启动线程的方法是通过Thread类的start方法，这个方法是native方法，它将启动线程，并在获得时间片后执行run方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThread run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><p>如果该类已经继承其他类，由于java是单继承，所以只能实现runnable接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThread run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>这里值得一提的是，start方法是启动一个线程，线程处于就绪状态，而run方法则是直接执行，线程进入了运行状态。start方法之后会直接执行完毕，等待后续cpu的调度来执行这个线程，如果是run方法则直接在当前线程运行了方法，影响接下来的代码。因此只有start方法才能是多线程执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).run();</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 输出两个main 如果是start方法，输出不同线程。</span></span><br></pre></td></tr></table></figure></p><p>通常情况下如果需要一个异步操作，那直接在类里new Thread实例并传入Runnable实例，重写run方法就可以简单实现一个多线程操作，但这种方法并不提倡。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></p><h2 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h2><p>前面说了创建线程的方式，那为什么阿里不让程序员这样创建线程呢？原因在于以下几点：</p><ul><li>每次new Thread实例性能会逐渐变差。</li><li>线程没法统一管理，容易出现线程无限制创建，严重会有线程间相互竞争导致死锁，再严重些会导致占用过多资源而导致OOM。   </li></ul><p>而相比于new Thread，Java中提供的四种线程池有几点好处：</p><ul><li>在创建和销毁线程时所消耗时间与系统资源的开销大幅度减小。  </li><li>可以提供定时执行，并发控制等高级功能。 </li></ul><h2 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h2><p>Java中通过Executors提供四种线程池，分别为：  </p><ul><li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</li><li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。  </li></ul><p>Executors源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">            (parallelism,</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">            (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, threadFactory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>我们查看源码可以知道，Executors类使用了ThreadPoolExecutor类创建了一个简单线程池。我们接着跟进ThreadPoolExecutor类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们得知，ThreadPoolExecutor提供了四种构造器，但前三种构造器其实是调用了第四种构造方法而已。接下来看看几个参数的作用：  </p><ul><li>corePoolSize： 线程池核心线程数最大值</li><li>maximumPoolSize： 线程池最大线程数大小</li><li>keepAliveTime： 线程池中非核心线程空闲的存活时间大小</li><li>unit： 线程空闲存活时间单位</li><li>workQueue： 存放任务的阻塞队列</li><li>threadFactory： 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。</li><li>handler：  线城池的饱和策略事件，主要有四种类型。  </li></ul><p>我们可以看看源码中线程池的执行流程，即execute方法，源码中的注释已经十分清楚。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>翻译一下： </p><ul><li>提交一个任务，如果线程池中存活的核心线程小于线程数corePoolSize，线程池会创建一个核心线程去处理提交的任务。</li><li>如果核心线程池已满，一个新的任务会放到任务队列workQueue中排队等待执行。</li><li>当corePoolSize已满，并且workQueue也满，判断线程数是否达到maximumPoolSize，如果没达到，就创建一个非核心线程来执行任务。</li><li>如果线程数达到maximumPoolSize，直接采取拒绝策略。</li></ul><p>顺带一提四种拒绝策略： </p><ul><li>AbortPolicy(抛出一个异常，默认的)</li><li>DiscardPolicy(直接丢弃任务)</li><li>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</li><li>CallerRunsPolicy（交给线程池调用所在的线程进行处理) </li></ul><p>至此，线程池的工作原理基本上讲完了。但在阿里巴巴Java开发手册中有这么一条：  </p><blockquote><p>【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors返回的线程池对象的弊端如下： 1） FixedThreadPool和SingleThreadPool： 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。 2） CachedThreadPool： 允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。  </p></blockquote><p>仔细看源码，确实Executors在创建线程池时，workQueue并没有指定最大大小，可能会导致堆积大量的请求，即没有实行拒绝策略。 </p><h2 id="线程池的工作队列"><a href="#线程池的工作队列" class="headerlink" title="线程池的工作队列"></a>线程池的工作队列</h2><ul><li>ArrayBlockingQueue：有界队列，使用数组实现，FIFO。</li><li>LinkedBlockingQueue：基于链表的可设置容量的阻塞队列，默认最大长度为Integer.MAX_VALUE。</li><li>DelayQueue：延迟队列，是一个任务定时周期的延迟执行的队列。根据指定的时间从小到大排列，否则否则根据插入到队列的时间先后排序。</li><li>PriorityBlockingQueue：优先级队列。</li><li>SynchronousQueue：同步队列，不存储元素，每个插入操作必须等到另一个线程进行移除操作，否则一直阻塞。</li></ul><h2 id="几种常见线程池"><a href="#几种常见线程池" class="headerlink" title="几种常见线程池"></a>几种常见线程池</h2><p>前面只是稍微提到几种线程池，这边详细说说每种线程池。</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>源码在上头，这里我就不贴了。可以知道，这个线程池特点是核心线程数与最大线程数相同，并且没有非空闲时间，即keepAliveTime为0，再有就是阻塞队列使用的是LinkedBlockingQueue。<br>在Executors中newFixedThreadPool的阻塞队列是无界的，也就是如果核心线程执行的时间过长，会导致大量的任务插入到队列中，最终导致OOM。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; Integer.MAX_VALUE;i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded</span></span><br></pre></td></tr></table></figure></p><p>因此fixedThreadPool适用于cpu密集的任务，cpu长期被使用的情况下，尽可能少分配线程，适合执行长期的任务。  </p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>这个线程池的核心线程数为0，最大线程数为Integer.MAX_VALUE，阻塞队列为SynchronousQueue，非核心线程的空闲存活时间为60秒。<br>因为没有核心线程，所以添加任务后直接添加进阻塞队列，判断是够有空闲进程，如果有，取出去执行任务，如果没有，就创建一个线程执行，执行完任务的线程有60秒的存活时间，如果再次接到任务，则可以活下去，否则被销毁。<br>这种线程池适合并发执行短期的小任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"   "</span> + System.currentTimeMillis() + <span class="string">"   running now"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如果提交任务速度小于处理任务的速度，则只会使用一个线程重复使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"   "</span> + System.currentTimeMillis() + <span class="string">"   running now"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>特点为核心线程数为1，最大线程数也为1，阻塞队列是LinkedBlockingQueue，keepAliveTime为0。<br>这个线程池的特点就是只有一个线程在工作，如果有任务到来，线程空闲就执行任务，线程繁忙就把任务加到阻塞队列中，直到线程从队列中取出任务执行。<br>适合串行执行任务的场景。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"   "</span> + System.currentTimeMillis() + <span class="string">"   running now"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>特点是最大线程数为Integer.MAX_VALUE，阻塞队列是DelayedWorkQueue，keepAliveTime为0。<br>工作机制为：添加一个任务到阻塞队列中，线程池中的线程从阻塞队列中取任务，取time大于当前时间的任务，执行完将任务的time修改为下次执行的时间，并将这个任务放到阻塞队列中。<br>这种线程池适合周期执行定时任务的场景。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        executorService.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"   "</span> + System.currentTimeMillis() + <span class="string">"   running now"</span>);</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h1><p>本文讲了Java中四种常见的线程池，并学习相应的工作原理与应用常见，尽管阿里开发手册中不允许直接使用Executors中的线程池，但理解这几种线程池十分重要，如果需要创建线程池的话，可以通过ThreadPoolExecutor自定义所有参数来创建，让代码阅读者明白为什么要这样创建。通过这次的学习，对java线程池的理解确实有学到不少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇来讲讲Java中线程池的使用与分析。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="编程" scheme="http://re0.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="java" scheme="http://re0.top/tags/java/"/>
    
  </entry>
  
</feed>
